<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2018s on Xuanwo&#39;s Blog</title><link>https://xuanwo.io/2018/</link><description>Recent content in 2018s on Xuanwo&#39;s Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 27 Dec 2018 02:00:00 +0000</lastBuildDate><atom:link href="https://xuanwo.io/2018/index.xml" rel="self" type="application/rss+xml"/><item><title>日本旅游不完全踩坑记录</title><link>https://xuanwo.io/2018/12/27/pit-stepping-record-for-japan/</link><pubDate>Thu, 27 Dec 2018 02:00:00 +0000</pubDate><guid>https://xuanwo.io/2018/12/27/pit-stepping-record-for-japan/</guid><description>&lt;p&gt;日本游记持续难产中，先写篇文章记录一下自己这一趟日本之旅踩过的坑~&lt;/p&gt;
&lt;h2 id=&#34;签证&#34;&gt;签证&lt;/h2&gt;
&lt;p&gt;赴日旅游签证大概有下面几个需要注意的地方：&lt;/p&gt;
&lt;p&gt;日本签证原则上都需要通过指定的代办机构进行办理，也就是说整个流程是你把资料送给代办机构，代办机构负责审核，然后代办机构把资料送给大使馆，大使馆那边基本上是不做审核的，如果出了问题是由代办机构负责。找一个靠谱的代办机构可以免掉很多麻烦。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为上述的原因，整个准备签证材料的过程其实是很有弹性的，只要给的钱够，代办机构可以帮你准备（伪造）好所有的材料，也就是所谓的极简套餐。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果没有什么特殊情况的话，需要申请的是 &lt;a href=&#34;https://www.cn.emb-japan.go.jp/consular/visa_dantai.htm&#34;&gt;&lt;strong&gt;中国人赴日个人旅游签证&lt;/strong&gt;&lt;/a&gt;。这个签证需要准备&lt;a href=&#34;https://www.cn.emb-japan.go.jp/consular/joho180301.htm&#34;&gt;这些材料&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;护照&lt;/li&gt;
&lt;li&gt;签证申请表&lt;/li&gt;
&lt;li&gt;个人信息处理同意书&lt;/li&gt;
&lt;li&gt;户口本等，能确认本人居住地的资料&lt;/li&gt;
&lt;li&gt;能确认经济能力的资料&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;护照是肯定要的，一些申请表和同意书也是流程，剩下的两个材料比较关键：一个用来确定你的居住地，一个用来确认经济能力。我展开说一下：&lt;/p&gt;
&lt;p&gt;居住地涉及到日本在中国各个领事馆的&lt;a href=&#34;https://www.cn.emb-japan.go.jp/consular/visa_dantai.htm&#34;&gt;管辖区域&lt;/a&gt;，比如江苏省归驻上海总领事馆管辖。比如我是江苏人，现在在北京工作，那如果想要申请签证的话有两个路子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获得北京市居住证（相当于替代了自己的户籍地），就职的公司在北京&lt;/li&gt;
&lt;li&gt;户籍在江苏，填写的公司是在上海的分公司&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;北京居住证来不及办了，因此我选择了在上海领区申请签证。&lt;/p&gt;
&lt;p&gt;经济能力需要通过国际信用卡，在职证明和银行流水之类的提供，但是如果你是就读于中国教育部直属大学的在校生、研究生或者毕业于该校三年以内的毕业生，那就只要提交自己的毕业证书和学信网的学籍验证报告。&lt;/p&gt;
&lt;p&gt;从提交材料到最后拿到签证大概需要两周的时间，如果可以的话最好来回都用顺丰快递。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;应朋友的请求，实名吐槽一下中青旅淘宝店：三个工作人员三个不同的出签时间，有说从寄出材料开始计算的，有从旅行社收到材料开始计算的，有从大使馆收到材料才开始计算的，保证 10 个工作日出签这句话可以随意解释。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后我是买了携程自营的一个套餐，感觉还是比较靠谱，各个环节记录都非常清晰，交接流程也很完善，支持在你实际邮寄资料之前预审查：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;apply-visa.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;机票&#34;&gt;机票&lt;/h2&gt;
&lt;p&gt;买机票之前推荐先看看 &lt;a href=&#34;https://www.skyscanner.net/&#34;&gt;skyscanner&lt;/a&gt;，支持低价日历，可以同时搜索多个机票网站，有时候还有从 skyscanner 跳转还有专门的优惠。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实名批评一下同程网，给出的飞机票价比最后实际付款的时候要低不少，我到最后付款的时候才发现，差点被坑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们一开始想买巴基斯坦航空的飞机票，但是时间不太合适而且巴基斯坦航空之前也出过一些事故，对它印象不太好，于是加钱上了日本航空。去程是 &lt;a href=&#34;https://flightaware.com/live/flight/JAL860&#34;&gt;JL860&lt;/a&gt;，11:30 从北京起飞，16:05 到成田机场，返程是 &lt;a href=&#34;https://flightaware.com/live/flight/JAL21&#34;&gt;JL021&lt;/a&gt;，09:05 从羽田机场起飞，12:20 到北京，往返一共 2995 元。&lt;/p&gt;
&lt;p&gt;日本航空体验还是不错的，飞机餐大概是下图这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;food-on-plane.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;有水果，有哈根达斯（这是我人生第二次&amp;amp;第三次吃上哈根达斯- -），还有个小面包，去程的时候小菜是三明治+纳豆，返程的时候给的是蔬菜沙拉。&lt;/p&gt;
&lt;p&gt;机上娱乐系统感觉还是挺有意思的，有一个小的手柄，甚至还有 L 和 R 键~&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;handle-on-plane.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;我用这个手柄玩了好一会儿的俄罗斯方块。&lt;/p&gt;
&lt;p&gt;要说有啥不足的话就是日航的飞机好像没啥人权，停机坪到起飞跑道特别远，往返都在地面上转了好久。&lt;/p&gt;
&lt;h2 id=&#34;住宿&#34;&gt;住宿&lt;/h2&gt;
&lt;p&gt;住宿的话我们主要主要看 Booking 和 Airbnb。&lt;/p&gt;
&lt;p&gt;Booking 的话会有很多活动，在下单之前可以先留意下，很容易就能找到八折之类的优惠。有的时候如果登记的名字是错的或者种种原因导致订单查不到的话，把 Booking App 上的 &lt;code&gt;Confirmation Number&lt;/code&gt; 给前台看一下就好。&lt;/p&gt;
&lt;p&gt;我们这一趟分别住了&lt;a href=&#34;https://www.booking.com/hotel/jp/ginza-kokusai.zh-cn.html&#34;&gt;银座国际酒店&lt;/a&gt;和&lt;a href=&#34;https://www.booking.com/hotel/jp/pressance-kitahama-by-wbf.zh-cn.html&#34;&gt;WBF 北滨酒店&lt;/a&gt;。银座国际酒店虽然名头很响亮，但其实并不是非常国际，前台在三层，房间不大，但是各种设施都很齐全。好处是价格也不是非常国际，位置非常好，新桥站出来走几分钟就到，距离繁华的银座非常近，到筑地市场也很近。WBF 是一个连锁酒店的品牌，我朋友戏称是 &lt;code&gt;日本全季&lt;/code&gt;。在大阪的门店尤其多，服务挺 nice 的，前台的英文水平也很 OK，虽然遇到了订单没有查到的问题，但是简单沟通一下之后就搞定了。这个酒店距离地铁站大概 10 分钟脚程，距离大阪城也挺近的，走过去的路上顺便吃个早饭然后逛逛刚刚好。&lt;/p&gt;
&lt;p&gt;有一个有意思的现象是这两个酒店完全不是同一个类型，也不是同一个集团，但是他们的很多细节都是一样的。比如水龙头是同款，沐浴液，洗发液是同款，以至于我们都在怀疑这是不是日本酒店什么的标准。&lt;/p&gt;
&lt;p&gt;后面四天住的是 Airbnb，这就有点一言难尽了。首先是文化冲突（房主的故意误导？）：我们需要两间房，结果到了实地一看才发现所谓的两间房只不过是用纸门隔起来的一个小房间，用我们这边话来说就是一室一厅，还需要在客厅铺上一张床。房主用他独特的的摄影技巧成功的骗到了我，让我以为他家是一个两室一厅的豪宅= =。我们刚坐下来的时候讨论的第一件事情甚至是要不要把房子退了去找个酒店住，后来还是作罢，想着忍忍得了。&lt;/p&gt;
&lt;p&gt;真的住下来之后，度过了前期的适应阶段，开始觉得这房子坑是坑了点，但也不是一无是处。房子在居民区，晚上挺安静，只有偶尔呼啸而过的车声，几乎就在 Tokyo Skytree 脚底下。每天早上出门和晚上回来的时候，都能看上好一会儿。距离地铁站非常近，路上还有一个 711，我们在他们家门口解决了很多顿早餐。&lt;/p&gt;
&lt;h2 id=&#34;上网&#34;&gt;上网&lt;/h2&gt;
&lt;p&gt;一般情况下，海外上网有两个 Option：一个是 Wifi，一个是流量卡。Wifi 是给你一个便携设备，专门用来开热点，有时候还有一些附加的服务，比如地图和翻译之类的；流量卡就是一个卡，直接放到手机里面就能用。我个人还是更加倾向于每个人买一个单独的流量卡，因为很难保证所有人都一起活动，而且如果万一走丢了，手机没法上网就很坑爹了。&lt;/p&gt;
&lt;p&gt;有两个需要注意的点：&lt;/p&gt;
&lt;p&gt;第一个是注意卡的类型，在日本能打电话的卡都很贵，可用的通话时长也就是 30 分钟这种水平，大部分卖的卡还是纯的流量卡，不能打电话，建议使用微信或者 Telegram 替代。某些运营商还会有一些限制，比如 iPhone 上不能开热点分享。&lt;/p&gt;
&lt;p&gt;第二个是注意卡的限速，我非常奇怪作为一个发达的资本主义国家，流量居然这么抠门= =，可能是因为单个基站下用户量太大了。一般来说，一张卡从激活的时候开始计算，每 24 个小时为一个周期，每个周期如果超过 1G （估算的值，有时候在更少的流量就开始了）就会限速到 128Kbps。如果连续多个周期超过限制，还会有更加严格的限速策略。所以一定要注意流量的使用情况，要不然连微信和 Tg 消息都刷不出来，非常头疼。&lt;/p&gt;
&lt;p&gt;酒店和住宿的地方大多会提供热点，不限速不限量，可以回了酒店之后再上传照片和视频，需要注意的时候这些热点用的手机大多要求不能带出门，最好遵守他们的规定。&lt;/p&gt;
&lt;p&gt;抛开坑爹的限速策略之外，日本的网络覆盖是真的好，在东京深深的地下铁还能保持 4G 不掉，难怪怪物弹珠这种游戏能火起来了。&lt;/p&gt;
&lt;h2 id=&#34;交通&#34;&gt;交通&lt;/h2&gt;
&lt;p&gt;如果交通方面只能给出一个建议的话：&lt;strong&gt;请安装 Google Maps&lt;/strong&gt;。非常详细的路径规划，精确到分钟的发车时间，具体的换乘提示，基于 GPS 的提醒。到了异国他乡，Google Maps 展现了它的真实水平，虽然好像不能离线规划和导航，不过日本良好的网络覆盖也基本用不着这个功能，值得一提的是，就算在 128Kbps 限速下，它仍然工作正常（这很关键 = =）。&lt;/p&gt;
&lt;p&gt;此外，如果你需要往返东京，大阪，富士山，成田机场这四个中的两个以上的话，建议购买一个 JR Pass。JR Pass 是由 JR 集团 6 家公司共同提供的通票，是用铁道游遍日本的最经济实惠的车票。我举个栗子：7 日的成人 JR Pass 票是 29110 日元，往返东京和大阪的 JR 新干线票价是 29300 日元。同时 JR Pass 还能够用来乘坐很多市内的地铁，非常好用。&lt;/p&gt;
&lt;p&gt;对于一般的 JR 站，只需要在入口处出示 JR Pass 给工作人员看就行，只能走人工通道，不能走自动检票的闸机。对于一些需要预留座位的线路，则需要去 JR 的人工购票的窗口去换票，跟工作人员说要去哪里，然后选一下想要的车次就行。需要注意的是不能选希望（Nozomi）和瑞穗（Mizuho）这两个线路，其他的都是 OK 的。&lt;/p&gt;
&lt;p&gt;除了 Japan Railways 之外，还有其他的公司和组织运营的线路，可以买 Suica 卡或者按照自己的行程安排买每个城市的畅游卡，这样会比较方便，不需要每一次做地铁都用现金买票。Suica 卡购买的时候会需要 500 日元的制卡费，在返程的时候可以退，如果卡内余额需要退出来的话，还额外需要 220 日元的手续费，而且羽田机场的退卡处队排的很长，需要一个多小时 = =。所以建议要么尽量把卡里的余额用完，要么就不要退卡了，直接带回家做纪念品。&lt;/p&gt;
&lt;h2 id=&#34;杂项&#34;&gt;杂项&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果用招行的全币种 VISA 卡，有时候店员会让选择美元记账还是日元记账，记得要选择日元，否则可能会被收一笔 DCC，参见&lt;a href=&#34;https://www.douban.com/note/508378675/&#34;&gt;这篇文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果要退税的话可以在结帐的时候跟店员说 tax free，然后他会在护照上钉上账单，这样拿到就是免税的价格。需要达到 5000 日元才能免税，而且消耗品和非消耗品是要分开计算的，有些店也会专门标出本层商品需要在本层结帐，这些都是不能算到一起，而且免税商品在回国之前不能打开。&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>随缘分享第 1 期</title><link>https://xuanwo.io/2018/12/15/share-with-luck-1st/</link><pubDate>Sat, 15 Dec 2018 06:05:00 +0000</pubDate><guid>https://xuanwo.io/2018/12/15/share-with-luck-1st/</guid><description>&lt;p&gt;每周分享实在做不到，但是随缘分享还是可以的，内容大体上会跟之前的动态有些交叉~&lt;/p&gt;
&lt;h2 id=&#34;workflowy-复活&#34;&gt;Workflowy 复活&lt;/h2&gt;
&lt;p&gt;Workflowy 自从有一个 PM 和设计师之后，感觉整个产品复活了。前端使用 React + TypeScript 彻底重写，有了全新的设计，清理掉了一大堆旧代码，甚至开始提供 &lt;a href=&#34;https://workflowy.com/s/workflowy-extension-api/6ziauXitmUj7idN2&#34;&gt;Extension API&lt;/a&gt; 了！&lt;/p&gt;
&lt;p&gt;读着他们的博文 &lt;a href=&#34;https://blog.workflowy.com/2018/12/11/new-year-new-code/&#34;&gt;New Year, New Code&lt;/a&gt;，我感到非常激动且开心。激动于一些期待已久的功能终于可以实现，开心于一个快十年的老产品还能够这样焕发生机。&lt;/p&gt;
&lt;p&gt;Android 和 iOS 的 App 也都重写了，&lt;a href=&#34;https://blog.workflowy.com/2018/12/14/better-daily-digests-a-splash-of-color-in-your-inbox/&#34;&gt;每日推送的摘要&lt;/a&gt; 也支持了类似于 git diff 一样的效果，欢迎各位用过或者没有用过 Workflowy 的童鞋来体验一下，有余力有需求的话也可以买个 WorkFlowy Pro 以最实际的方式支持开发者~&lt;/p&gt;
&lt;h2 id=&#34;enpass-6-体验&#34;&gt;Enpass 6 体验&lt;/h2&gt;
&lt;p&gt;最近正好有人请求打包 enpass-beta-bin，于是我就把这个包加到了 archcn 源里面，并将自己本地和 iOS 上的 enpass 都升级了一下。&lt;/p&gt;
&lt;p&gt;新的版本最大的变化就是支持多个 Vault：每个 Vault 彼此之间完全独立，可以设置不一样的 Master Password。Vault 的同步也是分开的，以 Google Drive 为例，一个 Google 帐号只能同步一个 Vault。同步的实现机制也有变化，原来是单纯的把加密之后的文件同步到一个文件夹下面，现在开始使用各个网盘提供的 App Folders 功能，现在用户以及其他应用已经不能直接访问到同步的文件。可能会有些不太方便，但是更加安全，我还是比较欣赏这个改动的。&lt;/p&gt;
&lt;p&gt;功能上还有的变化是支持自定义类型和模板，这是用户一直想要的功能，原来受限于软件架构问题无法实现，现在在重写之后的 Enpass 6 里终于有了。Enpass 6 还将只有浏览器有的登录助手带到了桌面上，现在点击图标默认会出现这个助手而不是完整的应用界面。这个改动我不太喜欢，背后的逻辑可能是认为用户的查询操作更加频繁，因此需要一个精简版的入口，但是从我的实际体验上来看，我打开 Enpass 就是想要增加或修改条目，查询基本上只会在浏览器端登录的时候做。&lt;/p&gt;
&lt;p&gt;对浏览器的支持也重新实现了，现在浏览器插件和主程序之间首次通信会进行一次认证，大体上类似于蓝牙链接一样，主程序这边要生成一个随机的 6 位数字，浏览器插件需要输入一样的数字之后才能连接。这大大提升了浏览器插件这一端的安全性：原有的实现依赖于校验浏览器本身是否可信，在 Linux 上这个功能完全不可用，现在的这种方式可以防止奇怪的浏览器或者插件访问我们敏感的数据了~&lt;/p&gt;
&lt;p&gt;除了功能之外的大变化就是 UI 和交互了，整体上变得更加时髦了，虽然现在用起来感觉不是非常好用 - -!，相信后续还是会不断改善。最起码现在我用 1password 的朋友们看了新界面之后会说一句不丑，比原来的好多了（。&lt;/p&gt;
&lt;p&gt;老毛病还是有：对 CJK 字符的支持没有，应该是没有带上 fcitx 的 qt 插件，这个已经跟上游反馈了，或许下次（?）更新就会修好吧。然后因为是 Beta 版本，所以体验上还不是非常好，很多细节的地方都打磨的不太精致。&lt;/p&gt;
&lt;p&gt;此外在 Archlinux 上配置同步的话可能会遇到一些问题：配置的时候会打开对应网盘的登录界面，进行一次标准的 OAuth2 认证流程，然后会访问一个 &lt;code&gt;enpassauth://&lt;/code&gt; 的链接，但是此时 &lt;code&gt;xdg-open&lt;/code&gt; 会打开一个全新的 enpass 实例，导致之前的那个 enpass 没有办法收到这个回调。&lt;/p&gt;
&lt;p&gt;跟 Enpass 反馈之后他们表示这是一个实现上的问题，之后会予以修复。一个可行的 workaround 是在命令行使用 &lt;code&gt;xdg-open enpassauth://&lt;/code&gt; 打开 enpass 并配置同步，此时 enpass 可以正确的响应这个回调。&lt;/p&gt;
&lt;p&gt;Enpass 6 目前还处在 Beta 的阶段，感兴趣的童鞋可以体验一下，在 Archlinux 上使用有问题的话可以反馈给我~&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;安装 Enpass 6 第一次启动会自动升级原有的数据，此升级不可逆，如果还想回去的话，记得备份好数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;用 Arch 的同学可以直接安装： &lt;code&gt;pacman -S enpass-beta-bin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用 iOS 的同学可以通过 TestFlight 来直接参与测试：&lt;a href=&#34;https://testflight.apple.com/join/hIec0gli&#34;&gt;https://testflight.apple.com/join/hIec0gli&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;还没有用过的同学可以看看这篇&lt;a href=&#34;https://xuanwo.io/2017/11/26/enpass-intro/&#34;&gt;安利文&lt;/a&gt; 了解一下&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;game&#34;&gt;Game&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;最近想完成全弓箭收集的成就，大概保持着每天做半把的节奏，现在做到了尸套龙弓（然后发现自己没钱了），尸套龙还是比较好打，带上龙封力的武器，出门带上闪光弹，路上拣一点松明弹和可燃石基本上没啥问题，只要注意不要被秒&lt;/li&gt;
&lt;li&gt;有天晚上怎么都连不上集会所，于是玩了一会儿会免的重力异想世界，头有点晕 - -&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;travel&#34;&gt;Travel&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;下周要去日本了，第一次出国，有点紧张&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;miscellaneous&#34;&gt;Miscellaneous&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;现在大家好像都在倡导搁置 code style 的争议，gofmt 和 rustfmt 都是已经成为了各自社区的主流，js 这边也有一个类似的项目： &lt;a href=&#34;https://prettier.io/&#34;&gt;https://prettier.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;最近学到一个新词：&lt;code&gt;event storming&lt;/code&gt;，好像一般翻译成事件风暴，用于动态业务流程的分析，&lt;a href=&#34;https://www.eventstorming.com/&#34;&gt;https://www.eventstorming.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://openmessaging.cloud/&#34;&gt;OpenMessaging&lt;/a&gt;，名字非常酷炫，是一个阿里牵头搞的云原生，厂商独立的分布式消息规范，schema 我不是非常喜欢，这么搞还不如发 HTTP/2 的包呢&lt;/li&gt;
&lt;li&gt;隐私在当下成为了一个越来越重要的话题，这里 &lt;a href=&#34;https://ssd.eff.org/en&#34;&gt;https://ssd.eff.org/en&lt;/a&gt; 给出了一些保护自己隐私的方案和实践&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/grafana/loki&#34;&gt;loki&lt;/a&gt; 是 grafana 推出的一个类似于 Prometheus 的日志收集工具，主打的特性是简单便宜，支持从 Prometheus 无缝迁移，提供了对 k8s pod 日志的良好支持，会自动抓取和索引相关的标签，grafana 中会提供原生的支持&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bazelbuild/starlark&#34;&gt;starlark&lt;/a&gt; 是一个形似于 Python 的配置语言，而 &lt;a href=&#34;https://github.com/google/starlark-go&#34;&gt;starlark-go&lt;/a&gt; 是由 Google 的工作人员推出的 go 实现，用于他们自己的编译工具 bazel&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>博客升级至 v2.0</title><link>https://xuanwo.io/2018/12/03/bump-to-version-2.0/</link><pubDate>Mon, 03 Dec 2018 09:05:00 +0000</pubDate><guid>https://xuanwo.io/2018/12/03/bump-to-version-2.0/</guid><description>&lt;p&gt;Xuanwo&amp;rsquo;s Blog 升级至 2.0 啦&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;停一下，先别动手，我不是标题党，听我解释！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在域名切换成 &lt;code&gt;xuanwo.io&lt;/code&gt; 的时候，我重写了 &lt;a href=&#34;https://xuanwo.io/about/&#34;&gt;About Me&lt;/a&gt;。在写的时候我就在想每个人都会有不同的侧面，与此同时每个人也会有每个人想要看到的侧面。因此我按照归属的次元不同重新组织了一下我的博客：&lt;/p&gt;
&lt;h2 id=&#34;anime&#34;&gt;Anime&lt;/h2&gt;
&lt;p&gt;动漫相关的内容，动漫相关的周边相关的内容也会发在这个分类下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文章列表：&lt;a href=&#34;https://xuanwo.io/categories/anime/&#34;&gt;https://xuanwo.io/categories/anime/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;RSS 订阅：&lt;a href=&#34;https://xuanwo.io/categories/anime/index.xml&#34;&gt;https://xuanwo.io/categories/anime/index.xml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;
&lt;p&gt;编程/技术相关的内容都会在这个分类下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文章列表：&lt;a href=&#34;https://xuanwo.io/categories/code/&#34;&gt;https://xuanwo.io/categories/code/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;RSS 订阅：&lt;a href=&#34;https://xuanwo.io/categories/code/index.xml&#34;&gt;https://xuanwo.io/categories/code/index.xml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;daily&#34;&gt;Daily&lt;/h2&gt;
&lt;p&gt;日常（灌水）内容，一些心情相关的无病呻吟也会发在这个分类下，同时这个分类会取代之前每篇文章末尾的动态章节。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文章列表：&lt;a href=&#34;https://xuanwo.io/categories/daily/&#34;&gt;https://xuanwo.io/categories/daily/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;RSS 订阅：&lt;a href=&#34;https://xuanwo.io/categories/daily/index.xml&#34;&gt;https://xuanwo.io/categories/daily/index.xml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;game&#34;&gt;Game&lt;/h2&gt;
&lt;p&gt;游戏相关的内容会进这个分类啦，可能的内容大概会包括自己最近正在玩的游戏和一些感想。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文章列表：&lt;a href=&#34;https://xuanwo.io/categories/game/&#34;&gt;https://xuanwo.io/categories/game/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;RSS 订阅：&lt;a href=&#34;https://xuanwo.io/categories/game/index.xml&#34;&gt;https://xuanwo.io/categories/game/index.xml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;后续大概还会启用 Novel， Music 这些分类，不过暂时没有什么想写的，就先不提了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不管你觉得熟悉还是陌生，他们都是我，区别只是在于你是否知道~&lt;/p&gt;
&lt;/blockquote&gt;</description></item><item><title>你好，加藤惠</title><link>https://xuanwo.io/2018/12/03/hello-katou-megumi/</link><pubDate>Mon, 03 Dec 2018 08:05:00 +0000</pubDate><guid>https://xuanwo.io/2018/12/03/hello-katou-megumi/</guid><description>&lt;p&gt;&lt;strong&gt;死宅真恶心&lt;/strong&gt; 警告&lt;/p&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;嗯，啊，是的呢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前段时间拜托 fc 教授从日本寄了一套&lt;del&gt;老婆&lt;/del&gt;路人女主的原作小说回来，今天终于到了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从日本来的快递&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;package-from-japan.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;裹在塑料膜中的&lt;del&gt;老婆&lt;/del&gt;小说&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;wife-in-package.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先简单拍一张&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;quick-shot.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rua ！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;rua.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全家福&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;hotchpotch.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单独拍照&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;katou-megumi-1.jpg&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;katou-megumi-2.jpg&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;katou-megumi-3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有趣的邮票&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;stamps.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description></item><item><title>再见，xuanwo.org</title><link>https://xuanwo.io/2018/12/02/goodbye-xuanwo-org/</link><pubDate>Sun, 02 Dec 2018 08:05:00 +0000</pubDate><guid>https://xuanwo.io/2018/12/02/goodbye-xuanwo-org/</guid><description>&lt;p&gt;一句话新闻：启用新域名 &lt;code&gt;xuanwo.io&lt;/code&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;影响&#34;&gt;影响&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;个人域名切换到了 &lt;code&gt;xuanwo.io&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;所有指向 &lt;code&gt;xuanwo.org&lt;/code&gt; 请求都会被 301 到 &lt;code&gt;xuanwo.io&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所有发往 &lt;code&gt;xuanwo.org&lt;/code&gt; 域的邮件暂时不受影响&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xuanwo.org&lt;/code&gt; 域名有效期到 2019 年末，目前还没有决定是否要续费&lt;/li&gt;
&lt;li&gt;RSS 订阅用户可能需要修改订阅地址（RSS 订阅会 follow 301 么？）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;动态&#34;&gt;动态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;其实本来写了长长的告别文，回顾了过去 4 年间 xuanwo.org 的变迁，都快把自己感动哭了，但是在发布之前还是都删了，换个域名而已&lt;/li&gt;
&lt;li&gt;上周的时候朋友 A 来北京玩
&lt;ul&gt;
&lt;li&gt;跟着朋友 D 三人一起吃了顿捞王&lt;/li&gt;
&lt;li&gt;下午参观了 798，看了不少自己看不懂但是感觉很有意思的展&lt;/li&gt;
&lt;li&gt;晚上一起去了 tunight，看朋友 H 折腾了一晚上 Sony DPT 的 Android Xposed Hook，很是有意思&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;这周六跟朋友 K 见面，下次尝试了一下电影大串烧
&lt;ul&gt;
&lt;li&gt;先是看了《无名之辈》，电影很好看，虽说最后 20 分钟有点崩的厉害，但是并不是非常影响整理观感，最后的同名主题曲也非常好听&lt;/li&gt;
&lt;li&gt;然后二刷了《无敌破坏王 2》，因为之前看过了，加上晚上没有休息好，所以看到中途的时候还睡着了一会儿（并不是说它不好看啊喂）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;周日的时候参加了北航办的 !fs ，看到了可爱的 Rynco 酱，还有女装的小姐姐（还上去问了是不是女装大佬，结果发现是真小姐姐，丢人）&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>记一次 btrfs 的在线转换</title><link>https://xuanwo.io/2018/11/15/record-for-btrfs-conversion/</link><pubDate>Thu, 15 Nov 2018 13:05:00 +0000</pubDate><guid>https://xuanwo.io/2018/11/15/record-for-btrfs-conversion/</guid><description>&lt;p&gt;在 archcn 群里听 &lt;a href=&#34;https://farseerfc.me/&#34;&gt;fc 教授&lt;/a&gt; 安利了有一段时间了，终于在一个心情不是非常美好的晚上决定上一波 btrfs ，这篇文章主要分享这次转换中遇到的一些有趣的故事~&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;btrfs-是什么以及为什么&#34;&gt;btrfs 是什么以及为什么？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Btrfs（B-tree文件系统，通常念成Butter FS，Better FS或B-tree FS），一种支持写入时复制（COW）的文件系统，运行在Linux操作系统，采用GPL授权。Oracle于2007年对外宣布这项计划，并发布源代码，在2014年8月发布稳定版。目标是取代Linux目前的ext3文件系统，改善ext3的限制，特别是单个文件的大小，总文件系统大小或文件检查和加入ext3未支持的功能，像是可写快照（writable snapshots）、快照的快照（snapshots of snapshots）、内建磁盘阵列（RAID），以及子卷（subvolumes）。Btrfs也宣称专注在“容错、修复及易于管理”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之所以想要换成 btrfs ，主要是因为以下几个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;btrfs 支持快照，可以方便备份和恢复&lt;/li&gt;
&lt;li&gt;btrfs 支持透明压缩&lt;/li&gt;
&lt;li&gt;btrfs 支持子卷，结合快照功能，可以作为启动 &lt;code&gt;systemd-nspawn&lt;/code&gt; 容器的模板&lt;/li&gt;
&lt;li&gt;btrfs 支持数据和元数据的校验&lt;/li&gt;
&lt;li&gt;btrfs 支持就地从 ext4 转换&lt;/li&gt;
&lt;li&gt;那天晚上心情不是很好，需要有个足够好玩的事情来吸引我的注意力&lt;/li&gt;
&lt;li&gt;这是我自己的电脑，我乐意（&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实我之前一直是坚定的 ext4 党，觉得 ext4 非常稳定，性能优秀，文件系统的高级功能平时也不怎么会用到，所以并不觉得 btrfs 好，反而经常在别人报告自己的 btrfs 翻车的时候在一旁吃瓜，滑稽的喊两句毫无营养的 &lt;em&gt;我选择 ext4&lt;/em&gt; 。但是后来我的想法慢慢的发生了变化，一方面是 fc 老师的持续安利和讲解，另一方面是自己对事物，或者说世界的看法也在变化：&lt;/p&gt;
&lt;h3 id=&#34;不要迷醉于虚假的安全之中&#34;&gt;不要迷醉于虚假的安全之中&lt;/h3&gt;
&lt;p&gt;ext4 可能确实是稳，确实是快，但是这是因为它默认没有开启 checksum 。 &lt;em&gt;（虽然没有横向对比过，但此处应使用肯定语气表示强调，只要你不说出来别人也不会去查）&lt;/em&gt; 如果出现了静默错误，ext4 毫无修复的能力，而 btrfs 则会在读取的时候进行校验并尝试去进行修复。&lt;/p&gt;
&lt;h3 id=&#34;吃瓜群众没有什么可骄傲的&#34;&gt;吃瓜群众没有什么可骄傲的&lt;/h3&gt;
&lt;p&gt;以前可能习惯的去当一个吃瓜群众，静静的围观各种事件的反转并自诩 &lt;em&gt;机智如我&lt;/em&gt; ，&lt;em&gt;我就知道会这样&lt;/em&gt; 。但是现在渐渐明白了，吃瓜群众只不过是没脑子罢了，被铺天盖地的信息轰炸的多了，失去了自己去查明真相的能力，只能被动的随着信息的浪潮四处漂游。醒醒吧，世界的发展和技术的进步并不是吃瓜群众推动的，如果我们不亲自下场去尝试，最后留在自己手中的只有瓜皮而已。&lt;/p&gt;
&lt;h2 id=&#34;匹夫之勇&#34;&gt;匹夫之勇&lt;/h2&gt;
&lt;p&gt;啊，废话说的有点多了，下面开始正题。&lt;/p&gt;
&lt;p&gt;首先熟读并背诵 Archwiki 中 btrfs 相关的条目，英文的也都仔细读一遍，防止有什么新的信息被遗漏了。敢于尝试新鲜事物是勇者，但是 archwiki 都不好好看，那就是莽夫了。确认重要的信息都 get 到之后，插上 U 盘进入 live 环境。&lt;/p&gt;
&lt;p&gt;在开始之前有几个比较重要的 Tips：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;备份&lt;/strong&gt;，&lt;strong&gt;备份&lt;/strong&gt;，&lt;strong&gt;备份&lt;/strong&gt;。如果是在没有条件全盘备份，起码把自己的 &lt;code&gt;ssh_key&lt;/code&gt;，&lt;code&gt;gpg_key&lt;/code&gt; 等重要文件都备份好，数据是你自己的，为了帅这一下，不值得。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;btrfs-convert&lt;/code&gt; 会保留原来 ext4 中的 metadata，并作为一个单独的子卷。因此只要保留着这个子卷，你就可以恢复成 ext4 。但是这是有条件的，显然的，btrfs 不可能去在线维护 btrfs 和 ext4 两个 metadata，在 convert 之后的 btrfs 分区中做出的变更将不会同步到 ext4 的 metadata 中。因此请在确认数据都没有问题的情况下再开机进入系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先执行一次 fsck，避免带病上阵：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;fsck.ext4 /dev/nvme0n1p2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后深呼吸三次，开始执行 &lt;code&gt;btrfs-convert&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;btrfs-convert /dev/nvme0n1p2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;convert.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在经过漫长的等待后，convert 没有翻车，已经成功一半啦！&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;success.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;接下来把分区挂在上来，检查一下是否有问题：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;mount /dev/nvme0n1p2 /mnt
mount /dev/nvme0n1p1 /mnt/boot&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;随机抽查了一些文件发现都 OK 之后，下面开始修改一些引导相关的配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改 &lt;code&gt;/etc/fstab&lt;/code&gt;，把 &lt;code&gt;type&lt;/code&gt; 修改为 &lt;code&gt;btrfs&lt;/code&gt;，把最后一行的 &lt;code&gt;fs_passno&lt;/code&gt; 修改为 &lt;code&gt;0&lt;/code&gt;，因为 btrfs 不在开机的时候做检查&lt;/li&gt;
&lt;li&gt;如果使用的是 UUID 之类的话，还可能会需要修改 UUID，不过我是用的 PARTUUID，信息存储在 GPT 分区表中，修改文件系统并不会变化，因此不需要修改&lt;/li&gt;
&lt;li&gt;因为转换的是根目录，因此还需要执行 &lt;code&gt;mkinitcpio -p linux&lt;/code&gt; 以重建内存盘，我使用的是 &lt;code&gt;linux-zen&lt;/code&gt; 内核，因此我还执行了 &lt;code&gt;mkinitcpio -p linux-zen&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果用的是 &lt;code&gt;systemd-boot&lt;/code&gt; 的话，不需要做什么额外的配置，用 grub 的同学要按照 wiki 的指示重新生成 &lt;code&gt;grub.config&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来就是我做的一些很勇的事情了，请各位同学不要模仿：为了能够充分用上 btrfs 的透明压缩功能，我对全盘执行了一次压缩并修改了 &lt;code&gt;/etc/fstab&lt;/code&gt; 的挂载参数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;btrfs filesystem defragment -r -v -clzo /mnt&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后提示有两个 failure，只是当时我还没有明白这意味着什么。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;failure.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;弱者之愁&#34;&gt;弱者之愁&lt;/h2&gt;
&lt;p&gt;在压缩完毕后我重启并成功进入系统，于是高兴的在 archcn 的群中宣扬了一番：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;alive.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;后来 fc 教授提醒我需要删除 &lt;code&gt;ext2_saved&lt;/code&gt; 并执行 &lt;code&gt;balance&lt;/code&gt;，然后真正的故事开始了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#666&#34;&gt;[&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;1868&lt;/span&gt;.392801&lt;span style=&#34;color:#666&#34;&gt;]&lt;/span&gt; BTRFS warning &lt;span style=&#34;color:#666&#34;&gt;(&lt;/span&gt;device nvme0n1p2&lt;span style=&#34;color:#666&#34;&gt;)&lt;/span&gt;: csum failed root -9 ino &lt;span style=&#34;color:#40a070&#34;&gt;465&lt;/span&gt; off &lt;span style=&#34;color:#40a070&#34;&gt;1048576&lt;/span&gt; csum 0x9302c07f expected csum 0x98f94189 mirror &lt;span style=&#34;color:#40a070&#34;&gt;1&lt;/span&gt;
&lt;span style=&#34;color:#666&#34;&gt;[&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;1868&lt;/span&gt;.393966&lt;span style=&#34;color:#666&#34;&gt;]&lt;/span&gt; BTRFS warning &lt;span style=&#34;color:#666&#34;&gt;(&lt;/span&gt;device nvme0n1p2&lt;span style=&#34;color:#666&#34;&gt;)&lt;/span&gt;: csum failed root -9 ino &lt;span style=&#34;color:#40a070&#34;&gt;465&lt;/span&gt; off &lt;span style=&#34;color:#40a070&#34;&gt;1048576&lt;/span&gt; csum 0x9302c07f expected csum 0x98f94189 mirror &lt;span style=&#34;color:#40a070&#34;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我的心情毫无波动，甚至有点想笑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;csum-failed.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;之后在 fc 教授的指导下，查看了 btrfs 相关的各种信息，最后通过 inode 跟踪到了这个对应的错误文件，那是一个 golang 项目的 vendor 文件，所以我直接把这个文件删掉并执行了 &lt;code&gt;scrub&lt;/code&gt; 任务。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;Nov &lt;span style=&#34;color:#40a070&#34;&gt;14&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;23&lt;/span&gt;:16:03 thinkpad-x1-carbon systemd&lt;span style=&#34;color:#666&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#40a070&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;]&lt;/span&gt;: Started Btrfs scrub on /.
Nov &lt;span style=&#34;color:#40a070&#34;&gt;14&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;23&lt;/span&gt;:16:47 thinkpad-x1-carbon btrfs&lt;span style=&#34;color:#666&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#40a070&#34;&gt;15376&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;]&lt;/span&gt;: ERROR: there are uncorrectable errors
Nov &lt;span style=&#34;color:#40a070&#34;&gt;14&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;23&lt;/span&gt;:16:47 thinkpad-x1-carbon btrfs&lt;span style=&#34;color:#666&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#40a070&#34;&gt;15376&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;]&lt;/span&gt;: scrub &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;done&lt;/span&gt; &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;for&lt;/span&gt; 86fd5394-5a32-43cd-8ef5-5f3fbd46056e
Nov &lt;span style=&#34;color:#40a070&#34;&gt;14&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;23&lt;/span&gt;:16:47 thinkpad-x1-carbon btrfs&lt;span style=&#34;color:#666&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#40a070&#34;&gt;15376&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;]&lt;/span&gt;: scrub started at Wed Nov &lt;span style=&#34;color:#40a070&#34;&gt;14&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;23&lt;/span&gt;:16:03 &lt;span style=&#34;color:#40a070&#34;&gt;2018&lt;/span&gt; and finished after &lt;span style=&#34;color:#40a070&#34;&gt;00&lt;/span&gt;:00:44
Nov &lt;span style=&#34;color:#40a070&#34;&gt;14&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;23&lt;/span&gt;:16:47 thinkpad-x1-carbon btrfs&lt;span style=&#34;color:#666&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#40a070&#34;&gt;15376&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;]&lt;/span&gt;: total bytes scrubbed: &lt;span style=&#34;color:#40a070&#34;&gt;72&lt;/span&gt;.40GiB with &lt;span style=&#34;color:#40a070&#34;&gt;16&lt;/span&gt; errors
Nov &lt;span style=&#34;color:#40a070&#34;&gt;14&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;23&lt;/span&gt;:16:47 thinkpad-x1-carbon btrfs&lt;span style=&#34;color:#666&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#40a070&#34;&gt;15376&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;]&lt;/span&gt;: error details: &lt;span style=&#34;color:#bb60d5&#34;&gt;csum&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#40a070&#34;&gt;16&lt;/span&gt;
Nov &lt;span style=&#34;color:#40a070&#34;&gt;14&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;23&lt;/span&gt;:16:47 thinkpad-x1-carbon btrfs&lt;span style=&#34;color:#666&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#40a070&#34;&gt;15376&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;]&lt;/span&gt;: corrected errors: &lt;span style=&#34;color:#40a070&#34;&gt;0&lt;/span&gt;, uncorrectable errors: &lt;span style=&#34;color:#40a070&#34;&gt;16&lt;/span&gt;, unverified errors: &lt;span style=&#34;color:#40a070&#34;&gt;0&lt;/span&gt;
Nov &lt;span style=&#34;color:#40a070&#34;&gt;14&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;23&lt;/span&gt;:16:47 thinkpad-x1-carbon systemd&lt;span style=&#34;color:#666&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#40a070&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;]&lt;/span&gt;: btrfs-scrub@-.service: Main process exited, &lt;span style=&#34;color:#bb60d5&#34;&gt;code&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;exited, &lt;span style=&#34;color:#bb60d5&#34;&gt;status&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#40a070&#34;&gt;3&lt;/span&gt;/NOTIMPLEMENTED
Nov &lt;span style=&#34;color:#40a070&#34;&gt;14&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;23&lt;/span&gt;:16:47 thinkpad-x1-carbon systemd&lt;span style=&#34;color:#666&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#40a070&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;]&lt;/span&gt;: btrfs-scrub@-.service: Failed with result &lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;exit-code&amp;#39;&lt;/span&gt;.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然场面上很慌，但是我的心态出奇的好，感觉非常刺激。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;scrub-failed.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;后来通过 &lt;code&gt;dmesg&lt;/code&gt; 查到了具体的出错信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#666&#34;&gt;[&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;3392&lt;/span&gt;.226163&lt;span style=&#34;color:#666&#34;&gt;]&lt;/span&gt; BTRFS warning &lt;span style=&#34;color:#666&#34;&gt;(&lt;/span&gt;device nvme0n1p2&lt;span style=&#34;color:#666&#34;&gt;)&lt;/span&gt;: checksum error at logical &lt;span style=&#34;color:#40a070&#34;&gt;253848715264&lt;/span&gt; on dev /dev/nvme0n1p2, physical &lt;span style=&#34;color:#40a070&#34;&gt;21546885120&lt;/span&gt;, root &lt;span style=&#34;color:#40a070&#34;&gt;5&lt;/span&gt;, inode &lt;span style=&#34;color:#40a070&#34;&gt;8127262&lt;/span&gt;, offset &lt;span style=&#34;color:#40a070&#34;&gt;3928064&lt;/span&gt;, length &lt;span style=&#34;color:#40a070&#34;&gt;4096&lt;/span&gt;, links &lt;span style=&#34;color:#40a070&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;(&lt;/span&gt;path: var/log/journal/22c7d33d64ee4991ab100bf6abeb7ac7/user-1000@00056c232173e076-2815baa2d7d959be.journal~&lt;span style=&#34;color:#666&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#666&#34;&gt;[&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;3392&lt;/span&gt;.226167&lt;span style=&#34;color:#666&#34;&gt;]&lt;/span&gt; BTRFS error &lt;span style=&#34;color:#666&#34;&gt;(&lt;/span&gt;device nvme0n1p2&lt;span style=&#34;color:#666&#34;&gt;)&lt;/span&gt;: bdev /dev/nvme0n1p2 errs: wr &lt;span style=&#34;color:#40a070&#34;&gt;0&lt;/span&gt;, rd &lt;span style=&#34;color:#40a070&#34;&gt;0&lt;/span&gt;, flush &lt;span style=&#34;color:#40a070&#34;&gt;0&lt;/span&gt;, corrupt &lt;span style=&#34;color:#40a070&#34;&gt;1&lt;/span&gt;, gen &lt;span style=&#34;color:#40a070&#34;&gt;0&lt;/span&gt;
&lt;span style=&#34;color:#666&#34;&gt;[&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;3392&lt;/span&gt;.226169&lt;span style=&#34;color:#666&#34;&gt;]&lt;/span&gt; BTRFS error &lt;span style=&#34;color:#666&#34;&gt;(&lt;/span&gt;device nvme0n1p2&lt;span style=&#34;color:#666&#34;&gt;)&lt;/span&gt;: unable to fixup &lt;span style=&#34;color:#666&#34;&gt;(&lt;/span&gt;regular&lt;span style=&#34;color:#666&#34;&gt;)&lt;/span&gt; error at logical &lt;span style=&#34;color:#40a070&#34;&gt;253848715264&lt;/span&gt; on dev /dev/nvme0n1p2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个文件是 &lt;code&gt;systemd&lt;/code&gt; 的一个日志文件，于是直接把这个文件删掉了（解决问题最快的方式就是搞定有问题的那个人~），然后重新执行 &lt;code&gt;scrub&lt;/code&gt; 的任务，但是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#666&#34;&gt;[&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;3857&lt;/span&gt;.669742&lt;span style=&#34;color:#666&#34;&gt;]&lt;/span&gt; BTRFS error &lt;span style=&#34;color:#666&#34;&gt;(&lt;/span&gt;device nvme0n1p2&lt;span style=&#34;color:#666&#34;&gt;)&lt;/span&gt;: bdev /dev/nvme0n1p2 errs: wr &lt;span style=&#34;color:#40a070&#34;&gt;0&lt;/span&gt;, rd &lt;span style=&#34;color:#40a070&#34;&gt;0&lt;/span&gt;, flush &lt;span style=&#34;color:#40a070&#34;&gt;0&lt;/span&gt;, corrupt &lt;span style=&#34;color:#40a070&#34;&gt;25&lt;/span&gt;, gen &lt;span style=&#34;color:#40a070&#34;&gt;0&lt;/span&gt;
&lt;span style=&#34;color:#666&#34;&gt;[&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;3857&lt;/span&gt;.669743&lt;span style=&#34;color:#666&#34;&gt;]&lt;/span&gt; BTRFS error &lt;span style=&#34;color:#666&#34;&gt;(&lt;/span&gt;device nvme0n1p2&lt;span style=&#34;color:#666&#34;&gt;)&lt;/span&gt;: unable to fixup &lt;span style=&#34;color:#666&#34;&gt;(&lt;/span&gt;regular&lt;span style=&#34;color:#666&#34;&gt;)&lt;/span&gt; error at logical &lt;span style=&#34;color:#40a070&#34;&gt;253848748032&lt;/span&gt; on dev /dev/nvme0n1p2
&lt;span style=&#34;color:#666&#34;&gt;[&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;3857&lt;/span&gt;.669861&lt;span style=&#34;color:#666&#34;&gt;]&lt;/span&gt; BTRFS warning &lt;span style=&#34;color:#666&#34;&gt;(&lt;/span&gt;device nvme0n1p2&lt;span style=&#34;color:#666&#34;&gt;)&lt;/span&gt;: checksum error at logical &lt;span style=&#34;color:#40a070&#34;&gt;253848752128&lt;/span&gt; on dev /dev/nvme0n1p2, physical &lt;span style=&#34;color:#40a070&#34;&gt;21546921984&lt;/span&gt;, root &lt;span style=&#34;color:#40a070&#34;&gt;5&lt;/span&gt;, inode &lt;span style=&#34;color:#40a070&#34;&gt;8127262&lt;/span&gt;, offset &lt;span style=&#34;color:#40a070&#34;&gt;3964928&lt;/span&gt;: path resolving failed with &lt;span style=&#34;color:#bb60d5&#34;&gt;ret&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#40a070&#34;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;感觉坏的更严重了，通过 &lt;code&gt;logic number&lt;/code&gt; 和 &lt;code&gt;inode&lt;/code&gt; 号都查不到这个文件的信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;:&lt;span style=&#34;color:#666&#34;&gt;)&lt;/span&gt; sudo btrfs inspect-internal logical-resolve &lt;span style=&#34;color:#40a070&#34;&gt;253848752128&lt;/span&gt; /
ERROR: logical ino ioctl: No such file or directory
:&lt;span style=&#34;color:#666&#34;&gt;)&lt;/span&gt; sudo btrfs inspect-internal inode-resolve &lt;span style=&#34;color:#40a070&#34;&gt;8127262&lt;/span&gt; /
ERROR: ino paths ioctl: No such file or directory&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后来还是 fc 老师点醒了我：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我的意思是，scrub 發現了之後可能已經幫你刪掉了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是我重新执行了一下 &lt;code&gt;scrub&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;scrub &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;done&lt;/span&gt; &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;for&lt;/span&gt; 86fd5394-5a32-43cd-8ef5-5f3fbd46056e
scrub started at Wed Nov &lt;span style=&#34;color:#40a070&#34;&gt;14&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;23&lt;/span&gt;:35:39 &lt;span style=&#34;color:#40a070&#34;&gt;2018&lt;/span&gt; and finished after &lt;span style=&#34;color:#40a070&#34;&gt;00&lt;/span&gt;:00:44
total bytes scrubbed: &lt;span style=&#34;color:#40a070&#34;&gt;72&lt;/span&gt;.37GiB with &lt;span style=&#34;color:#40a070&#34;&gt;0&lt;/span&gt; errors&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;哈哈，修好啦！ &lt;strong&gt;btrfs 真香！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;收工之喜&#34;&gt;收工之喜&lt;/h2&gt;
&lt;p&gt;在全盘检查没有问题之后，我重新执行了 &lt;code&gt;balance&lt;/code&gt;，并且顺利完成了。在庆祝收工之余，还进行了如下配置：&lt;/p&gt;
&lt;p&gt;启用每月一次的全盘校验任务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;:&lt;span style=&#34;color:#666&#34;&gt;)&lt;/span&gt; sudo systemctl &lt;span style=&#34;color:#007020&#34;&gt;enable&lt;/span&gt; btrfs-scrub@-.timer
:&lt;span style=&#34;color:#666&#34;&gt;)&lt;/span&gt; sudo systemctl start btrfs-scrub@-.timer&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为我使用了 &lt;a href=&#34;https://wiki.archlinux.org/index.php/TLP&#34;&gt;&lt;code&gt;tlp&lt;/code&gt;&lt;/a&gt;，按照 wiki 上的说法，我需要修改一个配置以避免文件系统损坏：&lt;/p&gt;
&lt;p&gt;修改 &lt;code&gt;/etc/default/tlp&lt;/code&gt; 文件中的 &lt;code&gt;SATA_LINKPWR_ON_BAT&lt;/code&gt; 属性。wiki 要求是修改成 &lt;code&gt;max_performance&lt;/code&gt;，但是配置文件中的注释提到：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# AHCI link power management (ALPM) for disk devices:
# min_power, med_power_with_dipm(*), medium_power, max_performance.
# (*) Kernel &amp;gt;= 4.15 required, then recommended.
# Multiple values separated with spaces are tried sequentially until success.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此我设置成了如下的值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SATA_LINKPWR_ON_BAT=&amp;quot;med_power_with_dipm max_performance&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/Btrfs&#34;&gt;Btrfs 维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Btrfs_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)&#34;&gt;Btrfs archwiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://btrfs.wiki.kernel.org/index.php/Conversion_from_Ext3&#34;&gt;Conversion from Ext3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;动态&#34;&gt;动态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;iG 成功夺得 S8 世界总冠军，恭喜！iG 牛逼！&lt;/li&gt;
&lt;li&gt;上个周末去了一趟红领巾公园，绕着转了三圈，完成了夜刷红领巾的任务
&lt;ul&gt;
&lt;li&gt;第一圈的时候有点蒙圈，因为各种找不到 Po，走了不少回头路&lt;/li&gt;
&lt;li&gt;第二圈的时候感觉自己超强，身体和大脑都非常巅峰&lt;/li&gt;
&lt;li&gt;第三圈的时候累成傻逼，唯一的想法就是这任务怎么还没做完 = =&lt;/li&gt;
&lt;li&gt;后来去了朝阳大悦城，在一堆情侣中一个人吃了顿&lt;a href=&#34;http://www.dianping.com/shop/93355360&#34;&gt;越打星&lt;/a&gt;，我觉得海星&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;这周我的母上来了一趟北京
&lt;ul&gt;
&lt;li&gt;我带着我最好的两个朋友过去一起吃了顿&lt;a href=&#34;http://www.dianping.com/shop/10338660&#34;&gt;四季民福&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;期间多次提及找对象，买房，成家立业&lt;/li&gt;
&lt;li&gt;哎，我觉得我的心理年龄才 16 岁，总觉得结婚买房什么的好遥远啊&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;最近比较迷茫，干什么都有点提不起兴趣，是时候去寻找更好玩的东西了？&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Systemd 的一些小技巧</title><link>https://xuanwo.io/2018/10/30/tips-of-systemd/</link><pubDate>Tue, 30 Oct 2018 12:20:00 +0000</pubDate><guid>https://xuanwo.io/2018/10/30/tips-of-systemd/</guid><description>&lt;blockquote&gt;
&lt;p&gt;我就是累死，写脚本写到吐，我也绝对不换 &lt;code&gt;底裤D&lt;/code&gt;！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;底裤D&lt;/code&gt; 真香！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;p&gt;现在 systemd 正在日益的变成一个 Linux 内核与发行版之间的一个兼容层，systemd 向下管理了诸多底层组件，向上提供了一致的接口和 API。而作为一个 Arch 用户，更是一边各个群中大喊 &lt;code&gt;systemd 真香&lt;/code&gt;，一边乖乖的把自己的底裤交给了 systemd，由此戏称为 &lt;code&gt;底裤D&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;今天主要就是分享一些自己平时用到的一些 systemd 的小技巧，备忘（&lt;/p&gt;
&lt;h2 id=&#34;管理自己的-vpn&#34;&gt;管理自己的 VPN&lt;/h2&gt;
&lt;p&gt;因为现在正在做的一个项目同时支持公有云和私有云的部署，因此就有很多的 VPN，难道要到每个 VPN 的目录下面手动执行 openvpn 么，答案当然是否定的，主要的弊端有以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最显然的一点：麻烦，每次都切换过去，然后手动执行 openvpn，想想就觉得特别蠢&lt;/li&gt;
&lt;li&gt;VPN 数量多了之后不好维护
&lt;ul&gt;
&lt;li&gt;不知道某个 vpn 开没开&lt;/li&gt;
&lt;li&gt;不知道某个 vpn 是不是成功的起来了&lt;/li&gt;
&lt;li&gt;后台运行的情况下 log 查起来也很麻烦，特别是在某些 VPN 的路由有冲突的时候&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;让指定的 VPN 开机启动还需要单独写一个脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然可以写一个 VPN 管理工具啦，但是何必呢，systemd 已经都帮我们做好啦~&lt;/p&gt;
&lt;p&gt;只要写一个 &lt;code&gt;service&lt;/code&gt; 文件，并放在 &lt;code&gt;/etc/systemd/system&lt;/code&gt; 下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;[Unit]&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;Description&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;OpenVPN tunnel for %I&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;After&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;syslog.target network-online.target&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;Wants&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;network-online.target&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;Documentation&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;man:openvpn(8)&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;Documentation&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;https://community.openvpn.net/openvpn/wiki/Openvpn24ManPage&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;Documentation&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;https://community.openvpn.net/openvpn/wiki/HOWTO&lt;/span&gt;
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;[Service]&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;Type&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;notify&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;PrivateTmp&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;true&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;WorkingDirectory&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;/etc/openvpn/xuanwo/%i&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;ExecStart&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;/usr/bin/openvpn --suppress-timestamps --nobind --config config.ovpn&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;CapabilityBoundingSet&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;CAP_IPC_LOCK CAP_NET_ADMIN CAP_NET_RAW CAP_SETGID CAP_SETUID CAP_SYS_CHROOT CAP_DAC_OVERRIDE&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;LimitNPROC&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;10&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;DeviceAllow&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;/dev/null rw&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;DeviceAllow&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;/dev/net/tun rw&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;ProtectSystem&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;true&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;KillMode&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;process&lt;/span&gt;
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;[Install]&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;WantedBy&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;multi-user.target&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个文件基本上是 Copy 自 &lt;code&gt;openvpn-client@.service&lt;/code&gt;，根据我实际的情况做了一些改动：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-diff&#34; data-lang=&#34;diff&#34;&gt;&lt;span style=&#34;color:#a00000&#34;&gt;--- a/usr/lib/systemd/system/openvpn-client@.service
&lt;/span&gt;&lt;span style=&#34;color:#a00000&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;+++ b/usr/lib/systemd/system/vpn@.service
&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;@@ -9,14 +9,13 @@ Documentation=https://community.openvpn.net/openvpn/wiki/HOWTO
&lt;/span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt; [Service]
Type=notify
PrivateTmp=true
&lt;span style=&#34;color:#a00000&#34;&gt;-WorkingDirectory=/etc/openvpn/client
&lt;/span&gt;&lt;span style=&#34;color:#a00000&#34;&gt;-ExecStart=/usr/bin/openvpn --suppress-timestamps --nobind --config %i.conf
&lt;/span&gt;&lt;span style=&#34;color:#a00000&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;+WorkingDirectory=/etc/openvpn/xuanwo/%i
&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;+ExecStart=/usr/bin/openvpn --suppress-timestamps --nobind --config config.ovpn
&lt;/span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;&lt;/span&gt; CapabilityBoundingSet=CAP_IPC_LOCK CAP_NET_ADMIN CAP_NET_RAW CAP_SETGID CAP_SETUID CAP_SYS_CHROOT CAP_DAC_OVERRIDE
LimitNPROC=10
DeviceAllow=/dev/null rw
DeviceAllow=/dev/net/tun rw
ProtectSystem=true
&lt;span style=&#34;color:#a00000&#34;&gt;-ProtectHome=true
&lt;/span&gt;&lt;span style=&#34;color:#a00000&#34;&gt;&lt;/span&gt; KillMode=process
[Install]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是与源文件的 diff，我针对不同的地方稍微介绍一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%i&lt;/code&gt; 是 systemd 中的一个替换标记，表示 &lt;code&gt;已转义的实例名称。对于实例化的单元，就是 &amp;quot;@&amp;quot; 和后缀之间的部分。&lt;/code&gt;，比如 &lt;code&gt;systemctl start vpn@abc&lt;/code&gt;，这个 &lt;code&gt;%i&lt;/code&gt; 就会被替换成 &lt;code&gt;abc&lt;/code&gt;。更多选项可以在参考中查阅。&lt;/li&gt;
&lt;li&gt;原来的配置文件都是指向一个独立的文件，但是我的 VPN 都会按照文件夹组织起来，所以我把工作目录修改为每个 vpn 独立的目录，并且读取目录下的配置文件 &lt;code&gt;config.ovpn&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ProtectHome=true&lt;/code&gt; 表示 &lt;code&gt;表示对该单元屏蔽 /home, /root, /run/user 目录(内容为空且不可写入)&lt;/code&gt;，此处我知道并且信任这个服务，而且我的 &lt;code&gt;/etc/openvpn/xuanwo&lt;/code&gt; 实际上是一个到 &lt;code&gt;/home/xuanwo/Google/VPN/&lt;/code&gt; 的软链接，我需要它访问 &lt;code&gt;/home&lt;/code&gt; ，因此我去掉了这个配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此以外，我还配置了两个 systemctl 相关的 alias：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#007020&#34;&gt;alias&lt;/span&gt; &lt;span style=&#34;color:#bb60d5&#34;&gt;sys&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;sudo systemctl&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#007020&#34;&gt;alias&lt;/span&gt; &lt;span style=&#34;color:#bb60d5&#34;&gt;sus&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;systemctl --user&amp;#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后的效果是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我的所有 VPN 配置都放在 &lt;code&gt;/home/xuanwo/Google/VPN&lt;/code&gt; 下并自动加密后同步到 Google Drive&lt;/li&gt;
&lt;li&gt;每个 VPN 都是一个独立的目录，每个目录下都有这个 vpn 需要的所有文件
&lt;ul&gt;
&lt;li&gt;特别的，一些需要密码的 vpn 可以在 &lt;code&gt;config.ovpn&lt;/code&gt; 中配置 &lt;code&gt;auth-user-pass passwd&lt;/code&gt;，并在当前目录下创建一个 &lt;code&gt;passwd&lt;/code&gt; 文件，内容为两行，第一行是用户名，第二行是密码，这样就可以免交互启动 VPN 了。&lt;em&gt;当然了，这样做会导致 VPN 的安全性有所下降，请根据自己的实际情况配置。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;所有的 vpn 都有了它对应的 service，因此可以做所有 service 支持的操作，比如 start 来启动，stop 来关闭，enable 来设置为开机启动&lt;/li&gt;
&lt;li&gt;不过现在 systemd 好像没有什么办法能查看指定模板下所有 service 的状态，我一般是用 &lt;code&gt;sys status | grep vpn&lt;/code&gt; 这样来查看（又不是不能用.png）&lt;/li&gt;
&lt;li&gt;当然也有了 &lt;code&gt;journald&lt;/code&gt; 的支持，我们可以用 &lt;code&gt;journalctl -u vpn@abc -r&lt;/code&gt; 来查看这个 vpn 近期的日志&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;限制某个-service-的内存用量&#34;&gt;限制某个 Service 的内存用量&lt;/h2&gt;
&lt;p&gt;Systemd 底层使用了 &lt;code&gt;cgroup&lt;/code&gt; 来控制和管理所有的服务，因此我们同样获得了控制服务所使用的内存占用的能力。&lt;/p&gt;
&lt;p&gt;只需要在 Serivce 的配置文件中增加一行即可：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;MemoryHigh&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;512M&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有一些可以选择的配置项：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MemoryLow&lt;/code&gt;: 尽可能保障该单元中的进程至少可以使用多少内存。如果该单元及其所有父单元的内存用量都低于最低保障线，那么只要还可以从其他未受保护的单元回收内存， 就不会回收该单元占用的内存。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MemoryHigh&lt;/code&gt;: 尽可能限制该单元中的进程最多可以使用多少内存。虽然这是一个允许被突破的柔性限制，但是突破限制后，进程的运行速度将会大打折扣， 并且系统将会尽可能尽快回收超出的内存。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MemoryMax&lt;/code&gt;: 绝对刚性的限制该单元中的进程最多可以使用多少内存。 这是一个不允许突破的刚性限制，触碰此限制会导致进程由于内存不足而被强制杀死。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如说我们可以这样来限制 &lt;code&gt;telegram&lt;/code&gt; 的内存使用量（telegram 真垃圾，一个内存泄漏问题至今修不好）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;[Unit]&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;Description&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;Telegram&lt;/span&gt;
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;[Service]&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;Type&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;simple&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;ExecStart&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;/usr/bin/telegram-desktop -- %u&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;KillMode&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;process&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;Restart&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;on-abnormal&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;RestartSec&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;2&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;MemoryHigh&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;512M&lt;/span&gt;
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;[Install]&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;WantedBy&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;multi-user.target&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以覆盖应用自带的 desktop 文件，让它总是通过 systemd 来启动应用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-desktop&#34; data-lang=&#34;desktop&#34;&gt;[Desktop Entry]
Version=1.0
Name=Telegram Desktop
Comment=Official desktop version of Telegram messaging app
Exec=systemctl --user start telegram.service
Icon=telegram
Terminal=false
StartupWMClass=TelegramDesktop
Type=Application
Categories=Network;InstantMessaging;Qt;
MimeType=x-scheme-handler/tg;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只要把这个文件命名为 &lt;code&gt;telegramdesktop.desktop&lt;/code&gt; 并放在 &lt;code&gt;~/.local/share/applications&lt;/code&gt; 目录下，我们的启动器就会总是使用这个文件，无缝集成~&lt;/p&gt;
&lt;p&gt;看起来非常美好，然而并没有什么卵用，因为 systemd 这里的实现有问题，主要是以下的几个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cgroup v1 无法确保非特权进程安全的使用资源控制器，所以 systemd 用户实例无法使用 cgroup v1，也就是说 systemd 的用户实例无法通过配置 &lt;code&gt;MemoryHigh=512M&lt;/code&gt; 来实现资源控制&lt;/li&gt;
&lt;li&gt;如果使用系统实例的话，会有如下两个问题
&lt;ul&gt;
&lt;li&gt;需要额外配置：&lt;code&gt;Environment=DISPLAY=:0&lt;/code&gt;，否则图形化界面不会正确展示&lt;/li&gt;
&lt;li&gt;运行一个普通应用要输入 sudo 密码，感觉非常蛋疼&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果做一个勇士，通过内核参数设置 &lt;code&gt;systemd.unified_cgroup_hierarchy&lt;/code&gt; 来强制启用 cgroup v2，那么你会面对如下问题：
&lt;ul&gt;
&lt;li&gt;docker 啥的全崩了，因为 runc 还不支持 cgroups v2，参见&lt;a href=&#34;https://github.com/opencontainers/runc/issues/654&#34;&gt;这个 issue&lt;/a&gt; ，从社区反馈来看，感觉还遥遥无期&lt;/li&gt;
&lt;li&gt;~systemd 的 cgroup v2 的资源控制实现有问题，并不能正常工作，在 &lt;a href=&#34;https://github.com/systemd/systemd/pull/10894&#34;&gt;PR&lt;/a&gt;中已经修复，但是暂时还没有 release~&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;虽说暂时还用不上，但是先记录一下，万一修好了呢~&lt;/p&gt;
&lt;p&gt;已经修好啦，systemd v240 中已经 fix 了 cgroup v2 相关的问题，可以正确控制用户实例的资源占用量啦~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;为指定的-service-设置环境变量&#34;&gt;为指定的 Service 设置环境变量&lt;/h2&gt;
&lt;p&gt;这个就比较简单啦，总有一些应用自己不提供代理的配置，我们可以通过 systemd 来启动它并为它设置专门的环境变量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;Environment&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;no_proxy=&amp;#34;localhost,127.0.0.1,localaddress,.localdomain.com&amp;#34; http_proxy=http://127.0.0.1:1090 https_proxy=http://127.0.0.1:1090&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;说的就是你，Skype！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解决关机时等待-stop-job-的问题&#34;&gt;解决关机时等待 stop job 的问题&lt;/h2&gt;
&lt;p&gt;关机的时候总会遇到这种问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;A stop job is running for Session xxx of user yyy&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一般是因为 systemd 给某个服务发送 kill 之后，那个服务没有正确退出，因此 systemd 会等待一段时间，直到 timeout 之后，直接给它发送 &lt;code&gt;kill -9&lt;/code&gt; 来强制关闭。这个时候我们首先要查看 systemd 的相关 log 来定位问题到底出在哪里：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;journalctl -b -1 -r&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;-b&lt;/code&gt; 参数表示显示开机至今的日志，而后面跟上 &lt;code&gt;-1&lt;/code&gt; 表示偏差值为一，&lt;code&gt;-r&lt;/code&gt; 表示逆序显示，连在一起就是逆序展示上次开机的日志。&lt;/p&gt;
&lt;p&gt;接下来我们需要耐心的查看一下日志，每个人启用的服务和系统的状况都不一样，要根据实际的情况来判断，比如我这边关闭失败的日志是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Oct 29 23:14:57 thinkpad-x1-carbon systemd[547]: Stopped Skype.
Oct 29 23:14:57 thinkpad-x1-carbon systemd[547]: skype.service: Failed with result &#39;timeout&#39;.
Oct 29 23:14:57 thinkpad-x1-carbon systemd[547]: skype.service: Main process exited, code=killed, status=9/KILL
Oct 29 23:14:57 thinkpad-x1-carbon systemd[547]: skype.service: Killing process 22768 (D-Bus thread) with signal SIGKILL.
Oct 29 23:14:57 thinkpad-x1-carbon systemd[547]: skype.service: Killing process 22001 (TaskSchedulerFo) with signal SIGKILL.
Oct 29 23:14:57 thinkpad-x1-carbon systemd[547]: skype.service: Killing process 1478 (skypeforlinux) with signal SIGKILL.
Oct 29 23:14:57 thinkpad-x1-carbon systemd[547]: skype.service: State &#39;stop-sigterm&#39; timed out. Killing.
Oct 29 23:13:26 thinkpad-x1-carbon systemd[547]: Stopping Skype...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以看到在等待了 90s 之后，systemd 强行关闭了 skype。后来发现是我的 service 文件写的不太对，KillMode 被错误的设置成了 &lt;code&gt;control-group&lt;/code&gt;，将这个问题修复之后，这个问题搞定了。&lt;/p&gt;
&lt;p&gt;有时候有些服务的实现上会有问题，导致没有正确关闭，我们在确定 &lt;code&gt;kill -9&lt;/code&gt; 没有问题的前提下，可以将它的 timeout 时间设置的更短一些，比如：&lt;code&gt;TimeoutStopSec=1s&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jinbuguo.com/systemd/systemd.unit.html#%E6%9B%BF%E6%8D%A2%E6%A0%87%E8%AE%B0&#34;&gt;可以用在单元文件中的替换标记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jinbuguo.com/systemd/systemd.resource-control.html&#34;&gt;systemd.resource-control&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jinbuguo.com/systemd/systemd.kill.html#KillMode=&#34;&gt;KillMode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/archlinux/comments/4bawf7/a_stop_job_is_running_for_session_c2_of_user/d187683/&#34;&gt;timesyncd can&amp;rsquo;t stop&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;动态&#34;&gt;动态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;关于 S8 世界总决赛
&lt;ul&gt;
&lt;li&gt;气死了，RNG 八强被淘汰，丢人。&lt;/li&gt;
&lt;li&gt;尽力了，EDG 八强被淘汰，明年再来。&lt;/li&gt;
&lt;li&gt;太强了，iG 成功进入总决赛，加油！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;关于游戏
&lt;ul&gt;
&lt;li&gt;荒野大镖客 2 已经出来了，然而我还在苦苦守候着我的皇牌空战 = =&lt;/li&gt;
&lt;li&gt;传送门骑士真的是垃圾游戏，打个一级的小怪都会卡一下，千万不要玩&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;关于动漫
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/bangumi/play/ss25510/&#34;&gt;刀剑神域 Alicization&lt;/a&gt; 画质炸裂，诚意满满，强烈推荐！&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/bangumi/play/ss25733/&#34;&gt;青春猪头少年不会梦到兔女郎学姐&lt;/a&gt; 男主各种神级操作，一定要认真学习，我笔记已经记了好几本了。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/bangumi/play/ss25696/&#34;&gt;弦音 -风舞高中弓道部-&lt;/a&gt; 我知道你们想说什么 - -，但是弓道真的好帅啊，运动番，运动番&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;关于阅读
&lt;ul&gt;
&lt;li&gt;金庸先生走了哎，感觉 20 世纪真的逐步远去，&lt;strong&gt;他&lt;/strong&gt;可能也快要走了&lt;/li&gt;
&lt;li&gt;重读&lt;a href=&#34;https://book.douban.com/subject/20499536/&#34;&gt;时代的稻草人&lt;/a&gt;，大学毕业一年多，我的精英意识已经完全被现实消磨光了，高中的时候满脑子社会变革，自我批判，要做时代的守望者，现在想起来居然觉得有些羞耻&lt;/li&gt;
&lt;li&gt;我们 Team 买了一本&lt;a href=&#34;https://www.amazon.cn/dp/B07GJ6H3X3&#34;&gt;万物皆数&lt;/a&gt;，挺有意思的，社会精英当不了，搞搞纯粹理性的东西是不是会更快乐一些&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>恢复博客遗失的评论</title><link>https://xuanwo.io/2018/10/15/revocer-lost-blog-comments/</link><pubDate>Mon, 15 Oct 2018 13:35:00 +0000</pubDate><guid>https://xuanwo.io/2018/10/15/revocer-lost-blog-comments/</guid><description>&lt;p&gt;最近发现自己博客的评论少了不少，于是找了一下原因并使用工具做了修复，这篇文章主要就是讲 Hugo 如何正确的配置 Disqus 以及如何使用 Disqus 提供的迁移工具来修复已经出问题的数据。&lt;/p&gt;
&lt;h2 id=&#34;hugo-sucks&#34;&gt;Hugo sucks&lt;/h2&gt;
&lt;p&gt;查看自己博客的 Discussions 的时候会看到很多奇奇怪怪的链接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://translate.googleusercontent.com/translate_c?act=url&amp;amp;depth=1&amp;amp;ie=UTF8&amp;amp;prev=_t&amp;amp;sl=auto&amp;amp;sp=nmt4&amp;amp;tl=en&amp;amp;u=https://xuanwo.io/2014/07/16/poj-1011-sticks/
https://translate.googleusercontent.com/translate_c?depth=1&amp;amp;sl=zh-CN&amp;amp;sp=nmt4&amp;amp;tl=en&amp;amp;u=https://xuanwo.io/2015/02/07/generate-a-ssh-key/&amp;amp;xid=17259,15700022,15700124,15700149,15700168,15700186,15700190,15700201,15700208
https://webcache.googleusercontent.com/search?q=cache:RMRC2X9nD0EJ:https://xuanwo.io/2017/11/26/enpass-intro/+&amp;amp;cd=1&amp;amp;ct=clnk&amp;amp;gl=jp&amp;amp;lr=lang_zh-CN%7Clang_zh-TW
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然啦，自己的博客有外国友人开着 Google 翻译看自然会觉得开心，但是为啥这些奇怪的地址会被作为这篇文章评论的 URL 存入 Disqus 呢？&lt;/p&gt;
&lt;p&gt;首先看了下网页的源代码中与 disqus 有关的部分：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#062873;font-weight:bold&#34;&gt;script&lt;/span&gt;&amp;gt;
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;var&lt;/span&gt; disqus_config &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;function&lt;/span&gt; () {
};
(&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;if&lt;/span&gt; ([&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#34;localhost&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#34;127.0.0.1&amp;#34;&lt;/span&gt;].indexOf(&lt;span style=&#34;color:#007020&#34;&gt;window&lt;/span&gt;.location.hostname) &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#40a070&#34;&gt;1&lt;/span&gt;) {
&lt;span style=&#34;color:#007020&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;disqus_thread&amp;#39;&lt;/span&gt;).innerHTML &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;Disqus comments not available by default when the website is previewed locally.&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;return&lt;/span&gt;;
}
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;var&lt;/span&gt; d &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;document&lt;/span&gt;, s &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; d.createElement(&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;script&amp;#39;&lt;/span&gt;); s.&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;true&lt;/span&gt;;
s.src &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;//&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#34;only0god&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;.disqus.com/embed.js&amp;#39;&lt;/span&gt;;
s.setAttribute(&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;data-timestamp&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#007020&#34;&gt;Date&lt;/span&gt;());
(d.head &lt;span style=&#34;color:#666&#34;&gt;||&lt;/span&gt; d.body).appendChild(s);
})();
&amp;lt;/&lt;span style=&#34;color:#062873;font-weight:bold&#34;&gt;script&lt;/span&gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到 &lt;code&gt;disqus_config&lt;/code&gt; 是空的，此时首先会感到有些不对劲，接下来看一下 disqus 文档对这个 config 是如何处理的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When url or identifier are not defined, the Disqus embed will use the window URL as the main identifier when creating a thread. In other words, each unique URL Disqus loads on will result in a new unique thread. This works well for some sites, however, this method of creating threads can lead to duplicate “split threads” for the same page of content, especially when your site accepts many different URLs for the same page of content.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以如果 &lt;code&gt;disqus_config&lt;/code&gt; 是空的，那 disqus 就会取当前的 window URL 创建一个条目。换言之，如果用户通过多个不同的 URL 访问到你这篇博客，那么你的博客就会有多个不一样的评论条目。&lt;/p&gt;
&lt;p&gt;现在导致 disqus 出现重复的原因知道了，那为什么会这样呢？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;var disqus_config = function () {
{{with .GetParam &amp;#34;disqus_identifier&amp;#34; }}this.page.identifier = &amp;#39;{{ . }}&amp;#39;;{{end}}
{{with .GetParam &amp;#34;disqus_title&amp;#34; }}this.page.title = &amp;#39;{{ . }}&amp;#39;;{{end}}
{{with .GetParam &amp;#34;disqus_url&amp;#34; }}this.page.url = &amp;#39;{{ . | html }}&amp;#39;;{{end}}
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是 Hugo 内嵌的 disqus 模板，看得出来，Hugo 为了追求灵活性（总有人想用奇奇怪怪的 URL 作为 disqus 的 url），他选择读取当前页面的参数，而不是直接写死了一个规定的值。这就很坑了，我选择自己改一下这个模板：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;var disqus_config = function () {
this.page.identifier = &amp;#39;{{ .URL }}&amp;#39;;
this.page.title = &amp;#39;{{ .Title }}&amp;#39;;
this.page.url = &amp;#39;{{ .Permalink }}&amp;#39;;
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;URL 是当前页面的相对路径&lt;/li&gt;
&lt;li&gt;Title 是当前页面的标题&lt;/li&gt;
&lt;li&gt;Permalink 是当前页面的完整 URL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如说：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;var&lt;/span&gt; disqus_config &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;this&lt;/span&gt;.page.identifier &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;\/2018\/10\/03\/ingress-beijing-central-axis\/&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;this&lt;/span&gt;.page.title &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;Ingress 北京中轴线噩梦难度一日速刷攻略&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;this&lt;/span&gt;.page.url &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;https:\/\/xuanwo.io\/2018\/10\/03\/ingress-beijing-central-axis\/&amp;#39;&lt;/span&gt;;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;此处的 &lt;code&gt;\&lt;/code&gt; 是 JavaScript 的转义，实际的内容中并不包括 &lt;code&gt;\&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;disqus-的-url-mapper&#34;&gt;Disqus 的 URL Mapper&lt;/h2&gt;
&lt;p&gt;现在已经修复了问题的源头，那现在这个烂摊子如何收拾呢？好在我们有 Disqus 的 URL Mapper，这个工具可以批量的将一组 URL 映射到另外一组 URL 上：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 A 映射为 B，那么 A 的评论就会迁移到 B 上&lt;/li&gt;
&lt;li&gt;将 A，B 都映射为 B，那么相当于把 A 和 B 两个页面的评论合并到了 B&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用起来也非常简单，访问自己网站的控制面板 &lt;code&gt;TOOLS -&amp;gt; Migration Tools -&amp;gt; URL Mapper&lt;/code&gt;，首先下载一个 csv，里面会包括网站的所有评论链接，然后按照如下规则修改即可：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果想将 A 修改为 B，那么只需要增加一列，写上 B 即可&lt;/li&gt;
&lt;li&gt;如果想跳过 A，那么直接将 A 这一行删除即可&lt;/li&gt;
&lt;li&gt;如果 B 为空的话，我也不知道会发生什么，没试过（&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我是直接将 CSV 上传到了 Google Sheet，然后用它的函数一阵操作搞定了，简单分享一哈：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LOWER(REPLACE(AXXX,1,4,&amp;quot;https&amp;quot;))&lt;/code&gt; 可以将 protocol 修改为 https 并全部转换为小写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;REGEXEXTRACT(AXXX, &amp;quot;https://xuanwo.io[\/\w-]*/&amp;quot;)&lt;/code&gt; 可以从 URL 的 Query 中提取出链接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面将修改好的 CSV 导出并上传，等到 disqus 异步处理即可。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://help.disqus.com/troubleshooting/use-configuration-variables-to-avoid-split-threads-and-missing-comments&#34;&gt;Use Configuration Variables to Avoid Split Threads and Missing Comments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Xuanwo/xuanwo.github.io/commit/bfb38029cabe8f3a5b1c33f808644e89cb5111b9&#34;&gt;themes: Fix disqus identifier not set correctly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;动态&#34;&gt;动态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;RNG 差点在小组赛翻车，最后连续干掉三星和状态火热的 C9，成功以小组第一出线（真的不容易，最后一波团真的是太刺激了），希望 EDG 和 iG 也能顺利出线~&lt;/li&gt;
&lt;li&gt;不知道为啥突然开始了规律作息，每天 7:30 起床，9 点到公司，感觉很爽，仿佛自己的人生突然多出来一个上午（&lt;/li&gt;
&lt;li&gt;最近成功加入了 Archlinuxcn 的打包组，并且把我常用的一些包加进了 cn 源，比如 &lt;a href=&#34;https://github.com/archlinuxcn/repo/tree/master/coredns&#34;&gt;coredns&lt;/a&gt;，我这个包可比 AUR 上的那个用心多了，欢迎大家使用并反馈意见~&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Ingress 北京中轴线噩梦难度一日速刷攻略</title><link>https://xuanwo.io/2018/10/03/ingress-beijing-central-axis/</link><pubDate>Wed, 03 Oct 2018 15:35:00 +0000</pubDate><guid>https://xuanwo.io/2018/10/03/ingress-beijing-central-axis/</guid><description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/Ingress&#34;&gt;Ingress&lt;/a&gt; 是一款基于地理位置的大型多人侵入式虚拟现实游戏，由 &lt;a href=&#34;https://zh.wikipedia.org/wiki/Niantic&#34;&gt;Niantic Labs&lt;/a&gt; 开发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为一位入坑多年，最近几个月才刚刚喜获人权的咸鱼玩家，这个十一长假不想平庸的度过，于是决定在 10 月 3 号的时候一日速刷北京中轴线。因为在适逢十一假期，再加上各种大家都懂的原因，这次任务的难度可以说是噩梦级别。这篇文章就是要跟大家分享一下我成功通关喜悦并且为更多想要一日速刷北京中轴线的同学提供一些小小的帮助。&lt;/p&gt;
&lt;h2 id=&#34;不打无准备之仗&#34;&gt;不打无准备之仗&lt;/h2&gt;
&lt;p&gt;既然目标是一日速刷，那当然首先要做好准备工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确认自己的身体和状态可以支持步行 20 公里
&lt;ul&gt;
&lt;li&gt;不要拿自己的身体开玩笑，如果实在勉强的话，可以断点续刷，比如每天刷三排~&lt;/li&gt;
&lt;li&gt;根据天气预报可以适当准备一些工具和药物，比如遮阳伞和藿香正气水之类的（当然我这样的糙爷们是没有准备的）&lt;/li&gt;
&lt;li&gt;爱美的小姐姐和小哥哥根据情况做好防晒等措施（你猜我做没做。。。）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;手机需要提前安装好需要的应用，确认手机运行没有问题
&lt;ul&gt;
&lt;li&gt;小飞机要确认可用，不要像我的朋友 X 一样到了现场发现上不了 Ingress，然后发现是服务器欠费了。。&lt;/li&gt;
&lt;li&gt;我用的是 iPhone 8，小飞机用的是 Shadowrocket，服务器是自建的~&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;带上 &lt;strong&gt;充满电&lt;/strong&gt; 的充电宝和充电线
&lt;ul&gt;
&lt;li&gt;我带了两块 10400 毫安时的充电宝，全天只用到了一块，电量还剩 50 % 不到的样子&lt;/li&gt;
&lt;li&gt;建议带一根长一点的充电线，这样就可以直接从包里面拉一根线出来充电，这样会比较方便，不会影响到走路&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;带上两瓶水
&lt;ul&gt;
&lt;li&gt;北京中轴线全程基本都在景区边上，为了避免被宰，最好还是自己带上水，你一定不想喝 15 块一瓶的农夫山泉&lt;/li&gt;
&lt;li&gt;我出发的时候带了一瓶水，然后在景区间移动的时候在一家小店买了一瓶尖叫，最后快结束的时候买了一瓶奶茶~&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;自备中午的干粮
&lt;ul&gt;
&lt;li&gt;虽然作者非常贴心的在上篇的最后一个任务中提示可以在此处休息，但是根据我的实际体验，基本上所有的店里面全都是人，最好还是不要凑这个热闹&lt;/li&gt;
&lt;li&gt;在走了一个上午之后，基本上也不会有什么食欲，因此不要带过于油腻的东西&lt;/li&gt;
&lt;li&gt;我出发的时候没有来得及买，最后是在一个马路的拐角处花了 9 块钱买了两个 &lt;strong&gt;鱼香肉丝&lt;/strong&gt; 馅儿的包子（&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;务必要在早上九点之前到 &lt;strong&gt;地铁八号线森林公园南门 B 口&lt;/strong&gt; ，过晚开始的话可能导致无法进入天安门广场，切记切记&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;let-s-rock&#34;&gt;Let&amp;rsquo;s rock&lt;/h2&gt;
&lt;h3 id=&#34;上篇-盛世&#34;&gt;上篇 盛世&lt;/h3&gt;
&lt;p&gt;大概八点半到了森林公园南门，朋友 X 稍微晚了一点，大概九点左右到，在地铁站门口接到他之后便直接开始了行程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小插曲：第一个任务的最后一个 Po &lt;code&gt;三度空间的演变&lt;/code&gt; 的时候遇到了一些状况，在那个位置中国移动的网络似乎有些问题，导致朋友 X 始终无法登录，最后是中国联通的我开热点并且帮他换掉了欠费的服务器之后搞定的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;上篇基本上没啥坑，就是一路摸过去，摸的时候最好看看下一个 Po 的位置，这样可以少走一些冤枉路。&lt;/li&gt;
&lt;li&gt;进奥林匹克公园的时候需要安检，不过并不是非常严格，边上放了一个扫身份证的机器，但是并没有要求我扫就放我进去了&lt;/li&gt;
&lt;li&gt;放眼望去基本上都是人，不过任务路线会有一段比较荫凉，人少的地方，可以坐着休息一会儿~&lt;/li&gt;
&lt;li&gt;出奥林匹克公园的时候会有些懵逼，因为下一个任务点在马路对面，但是地图上并没有标出来可以过马路的地方，不用担心，只需要贴着右边走就能看到一个去对面地铁站的人行道&lt;/li&gt;
&lt;li&gt;And 从这个地铁口开始后面的路程都可以骑单车过去&lt;/li&gt;
&lt;li&gt;中华民族园不需要进去，在外面就能摸到所有的 Po，然后这边会有个小小的往返，所以不要手滑 Hack 错了 Po&lt;/li&gt;
&lt;li&gt;任务上会推荐在此处休息，但是节假日的时候人会特别多，所以建议自备干粮对付一下（&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;中篇-故都&#34;&gt;中篇 故都&lt;/h3&gt;
&lt;p&gt;上篇基本上轻松搞定，中午休息了几次，喝了点水，顺便感慨一下人真多。上篇的很多路程都是阳光直射的，所以我们也没啥胃口吃东西，喝了两口水之后便直接出发了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务二的最后一个 Po 需要进到地铁背后的那个小道外面蹭一蹭，不过问题不算很大，并不是特别远&lt;/li&gt;
&lt;li&gt;之后就需要地铁坐到鼓楼大街站的 A 口继续，任务中也通过问答的形式来通知玩家了&lt;/li&gt;
&lt;li&gt;出地铁之后会去奇石馆，不需要门票，人也很少，只有附近的老大爷，挺安静，可以好好休息一会儿&lt;/li&gt;
&lt;li&gt;之后会沿着街一直走，进到一个胡同里面，最后来到什刹海，我们在这里遇到了 20 块钱一个的蟹黄汤包，囊中羞涩，吃不起吃不起&lt;/li&gt;
&lt;li&gt;接下来就是在小巷里面转圈，在南锣鼓巷附近，但是不会去南锣鼓巷&lt;/li&gt;
&lt;li&gt;从任务十三出来之后可以走 &lt;strong&gt;白米斜街&lt;/strong&gt; ，这样会近一点
&lt;ul&gt;
&lt;li&gt;但是如果直走的话，可以在拐角的峨嵋酒家处买到 &lt;strong&gt;鱼香肉丝&lt;/strong&gt; 馅儿的包子，而且还是冰凉冰凉的，我吃的心也冰凉冰凉的。。&lt;/li&gt;
&lt;li&gt;在这个附近会有一些售价正常的小卖部，可以补充一下水和干粮&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;任务十六的最后一个任务在景山公园，后续的任务都会在公园里面，所以不用想着在外面蹭蹭了，直接买票进去就好
&lt;ul&gt;
&lt;li&gt;票价两元，有学生证之类的可以优惠&lt;/li&gt;
&lt;li&gt;推荐使用微信买票，需要绑定手机号，不用排队，不要换票，可以直接扫码入园&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;按照任务指示前进即可，不需要爬山，任务十七中间会有个 Po 因为正在寿黄门整修所以需要在外面蹭蹭，同样问题不大&lt;/li&gt;
&lt;li&gt;出了景山公园之后需要走 &lt;code&gt;景山前街-&amp;gt;北长安街-&amp;gt;南长安街&lt;/code&gt; 到中山公园以开始下篇的任务
&lt;ul&gt;
&lt;li&gt;因为人很多的关系，所以单车不一定搞的到，需要往前面走一点&lt;/li&gt;
&lt;li&gt;搞到单车了也没用，因为北长安街这边不允许单车进入，只能步行（&lt;/li&gt;
&lt;li&gt;中途没有其他的任务 Po，只需要一直向前走，直到看到了中山公园的入口&lt;/li&gt;
&lt;li&gt;这段路会比较无聊，除了人什么都没有，中途也没有休息的地方，所以推荐在外面休息一下再进去&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;下篇-永定&#34;&gt;下篇 永定&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;下篇的第一个任务从中山公园的西口开始
&lt;ul&gt;
&lt;li&gt;同样推荐使用微信买票，跟景山公园是同一个公众号，票价三元（是的，涨了一块钱~）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;做任务一的第三个 Po 会让你觉得需要在外面蹭蹭，但是实际上是蹭不到的，你需要从蕙芳园边上的那个路直接走进去，不需要买票，走到底左转靠近中山堂地方就能摸到&lt;/li&gt;
&lt;li&gt;之后就是一阵刷刷刷，一直到任务三会让你从南门出中山公园
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;但是&lt;/strong&gt; ，中山公园南门是不让出的（准进不准出&lt;/li&gt;
&lt;li&gt;我们当时看到两个人从南门出去了，于是跟着他们两一起走过去，然后被保安拦住，我们把手机给他看了一下，然后说我们有人在里面，不出去&lt;/li&gt;
&lt;li&gt;结果进去之后才发现那两个人是工作人员，但是反悔已经晚了，边上还有工作人员在问你们怎么回事，这边不让出&lt;/li&gt;
&lt;li&gt;眼看着出口就在边上，我们假装啥都没听见，直接过去了，好在无事发生&lt;/li&gt;
&lt;li&gt;（朋友们，千万不要学我，运气不好的话，可能剩下的十一假期都在派出所过了哎）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;之后会从天安门门口过一圈，人超级多，直接摸一下就过去，不多做逗留了&lt;/li&gt;
&lt;li&gt;从地下通道去广场，没有过安检&lt;/li&gt;
&lt;li&gt;广场上一路刷刷刷，没啥好说的&lt;/li&gt;
&lt;li&gt;然后就是在前门大街逛吃逛吃&lt;/li&gt;
&lt;li&gt;天坑的最后两个 Po
&lt;ul&gt;
&lt;li&gt;这个比较蛋疼，任务上是推荐做公交过去，但是节假日做公交其实是一件很麻烦的事情&lt;/li&gt;
&lt;li&gt;我推荐骑单车过去，精确的定位是 &lt;strong&gt;永定门城楼&lt;/strong&gt;，可以直接骑过去，然后走上去&lt;/li&gt;
&lt;li&gt;一路骑车过来体验很赞&lt;/li&gt;
&lt;li&gt;在天桥艺术中心的门口还会有人唱歌，我是听完了一曲《一路向北》之后才走的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;show-me-your-hand&#34;&gt;Show me your hand&lt;/h2&gt;
&lt;p&gt;摸完了最后两个 Po 之后，所有任务结束了，一日速刷搞定，做地铁回家的路上在大望路停了一下吃了顿晚饭，Over~&lt;/p&gt;
&lt;h3 id=&#34;微信运动步数&#34;&gt;微信运动步数&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;wechat.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;当天的-ingress-时长&#34;&gt;当天的 Ingress 时长&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;time.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;profile-任务页&#34;&gt;Profile 任务页&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;profile.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;彩蛋一枚&#34;&gt;彩蛋一枚&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;egg.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;动态&#34;&gt;动态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;跟朋友约好了一起联机玩 For the King，但是他的网卡坏了，只能用手机玩 *决战平安京*，蛋疼&lt;/li&gt;
&lt;li&gt;最近新发现了不少好玩的联机游戏，有空的时候整理一下我多年联机经验&lt;/li&gt;
&lt;li&gt;开始从头看龙族，之前每次都没有看完（&lt;/li&gt;
&lt;li&gt;国庆的第一天去朋友家打麻将，连着自摸三把，哎，后悔没买彩票&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>qscamel —— 数据迁移工具</title><link>https://xuanwo.io/2018/09/05/qscamel-intro/</link><pubDate>Wed, 05 Sep 2018 09:00:00 +0000</pubDate><guid>https://xuanwo.io/2018/09/05/qscamel-intro/</guid><description>&lt;p&gt;qscamel 是一个用于在不同的端点 (Endpoint) 中高效迁移数据的工具。&lt;/p&gt;
&lt;p&gt;作为一个面向用户的数据迁移工具，它必须要满足如下要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不丢数据：这是一个数据迁移工具最基本的要求。不能多，不能少，不能错，要支持校验和修复。&lt;/li&gt;
&lt;li&gt;好用：作为一个给用户使用的工具，它需要足够好用。有完善的日志，不会无故退出，网络波动时能够自动重试，部署 &amp;amp; 配置容易，能够支持断点续传，无需人工干预。&lt;/li&gt;
&lt;li&gt;高效：数据迁移通常都会有大量的文件传输，工具必须能够高效的使用服务器资源和带宽，节省用户执行迁移所需要的时间。&lt;/li&gt;
&lt;li&gt;扩展性强：数据迁移所需要的场景千奇百怪，工具必须能够扩展并支持大多数用户的场景，减少后续开发和维护的成本。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;qscamel 正是在这些要求下诞生的产物，它或许还不是那么完美，但是已经可用。目前已经圆满完成了很多数据迁移任务，任务涉及文件数量上亿，文件大小达数百 TB 。这篇文章将会介绍 qscamel 设计，实现和开发过程中的一些小故事，希望能够简单的告诉大家在 QingCloud 我们是如何做产品的，以及为我们的 HR 小姐姐提前打一个招聘的广告:)&lt;/p&gt;
&lt;h2 id=&#34;设计&#34;&gt;设计&lt;/h2&gt;
&lt;p&gt;qscamel 只有一个功能，但是为了把这个功能做好，它需要在各个层面上都有一个比较良好的设计。&lt;/p&gt;
&lt;h3 id=&#34;用户交互&#34;&gt;用户交互&lt;/h3&gt;
&lt;p&gt;一个好的命令行工具应该如何跟用户交互呢？嗯，抛开使用场景谈好坏都是耍流氓，那我重新组织一下语言：一个给&lt;strong&gt;终端用户&lt;/strong&gt;使用的&lt;strong&gt;数据迁移&lt;/strong&gt;工具应该如何跟用户交互？这里有两个关键点：第一，终端用户意味着使用者不是像我这样的高级用户，他们大多数只有一点甚至是没有使用命令行程序的经验，他们能读一些中文的文档，他们无法自行处理或者理解程序返回的错误，他们记不住程序的参数；第二，数据迁移意味着这个程序可能会运行很长的时间，用户不会一直在边上守着，同时这个程序用户可能不会频繁使用。分析到这里，我们已经能够大概的想象到这个工具应该是什么样子了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令要少，参数要少&lt;/li&gt;
&lt;li&gt;学习成本要低，迁移成本要低（换个任务类型不需要重新学习配置方法）&lt;/li&gt;
&lt;li&gt;任务启动后无需用户介入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了需要考虑用户体验之外，我们还需要考虑开发体验。一个数据迁移工具，必然需要能够处理多种不同的数据来源和迁移目标，以及他们各自不一样的复杂参数。如果按照传统开发命令行工具的习惯，每个不同的端点都使用参数来进行配置，那光是参数解析和处理就要写很久。&lt;/p&gt;
&lt;p&gt;因此，qscamel 最终的交互设计稿是这样的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ qscamel run task-name &lt;span style=&#34;color:#666&#34;&gt;[&lt;/span&gt; -t /path/to/task/file &lt;span style=&#34;color:#666&#34;&gt;]&lt;/span&gt;
$ qscamel delete task-name
$ qscamel status
$ qscamel clean
$ qscamel version&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与之相对比的是 v1 版本的 qscamel：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ qscamel -t s3 -s s3-bucket-name -z us-east-1 -a &lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#34;S3ACCESSKEYID&amp;#34;&lt;/span&gt; -S &lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#34;S3SECRETACCESSKEY&amp;#34;&lt;/span&gt; -b qingstor-bucket-name -d &lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#34;migrate 05&amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时，我们将复杂的任务配置拆分为三块：qscamel 本身的配置，任务的配置，端点的配置，并将他们分成两个文件：qscamel 本身的配置独立的存储在一个全局的配置文件中，任务和端点的配置放在一个我们定义好的任务配置当中。&lt;/p&gt;
&lt;p&gt;全局的配置文件形如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;concurrency:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#40a070&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;log_level:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;info&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;pid_file:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;~/.qscamel/qscamel.pid&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;log_file:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;~/.qscamel/qscamel.log&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;database_file:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;~/.qscamel/db&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而任务的配置文件格式同样是精心设计过的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;type:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;copy&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;source:&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;type:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;fs&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;path:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;/path/to/source&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;destination:&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;type:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;qingstor&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;path:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;/path/to/destination&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;options:&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;bucket_name:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;example_bucket&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;access_key_id:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;example_access_key_id&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;secret_access_key:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;example_secret_access_key&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;ignore_existing:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;last_modified&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每个任务会由 &lt;code&gt;type&lt;/code&gt;，&lt;code&gt;source&lt;/code&gt;，&lt;code&gt;destination&lt;/code&gt; 和任务相关的配置组成。其中 &lt;code&gt;source&lt;/code&gt; 和 &lt;code&gt;destination&lt;/code&gt; 配置格式一样，都由 &lt;code&gt;type&lt;/code&gt;，&lt;code&gt;path&lt;/code&gt; 和 &lt;code&gt;options&lt;/code&gt; 组成。藉由这样的设计，我们希望能够在易用性和扩展性上取得一个统一。用户可以很快的知道自己需要配置的东西，并且能够忽略无关参数的干扰，比如说我要配置从 fs 迁移到 qingstor，我就不需要了解 s3 的配置参数。还有一个好处是，用户只要写一次配置文件，他就能够将其应用到别的场景：比如说进行 &lt;code&gt;delete&lt;/code&gt; 而不是 &lt;code&gt;copy&lt;/code&gt;，比如说从 &lt;code&gt;s3&lt;/code&gt; 迁移到 &lt;code&gt;qingstor&lt;/code&gt; 而不是从 &lt;code&gt;fs&lt;/code&gt;。使用一个格式规范的配置文件对于开发来说更是意义重大，开发者不再需要去维护一份晦涩难懂的参数列表，能够用更加一致的方法来处理所有的端点。&lt;/p&gt;
&lt;p&gt;下面我们同样用 v1 版本的 qscamel 来做对比：&lt;/p&gt;
&lt;p&gt;他首先有一个参数列表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;| short | full | type | required |
|-------|------------------|--------|----------|
| -z | --src-zone | string | N |
| -a | --src-access-key | string | N |
| -S | --src-secret-key | string | N |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后根据不同的 Source 还需要选择不同参数的组合：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;| platform | require --src-zone | require --src-access-key | require --src-secret-key |
|----------|--------------------|--------------------------|--------------------------|
| s3 | Y | Y | Y |
| qiniu | N | Y | Y |
| aliyun | Y | Y | Y |
| upyun | Y | Y | Y |
| qingstor | Y | Y | Y |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这还没有考虑到不同 Source 各自不同的参数配置呐 (๑•̀ㅂ•́) ✧&lt;/p&gt;
&lt;h3 id=&#34;整体流程&#34;&gt;整体流程&lt;/h3&gt;
&lt;p&gt;上面我们说到 qscamel 需要做到&lt;code&gt;任务启动后无需用户介入&lt;/code&gt;，接下来就聊一聊 qscamel 整体的任务流程是怎么样的。&lt;/p&gt;
&lt;p&gt;启动任务，检查任务文件的内容是否正确，初始化 Source 和 Destination 之后，qscamel 会不断的进行如下循环：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启动一个 listWorker 不断的从 Source 中遍历 Object
&lt;ul&gt;
&lt;li&gt;如果遍历失败将会自动重试&lt;/li&gt;
&lt;li&gt;如果遍历结束将会关闭任务队列，不再追加新的任务&lt;/li&gt;
&lt;li&gt;如果获取到新的 Object，则首先会将其保存到数据库，然后再添加到任务队列&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;启动指定数量的 migrateWorker 不断的从任务队列中获取任务
&lt;ul&gt;
&lt;li&gt;如果任务执行失败则会重试三次，每次重试的间隔会变长，若还是失败则会跳过&lt;/li&gt;
&lt;li&gt;如果任务执行成功则会从数据库中删除该任务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;等到任务队列中所有的任务均已执行完毕，qscamel 将会遍历数据库
&lt;ul&gt;
&lt;li&gt;如果数据库中没有未执行完毕的任务，则该迁移任务已成功，退出&lt;/li&gt;
&lt;li&gt;如果数据库中还有未执行完毕的任务，则重新开始上述流程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;不难发现，如果因为某些原因，某个 Object 一直在重试，那么 qscamel 将永远不会退出，并一直在输出报错的日志。这个在设计中是作为一个产品特性考虑的，但是根据实际的用户反馈，他们更希望程序能够将这些一直失败的任务在最后的时候统一输出，因此之后重新考虑一下，看如何交互更好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;分段上传&#34;&gt;分段上传&lt;/h3&gt;
&lt;p&gt;分段上传并不是什么新奇玩意儿，但是如果要做一个不依赖服务器状态，支持并发上传多个块，支持从断点恢复而且还好看的分段上传，却实打实的花了我整整一个下午的时间。不依赖服务器状态是说我们需要在本地存储分块上传的完成情况，而不是通过调用服务器端的 API 来获取，这样可以减少很多轮查询的开销；支持并发上传多个块就是字面意思，我们需要在分块的级别上做到并发，而不是单线程跑；支持从断点恢复是说已经上传的块需要跳过，只上传还没有完成的块。之前 qscamel 使用的是 qingstor-sdk-go 提供的一个比较简陋的 upload client 封装，只是简单的顺序调用接口，没有异常的处理。直到有一天，一个用户说我要上传一个 11 TB 的单文件到对象存储 (狗头.png)&lt;/p&gt;
&lt;p&gt;为了将分块上传的逻辑与我们刚才的逻辑可以优雅的结合起来，原来的 Object 和 Job （也就是一个 Folder）被组合并拆分成了三种 Object：DirectoryObject，SingleObject，PartialObject。顾名思义，DirectoryObject 就等同于原来的 Job，SingleObject 表示一个完整的 Object，而 PartialObject 除了有跟 SingleObject 一样的属性之外，它还会携带着与分段上传有关的信息，比如 part number，upload id 等。这样就使得每一个 PartialObject 都可以独立的进行上传，不需要依赖外部的信息。&lt;/p&gt;
&lt;p&gt;分段上传在实现的过程中最大限度的复用了原有的逻辑，只不过在每一个 Object 开始上传时会做相关的检查：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是 PartialObject，则会使用 Object 中的信息进行分段上传。&lt;/li&gt;
&lt;li&gt;如果是 SingleObject，则会根据 Endpoint 是否支持分段和这个 Object 的大小来判断是否需要拆分成 PartialObject：
&lt;ul&gt;
&lt;li&gt;如果 Endpoint 不支持分段，或者 Object 的大小不够大，则会直接上传。&lt;/li&gt;
&lt;li&gt;反之，则会使用 Endpoint 的初始化分段接口进行分片，并将所有的 PartialObject 创建好。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;p&gt;刚才我们讲了 qscamel 几处关键部分的设计，下面我们聊一聊 qscamel 的实现。qscamel 在实现过程中保持着对开发者友好的风格，没有使用什么黑科技，也没有使用什么奇怪的 Hack，简单直接，使用的也都是最常见的模型。&lt;/p&gt;
&lt;h3 id=&#34;生产者-消费者&#34;&gt;生产者-消费者&lt;/h3&gt;
&lt;p&gt;在绝大部分场景下，列取操作都要比上传和下载操作来得快，因此使用单生产者多消费者的模型更加合适，同时逻辑也会变得更加清晰。实现上我们使用 &lt;code&gt;sync.WaitGroup&lt;/code&gt; 做了一个简单的 &lt;code&gt;goroutine&lt;/code&gt; 池，在初始化的时候会一次性创建完毕，并始终监听 Object Channel，在 channel 关闭后自动退出。&lt;/p&gt;
&lt;h3 id=&#34;endpoint-中的-interface&#34;&gt;Endpoint 中的 interface&lt;/h3&gt;
&lt;p&gt;qscamel 要求支持的 endpoint 类型很多，从本地文件系统到各种对象存储，还包括本地文件的列表和 URL 的列表。想要快速开发，便于维护就要求将各个 endpoint 中的公共部分尽可能抽象出来，让 endpoint 实现者只需要关注自己逻辑相关的部分。为了做到这一点，qscamel 将 endpoint 中需要用到的所有方法拆分成了三个 interface，endpoint 实现者可以自行实现自己想要支持的功能。&lt;/p&gt;
&lt;p&gt;其中，所有 endpoint 都必须要实现的 base interface 中包括如下函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Base is the interface that both Source and Destination should implement.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;type&lt;/span&gt; Base &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;interface&lt;/span&gt; {
&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Name will return the endpoint&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#06287e&#34;&gt;Name&lt;/span&gt;(ctx context.Context) (name &lt;span style=&#34;color:#902000&#34;&gt;string&lt;/span&gt;)
&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Stat will get the metadata.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#06287e&#34;&gt;Stat&lt;/span&gt;(ctx context.Context, p &lt;span style=&#34;color:#902000&#34;&gt;string&lt;/span&gt;) (o &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;model.SingleObject, err &lt;span style=&#34;color:#902000&#34;&gt;error&lt;/span&gt;)
&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Read will return a reader.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#06287e&#34;&gt;Read&lt;/span&gt;(ctx context.Context, p &lt;span style=&#34;color:#902000&#34;&gt;string&lt;/span&gt;) (r io.Reader, err &lt;span style=&#34;color:#902000&#34;&gt;error&lt;/span&gt;)
&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// ReadRange will read content with range [offset, offset+size)
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#06287e&#34;&gt;ReadRange&lt;/span&gt;(ctx context.Context, p &lt;span style=&#34;color:#902000&#34;&gt;string&lt;/span&gt;, offset, size &lt;span style=&#34;color:#902000&#34;&gt;int64&lt;/span&gt;) (r io.Reader, err &lt;span style=&#34;color:#902000&#34;&gt;error&lt;/span&gt;)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想要作为 Source，则还需要 Source interface：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Source is the interface for source endpoint.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;type&lt;/span&gt; Source &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;interface&lt;/span&gt; {
Base
&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// List will list from the job.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#06287e&#34;&gt;List&lt;/span&gt;(ctx context.Context, j &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;model.DirectoryObject, fn &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;func&lt;/span&gt;(model.Object)) (err &lt;span style=&#34;color:#902000&#34;&gt;error&lt;/span&gt;)
&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Reach will return an accessible url.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#06287e&#34;&gt;Reach&lt;/span&gt;(ctx context.Context, p &lt;span style=&#34;color:#902000&#34;&gt;string&lt;/span&gt;) (url &lt;span style=&#34;color:#902000&#34;&gt;string&lt;/span&gt;, err &lt;span style=&#34;color:#902000&#34;&gt;error&lt;/span&gt;)
&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Reachable will return whether current endpoint supports reach.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#06287e&#34;&gt;Reachable&lt;/span&gt;() &lt;span style=&#34;color:#902000&#34;&gt;bool&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 List 会用来支持列取，而 Reach 则是可选的，这主要是用来支持对象存储的 Object Fetch 功能。&lt;/p&gt;
&lt;p&gt;如果想要作为一个 Task 的 Destination，则需要实现 Destination interface：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Destination is the interface for destination endpoint.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;type&lt;/span&gt; Destination &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;interface&lt;/span&gt; {
Base
&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Delete will use endpoint to delete the path.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#06287e&#34;&gt;Delete&lt;/span&gt;(ctx context.Context, p &lt;span style=&#34;color:#902000&#34;&gt;string&lt;/span&gt;) (err &lt;span style=&#34;color:#902000&#34;&gt;error&lt;/span&gt;)
&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Deletable will return whether current endpoint supports delete.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#06287e&#34;&gt;Deletable&lt;/span&gt;() &lt;span style=&#34;color:#902000&#34;&gt;bool&lt;/span&gt;
&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Fetch will use endpoint to fetch the url.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#06287e&#34;&gt;Fetch&lt;/span&gt;(ctx context.Context, path, url &lt;span style=&#34;color:#902000&#34;&gt;string&lt;/span&gt;) (err &lt;span style=&#34;color:#902000&#34;&gt;error&lt;/span&gt;)
&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Fetchable will return whether current endpoint supports fetch.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#06287e&#34;&gt;Fetchable&lt;/span&gt;() &lt;span style=&#34;color:#902000&#34;&gt;bool&lt;/span&gt;
&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// InitPart will inti a multipart upload.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#06287e&#34;&gt;InitPart&lt;/span&gt;(ctx context.Context, p &lt;span style=&#34;color:#902000&#34;&gt;string&lt;/span&gt;, size &lt;span style=&#34;color:#902000&#34;&gt;int64&lt;/span&gt;) (uploadID &lt;span style=&#34;color:#902000&#34;&gt;string&lt;/span&gt;, partSize &lt;span style=&#34;color:#902000&#34;&gt;int64&lt;/span&gt;, partNumbers &lt;span style=&#34;color:#902000&#34;&gt;int&lt;/span&gt;, err &lt;span style=&#34;color:#902000&#34;&gt;error&lt;/span&gt;)
&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// UploadPart will upload a part.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#06287e&#34;&gt;UploadPart&lt;/span&gt;(ctx context.Context, o &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;model.PartialObject, r io.Reader) (err &lt;span style=&#34;color:#902000&#34;&gt;error&lt;/span&gt;)
&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Partable will return whether current endpoint supports multipart upload.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#06287e&#34;&gt;Partable&lt;/span&gt;() &lt;span style=&#34;color:#902000&#34;&gt;bool&lt;/span&gt;
&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Write will read data from the reader and write to endpoint.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#06287e&#34;&gt;Write&lt;/span&gt;(ctx context.Context, path &lt;span style=&#34;color:#902000&#34;&gt;string&lt;/span&gt;, size &lt;span style=&#34;color:#902000&#34;&gt;int64&lt;/span&gt;, r io.Reader) (err &lt;span style=&#34;color:#902000&#34;&gt;error&lt;/span&gt;)
&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Writable will return whether current endpoint supports write.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#06287e&#34;&gt;Writable&lt;/span&gt;() &lt;span style=&#34;color:#902000&#34;&gt;bool&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在每个 interface 中，开发者对自己不想或者暂时不想实现的功能都可以在对应的 &lt;code&gt;Xxxable()&lt;/code&gt; 函数中返回 &lt;code&gt;false&lt;/code&gt; 即可，qscamel 在初始化任务时会进行对应功能的检查，并在任务要求不满足时报错。&lt;/p&gt;
&lt;p&gt;这样，我们 qscamel 就能够方便快捷的扩展新 endpoint 了~&lt;/p&gt;
&lt;h3 id=&#34;leveldb&#34;&gt;LevelDB&lt;/h3&gt;
&lt;p&gt;qscamel 是我们 QingStor Team 推出的第一款有状态的命令行工具，之前我们做 &lt;code&gt;qingcloud-cli&lt;/code&gt; 和 &lt;code&gt;qsctl&lt;/code&gt; 都只是直接调用对象存储的 API，不会在本地存储持久化的状态。但是 qscamel 作为一款数据迁移工具，它必须在本地维护大量信息以支持任务的断点续传。&lt;/p&gt;
&lt;p&gt;qscamel 在选型过程中考察了很多方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先排除掉了所有 Server - Client 模式的数据库，迁移工具要求部署简单，轻量级，如果迁移数据还需要部署一个 MySQL 或者 Redis，那就太滑稽了，因此可选择的一定是嵌入式 DB。&lt;/li&gt;
&lt;li&gt;然后因为开发者（没错，就是我）的个人偏好，排除掉了所有必须使用 CGO 的嵌入式 DB。RocksDB 非常酷炫，但是因为找不到一个足够好的纯 go 实现，所以被否决了。&lt;/li&gt;
&lt;li&gt;再次因为 qscamel 规划当中会在 DB 中存储的数据类型不会超过 3 种，同时也不会存在需要 Join 的情况，所以排除掉了所有嵌入式 SQL 数据库。&lt;/li&gt;
&lt;li&gt;最后在社区那么多嵌入式 K-V 数据库中，我们还需要排除掉所有不靠谱的，没有生产环境实际验证过的，维护状态不佳的，以及看着就不大行的项目。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在筛过好几轮之后，摆在我们面前的可选方案有三个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/etcd-io/bbolt&#34;&gt;BoltDB&lt;/a&gt; &lt;em&gt;原作者已经不维护了，现在由 coreos team 的人 Fork 并维护了一份，最近转移给了 etcd-io&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dgraph-io/badger&#34;&gt;Badger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/syndtr/goleveldb&#34;&gt;LevelDB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BoltDB 使用了 B+tree，LevelDB 使用了 LSM tree，而 Badger 则是借鉴了论文 &lt;a href=&#34;https://www.usenix.org/system/files/conference/fast16/fast16-papers-lu.pdf&#34;&gt;WiscKey&lt;/a&gt;，论文我没有细看，但大致的思想是将 LSM trees 中的 Key 和 Value 分开，将 Key 存储在 LSM tree 中，而 Value 则存在 value logs 里面。相对的来说，BoltDB 更加适合于读多写少的场景，而基于 LSM tree 的 DB 写入会更有优势。此外，LevelDB 不提供事务，它提供批量写入和读取时的 Snapshot，而 BoltDB 和 Badger 提供了完整的 ACID 事务，其中 BoltDB 不支持并发写事务，而 Badger 则支持。再三权衡之后，我首先放弃了 Badger。虽然特性很多，功能很强，Benchmark 也非常好看，但是它的特性我们基本上都用不到，加上我个人对这个项目的代码还不是很熟悉，可靠性上还有着疑虑，所以放弃了。&lt;/p&gt;
&lt;p&gt;本着够用就行的想法，我一开始选择了被广泛运用的 BoltDB 。但是事实证明这个选择是错误的，在 qscamel 实际的场景下，剧烈的写事务竞争导致性能很差，并且发现 qscamel 对事务其实并没有什么需求，因此切换成了 LevelDB。&lt;/p&gt;
&lt;h2 id=&#34;故事&#34;&gt;故事&lt;/h2&gt;
&lt;h3 id=&#34;遇事不决-黄金切割&#34;&gt;遇事不决，黄金切割&lt;/h3&gt;
&lt;p&gt;在 qscamel 探索的过程中，有过需要 magic number 的阶段，处于个人偏好，我无一例外的全部选择了黄金切割比。&lt;/p&gt;
&lt;p&gt;案例一：生产者与消费者比例&lt;/p&gt;
&lt;p&gt;之前 qscamel 是采用的多生产者，多消费者的方案，每个 worker 从一个统一的任务队列中取任务，又是生产者，又是消费者。看起来很美好，但是运行到某个时点，qscamel 总是会停止响应。当然了，现在回头来看可以知道这个 BUG 是由多种原因导致的。但是当时的一个分析是 Worker 的调度有问题，有可能所有的 Worker 都在生产，没有消费，导致整个任务队列阻塞了。作为一个解决方案，需要人为的固定生产者和消费者的比例，纠结了一会儿，选择了 0.618。&lt;/p&gt;
&lt;p&gt;事后的测试中发现这个 Fix 完全没有什么用，于是删掉了（&lt;/p&gt;
&lt;p&gt;案例二：乱搞的文件一致性检验&lt;/p&gt;
&lt;p&gt;为了加快一致性检验的速度，qscamel 曾经自己乱搞过一个&lt;a href=&#34;https://github.com/yunify/qscamel/commit/5a29fc9346b56b6ab5c6377f58d49675ace49838#diff-77889babdacd806bb9d5b8299a56e9a9&#34;&gt;一致性的算法&lt;/a&gt;。想法非常简单，从文件的头尾和 0.618 处，分别取 3 MB，总计 9 MB，然后计算它们的 MD5 。很快这个想法被毙了，用户开 MD5 的检查就是为了保证自己文件上传没错，搞一个所谓 quickMD5 完全没有实际的意义，要是万一有一个文件 MD5 不对，结果没有检查出来，那就大发了。&lt;/p&gt;
&lt;p&gt;总的来说，所有引入黄金切割的尝试全都失败了，但是我还在期待着下一个机会（&lt;/p&gt;
&lt;h3 id=&#34;buffer-的-bytes&#34;&gt;Buffer 的 Bytes&lt;/h3&gt;
&lt;p&gt;qscamel 很多地方都使用了我朋友 &lt;a href=&#34;https://pjw.io/&#34;&gt;@Aspire&lt;/a&gt; 写的&lt;a href=&#34;https://github.com/pengsrc/go-shared&#34;&gt;库&lt;/a&gt;，但是有一天被坑了一手，因为我发现它的 &lt;code&gt;buffer.Bytes()&lt;/code&gt; 不是线程安全的。因为它是这样实现的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Bytes returns a mutable reference to the underlying byte slice.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;func&lt;/span&gt; (b &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;BytesBuffer) &lt;span style=&#34;color:#06287e&#34;&gt;Bytes&lt;/span&gt;() []&lt;span style=&#34;color:#902000&#34;&gt;byte&lt;/span&gt; {
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;return&lt;/span&gt; b.bs
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;他将底层的 byte slice 直接返回，那就有可能在使用到一半的时候这个 buffer 被释放并写入了新的值，从而导致外部的调用者看到了一个错误的值。我提了一个 &lt;a href=&#34;https://github.com/pengsrc/go-shared/pull/3&#34;&gt;PR&lt;/a&gt;，跟 @Aspire 讨论了一下这个问题。虽说当初他实现的时候没有怎么考虑这个问题，但是想了一下他认为这是设计预期的，主要的点有两个：第一，设计这个 buffer 库就是为了复用内存，减少频繁创建 bytes slice 带来的开销，降低 gc 的压力，如果这个地方按照我的 PR 那样返回了一个新的 bytes slice 的话，那这个库就跟它的设计目标相违背了；第二，在 Golang 中，如果没有明确声明并发访问某事物是安全的，那它就不是安全的，比如 Golang 自己 &lt;a href=&#34;https://golang.org/src/bytes/buffer.go&#34;&gt;Buffer 实现&lt;/a&gt;就不是并发安全的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Bytes returns a slice of length b.Len() holding the unread portion of the buffer.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// The slice is valid for use only until the next buffer modification (that is,
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// only until the next call to a method like Read, Write, Reset, or Truncate).
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// The slice aliases the buffer content at least until the next buffer modification,
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// so immediate changes to the slice will affect the result of future reads.
&lt;/span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;func&lt;/span&gt; (b &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;Buffer) &lt;span style=&#34;color:#06287e&#34;&gt;Bytes&lt;/span&gt;() []&lt;span style=&#34;color:#902000&#34;&gt;byte&lt;/span&gt; { &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;return&lt;/span&gt; b.buf[b.off:] }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后的决定是增加一个类似于 &lt;code&gt;SafeBytes()&lt;/code&gt; 的函数，不过因为懒，所以一直没有做，以后再补上吧~&lt;/p&gt;
&lt;h3 id=&#34;小人物的重构-从早到晚&#34;&gt;小人物的重构，从早到晚&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;语出猫腻《间客》许乐在老虎死后跟随舰队穿越虫洞，手刃卡顿郡王前：“大人物报仇，隐忍十年也不算晚，小人物的复仇，却是从早到晚。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实 qscamel 的分段上传逻辑写了两遍，最开始是在原来的基础上缝缝补补，为 Object 加了很多新的属性，然后加了很多复杂判断，基本可用之后交付给了售前去做测试。晚上下班回家之后实在不满意那个版本，于是采用新的，也就是现在这样的逻辑重新实现了一遍。性能上有轻微提升，逻辑上变得更加顺畅，更主要的是我更加开心了 ʅ(‾◡◝)ʃ&lt;/p&gt;
&lt;h2 id=&#34;动态&#34;&gt;动态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这文章写了好几个月了，都不知道动态该写啥了。。&lt;/li&gt;
&lt;li&gt;LOL 洲际赛夺冠了，亚运会也夺冠了，又又又是最有希望的一年，希望今年能拿到 S 系列赛的冠军&lt;/li&gt;
&lt;li&gt;最近在重温《希灵帝国》，还买了微信读书新出的无限卡，每个月可以免费解锁 300 个章节，按照每个章节 0.3 元的均价，每月 19 块还是比较划算的（会计小能手&lt;/li&gt;
&lt;li&gt;PS 会免了命运 2，跟小伙伴一起突突突了两天，导致接下来的一个星期睡觉都满脑子枪声&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;广告&#34;&gt;广告&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;广告位招租，8 点 17 分发&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想要加入我们一起来做靠谱的产品吗，快访问 &lt;a href=&#34;https://www.qingcloud.com/jobs&#34;&gt;https://www.qingcloud.com/jobs&lt;/a&gt; 寻找自己中意的岗位并且给我发简历吧~&lt;/p&gt;</description></item></channel></rss>