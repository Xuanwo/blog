<!doctype html><html><head><title>文档误读导致的 BUG</title><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="A blog maintained by an interesting programmer."><meta name=keywords content="Technology,Code,Program,Linux,"><meta name=author content="Xuanwo"><meta property="og:title" content="文档误读导致的 BUG"><meta property="og:description" content="A blog maintained by an interesting programmer."><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://xuanwo.io/2018/06/15/bug-caused-by-misreading/"><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=https://xuanwo.io/css/main.min.5a9ffcf343273240b691845bba645faa19f2008c05742711b684042a3063818b.css integrity="sha256-Wp/880MnMkC2kYRbumRfqhnyAIwFdCcRtoQEKjBjgYs="><script data-ad-client=ca-pub-8380875817494486 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><link href=http://gmpg.org/xfn/11 rel=profile><meta name=generator content="Hugo 0.68.3"></head><body><nav class=nav><div class=nav-container><div class=brand><a href=https://xuanwo.io>Xuanwo's Blog</a></div><div class=links><a class=main-nav-link href=/about/>About</a>
<a class=main-nav-link href=/posts/>Posts</a></div></div></nav><main id=main-content><article class="single container"><header class=single-header><div class=flex><h1>文档误读导致的 BUG</h1><div class=post-meta><time class=date datetime=2018-06-15T18:00:00.000+00:00 itemprop=datePublished>2018-06-15</time></div><div class=tag-container><a style=text-decoration:none href=https://xuanwo.io/tags/golang><span>Golang</span></a></div></div></header><div class=post><blockquote><p>This post is the 3 / 3 post in
<a href=https://xuanwo.io/series/learn-from-bug>Learn From Bug</a> Series.</p></blockquote><p>之前听说过开发人员<a href=https://www.theregister.co.uk/2018/05/09/intel_amd_kernel_privilege_escalation_flaws/>读错 Intel 的文档</a>导致出现了严重 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-8897">BUG</a>，但是只是当成玩笑看待，但是等到这种事情发生在自己身上，还影响到了项目在用户生产环境的上线进度的时候，就不是那么好笑了。</p><blockquote><p>本文取材自真实事件的复盘，项目相关信息已经去敏。</p></blockquote><h2 id=经过>经过</h2><p>项目服务上线完毕，但是在上线后的测试中发现后端出现大量 504 错误。通过跟踪日志得知报错问题是后端数据库查询超时，在确定问题稳定复现之后，首先排除了服务器抖动，上线操作失误等问题，将原因锁定在了代码的层面。进一步的，还发现这个问题与后端的某个异步任务组件有关：只要开启该组件，错误就会出现；只要关闭，错误就会消失。该组件最近实施过一次较大的重构，在对代码进行二次 Review 之后，我们发现了可能出问题的点：重构时为了提升性能，组件内部会开多个 Goroutine 并发查询数据库，在业务首次启动时可能会对数据库造成特别大的压力。将并发改成 for 循环之后情况有所好转但是还是会有查询超时，没有修复到位。再次检查该组件中涉及到的数据库操作相关代码，发现有些 Query 操作返回的 row 没有手动做 Close 。在增加手动 Close 的代码后，超时问题消失。</p><h2 id=溯源>溯源</h2><p>第二天我再回过来看这段代码，发现导致这个错误的根源是我对一段文档的误读：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#60a0b0;font-style:italic>// Close closes the Rows, preventing further enumeration. If Next is called
</span><span style=color:#60a0b0;font-style:italic>// and returns false and there are no further result sets,
</span><span style=color:#60a0b0;font-style:italic>// the Rows are closed automatically and it will suffice to check the
</span><span style=color:#60a0b0;font-style:italic>// result of Err. Close is idempotent and does not affect the result of Err.
</span><span style=color:#60a0b0;font-style:italic></span><span style=color:#007020;font-weight:700>func</span> (rs <span style=color:#666>*</span>Rows) <span style=color:#06287e>Close</span>() <span style=color:#902000>error</span> {
	<span style=color:#007020;font-weight:700>return</span> rs.<span style=color:#007020>close</span>(<span style=color:#007020;font-weight:700>nil</span>)
}
</code></pre></div><p>文档中的描述是：如果 Next 被调用，并返回了 false 而且没有更多结果的时候，rows 将会自动 close。但是我实际上写出来的代码是这样的：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>value <span style=color:#666>:=</span> sql.NullInt64{}
row, err <span style=color:#666>:=</span> builder.<span style=color:#06287e>Select</span>(db.<span style=color:#06287e>Func</span>(<span style=color:#4070a0>&#34;COUNT&#34;</span>, <span style=color:#4070a0>&#34;?&#34;</span>)).
	<span style=color:#06287e>From</span>(table).<span style=color:#06287e>Where</span>(cond).<span style=color:#06287e>Query</span>()
<span style=color:#007020;font-weight:700>if</span> err <span style=color:#666>!=</span> <span style=color:#007020;font-weight:700>nil</span> {
	log.<span style=color:#06287e>Errorf</span>(ctx, <span style=color:#4070a0>&#34;MySQL error for %v.&#34;</span>, err)
	<span style=color:#007020;font-weight:700>return</span>
}
<span style=color:#007020;font-weight:700>if</span> row.<span style=color:#06287e>Next</span>() {
	err = row.<span style=color:#06287e>Scan</span>(<span style=color:#666>&amp;</span>value)
	<span style=color:#007020;font-weight:700>if</span> err <span style=color:#666>!=</span> <span style=color:#007020;font-weight:700>nil</span> {
		log.<span style=color:#06287e>Errorf</span>(ctx, <span style=color:#4070a0>&#34;MySQL scan error for %v.&#34;</span>, err)
		<span style=color:#007020;font-weight:700>return</span>
	}
	<span style=color:#007020;font-weight:700>if</span> value.Valid {
		n = <span style=color:#007020>int64</span>(value.Int64)
	}
}
</code></pre></div><p>区别在于我将这段文档理解成了：如果调用了 Next，而且没有更多结果的时候，rows 将会自动 close。实际上，Next 在返回 false 的时候后，其对应的 rows 才会 close。我们可以看一下 upperdb Rows 结构体的 Next 函数实现：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#60a0b0;font-style:italic>// Next prepares the next result row for reading with the Scan method. It
</span><span style=color:#60a0b0;font-style:italic>// returns true on success, or false if there is no next result row or an error
</span><span style=color:#60a0b0;font-style:italic>// happened while preparing it. Err should be consulted to distinguish between
</span><span style=color:#60a0b0;font-style:italic>// the two cases.
</span><span style=color:#60a0b0;font-style:italic>//
</span><span style=color:#60a0b0;font-style:italic>// Every call to Scan, even the first one, must be preceded by a call to Next.
</span><span style=color:#60a0b0;font-style:italic></span><span style=color:#007020;font-weight:700>func</span> (rs <span style=color:#666>*</span>Rows) <span style=color:#06287e>Next</span>() <span style=color:#902000>bool</span> {
	<span style=color:#007020;font-weight:700>var</span> doClose, ok <span style=color:#902000>bool</span>
	<span style=color:#06287e>withLock</span>(rs.closemu.<span style=color:#06287e>RLocker</span>(), <span style=color:#007020;font-weight:700>func</span>() {
		doClose, ok = rs.<span style=color:#06287e>nextLocked</span>()
	})
	<span style=color:#007020;font-weight:700>if</span> doClose {
		rs.<span style=color:#06287e>Close</span>()
	}
	<span style=color:#007020;font-weight:700>return</span> ok
}

<span style=color:#007020;font-weight:700>func</span> (rs <span style=color:#666>*</span>Rows) <span style=color:#06287e>nextLocked</span>() (doClose, ok <span style=color:#902000>bool</span>) {
	<span style=color:#007020;font-weight:700>if</span> rs.closed {
		<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020;font-weight:700>false</span>, <span style=color:#007020;font-weight:700>false</span>
	}

	<span style=color:#60a0b0;font-style:italic>// Lock the driver connection before calling the driver interface
</span><span style=color:#60a0b0;font-style:italic></span>	<span style=color:#60a0b0;font-style:italic>// rowsi to prevent a Tx from rolling back the connection at the same time.
</span><span style=color:#60a0b0;font-style:italic></span>	rs.dc.<span style=color:#06287e>Lock</span>()
	<span style=color:#007020;font-weight:700>defer</span> rs.dc.<span style=color:#06287e>Unlock</span>()

	<span style=color:#007020;font-weight:700>if</span> rs.lastcols <span style=color:#666>==</span> <span style=color:#007020;font-weight:700>nil</span> {
		rs.lastcols = <span style=color:#007020>make</span>([]driver.Value, <span style=color:#007020>len</span>(rs.rowsi.<span style=color:#06287e>Columns</span>()))
	}

	rs.lasterr = rs.rowsi.<span style=color:#06287e>Next</span>(rs.lastcols)
	<span style=color:#007020;font-weight:700>if</span> rs.lasterr <span style=color:#666>!=</span> <span style=color:#007020;font-weight:700>nil</span> {
		<span style=color:#60a0b0;font-style:italic>// Close the connection if there is a driver error.
</span><span style=color:#60a0b0;font-style:italic></span>		<span style=color:#007020;font-weight:700>if</span> rs.lasterr <span style=color:#666>!=</span> io.EOF {
			<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020;font-weight:700>true</span>, <span style=color:#007020;font-weight:700>false</span>
		}
		nextResultSet, ok <span style=color:#666>:=</span> rs.rowsi.(driver.RowsNextResultSet)
		<span style=color:#007020;font-weight:700>if</span> !ok {
			<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020;font-weight:700>true</span>, <span style=color:#007020;font-weight:700>false</span>
		}
		<span style=color:#60a0b0;font-style:italic>// The driver is at the end of the current result set.
</span><span style=color:#60a0b0;font-style:italic></span>		<span style=color:#60a0b0;font-style:italic>// Test to see if there is another result set after the current one.
</span><span style=color:#60a0b0;font-style:italic></span>		<span style=color:#60a0b0;font-style:italic>// Only close Rows if there is no further result sets to read.
</span><span style=color:#60a0b0;font-style:italic></span>		<span style=color:#007020;font-weight:700>if</span> !nextResultSet.<span style=color:#06287e>HasNextResultSet</span>() {
			doClose = <span style=color:#007020;font-weight:700>true</span>
		}
		<span style=color:#007020;font-weight:700>return</span> doClose, <span style=color:#007020;font-weight:700>false</span>
	}
	<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020;font-weight:700>false</span>, <span style=color:#007020;font-weight:700>true</span>
}
</code></pre></div><p>可以看到 Next 只有在 <code>nextLocked</code> 返回的 <code>doClose</code> 为 <code>true</code> 时才会主动调用 <code>rs.Close()</code>，而按照 <code>nextLocked</code> 中的逻辑，如果有值的话，会返回 <code>false, true</code>。也就是说，当 Next 返回 <code>true</code> 的时候，是不会去 Close rows 的。分析到这里，昨晚上线翻车的原因就很明显了，大量的 count query 的 rows 没有被 close 导致链接无法释放，从而新的请求无法执行以至于超时了。</p><h2 id=动态>动态</h2><ul><li>好不容易调整回来的作息被这次上线打回去了，现在很蓝瘦</li><li>用户环境上一次线就欠别人一顿饭，多上几次我要破产了。。。</li><li><a href=https://www.amazon.cn/dp/B00L1VVUTC>GEB</a> 虽然看不懂，但是我感觉很有意思</li><li><a href=https://docs.qingcloud.com/qingstor/developer_tools/qscamel.html>qscamel</a> 在经历了多个大用户的捶打之后终于正式发布了，有机会要写一个系列的文章讲讲自己在开发 qscamel 的时候都学到了啥</li><li>好久没有发文章了，找个由头水一篇</li><li>博客在 Linode 上跑了两个月之后，还是乖乖的回到了 gh-pages 的怀抱，真香</li><li>话说动态这个章节有人看么，如果不讨喜的我考虑一下去掉 = =</li></ul></div><div id=gitalk-container><div class=gt-container><div class=gt-meta><span class=gt-counts>6 comments</span></div><div class=gt-header><a class=gt-avatar-github><span class="gt-avatar gt-comment-avatar"><img src=https://www.gravatar.com/avatar/></span></a><div class=gt-header-comment><form class=gt-header-form target=comment-iframe method=post action=https://gitqus.now.sh/v0/comments/github.com/Xuanwo/xuanwo.github.io/master><input type=hidden name=slug value=static/2018/06/15/bug-caused-by-misreading/>
<input class=gt-header-input type=text name=name placeholder=Name required>
<input class=gt-header-input type=email name=email placeholder=Email required>
<textarea class=gt-header-textarea name=content placeholder="Leave a comment"></textarea><div class=gt-header-controls><button class=gt-btn><span class=gt-btn-text>Submit</span></button></div><iframe name=comment-iframe hidden id=frame></iframe></form></div></div><div class=gt-comments><div class="gt-comment gt-comment-admin"><div class="gt-avatar gt-comment-avatar"><img src=https://www.gravatar.com/avatar/></div><div class=gt-comment-content><div class=gt-comment-header><a class=gt-comment-username href=https://github.com/booxood>None</a>
<span class=gt-comment-text>commented</span>
<span class=gt-comment-date>2018-06-17T02:40:20</span></div><div class="gt-comment-body markdown-body">动态难道不是文章本体么？</div></div></div><div class="gt-comment gt-comment-admin"><div class="gt-avatar gt-comment-avatar"><img src=https://www.gravatar.com/avatar/></div><div class=gt-comment-content><div class=gt-comment-header><a class=gt-comment-username href=https://github.com/booxood>None</a>
<span class=gt-comment-text>commented</span>
<span class=gt-comment-date>2018-06-17T02:41:13</span></div><div class="gt-comment-body markdown-body">“出现大量 502 错误”，应该是 504。</div></div></div><div class="gt-comment gt-comment-admin"><div class="gt-avatar gt-comment-avatar"><img src=https://www.gravatar.com/avatar/></div><div class=gt-comment-content><div class=gt-comment-header><a class=gt-comment-username href=https://github.com/booxood>漩涡</a>
<span class=gt-comment-text>commented</span>
<span class=gt-comment-date>2018-06-17T02:52:37</span></div><div class="gt-comment-body markdown-body">彳亍口巴</div></div></div><div class="gt-comment gt-comment-admin"><div class="gt-avatar gt-comment-avatar"><img src=https://www.gravatar.com/avatar/></div><div class=gt-comment-content><div class=gt-comment-header><a class=gt-comment-username href=https://github.com/booxood>漩涡</a>
<span class=gt-comment-text>commented</span>
<span class=gt-comment-date>2018-06-17T02:53:02</span></div><div class="gt-comment-body markdown-body">唔，改一下~</div></div></div><div class="gt-comment gt-comment-admin"><div class="gt-avatar gt-comment-avatar"><img src=https://www.gravatar.com/avatar/></div><div class=gt-comment-content><div class=gt-comment-header><a class=gt-comment-username href=https://github.com/booxood>依云</a>
<span class=gt-comment-text>commented</span>
<span class=gt-comment-date>2018-10-11T07:46:19</span></div><div class="gt-comment-body markdown-body">不会被 gc 掉么？</div></div></div><div class="gt-comment gt-comment-admin"><div class="gt-avatar gt-comment-avatar"><img src=https://www.gravatar.com/avatar/></div><div class=gt-comment-content><div class=gt-comment-header><a class=gt-comment-username href=https://github.com/booxood>漩涡</a>
<span class=gt-comment-text>commented</span>
<span class=gt-comment-date>2018-10-11T07:52:32</span></div><div class="gt-comment-body markdown-body"><p>还真没有想过这个问题。</p><p>我的猜测是在 gc 之前 db 的连接数就已经消耗光了</p></div></div></div></div></div></div></article></main><footer class="footer container"><a class=main-nav-link href=/categories/>Categories</a>
<a class=main-nav-link href=/tags/>Tags</a>
<a class=main-nav-link href=/series/>Series</a>
<a class=main-nav-link href=/blogroll/>Blogroll</a>
<a class=main-nav-link href=/index.xml>Subscribe</a>
<script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-51515330-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></footer></body></html>