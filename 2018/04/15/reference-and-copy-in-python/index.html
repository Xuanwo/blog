<!doctype html><html><head><title>Python 中的引用与拷贝</title><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="A blog maintained by an interesting programmer."><meta name=keywords content=Technology,Code,Program,Linux,><meta name=author content=Xuanwo><meta property=og:title content="Python 中的引用与拷贝"><meta property=og:description content="A blog maintained by an interesting programmer."><meta property=og:type content=website><meta property=og:locale content=en_US><meta property=og:url content=https://xuanwo.io/2018/04/15/reference-and-copy-in-python/><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=https://xuanwo.io/css/main.min.f1117337552fb8079b063a89514739c5a687cc73d70687f23e488eb37c3047b1.css integrity="sha256-8RFzN1UvuAebBjqJUUc5xaaHzHPXBofyPkiOs3wwR7E="><link href=http://gmpg.org/xfn/11 rel=profile><meta name=generator content="Hugo 0.57.2"></head><body><nav class=nav><div class=nav-container><div class=brand><a href=https://xuanwo.io>Xuanwo&#39;s Blog</a></div><div class=links><a class=main-nav-link href=/about/>关于我</a>
<a class=main-nav-link href=/posts/>文章</a></div></div></nav><main id=main-content><article class="single container"><header class=single-header><div class=flex><h1>Python 中的引用与拷贝</h1><div class=post-meta><time class=date datetime=2018-04-15T15:07:00.000&#43;00:00 itemprop=datePublished>2018-04-15</time>
/
<span><a href=#disqus_thread class=comment-link>Comments</a></span></div><div class=tag-container><a style=text-decoration:none href=https://xuanwo.io/tags/python><span>Python</span></a></div></div></header><div class=post><blockquote><p>本文是
<a href=https://xuanwo.io/series/learn-from-bug>Learn from BUG</a> 系列的第 2 篇文章, 共 3 篇。</p></blockquote><p>用户反馈使用 <a href=https://github.com/yunify/qsctl>qsctl</a> 同步时文件内容不正确，调查后发现是对 Python 字典的错误使用导致了这个问题。这篇文章就来详细的介绍一下 Python 中的引用与拷贝。</p><h2 id=定位>定位</h2><p>按照用户给出的信息成功的复现出了用户描述的问题，进一步的，还发现当线程数量限制为只有一个时候，这个问题就消失了，因此可以判断是 Python 多线程间共享变量的时候出现了问题。qsctl 本身只是将文件 list 出来并调用 SDK 进行上传，没有做额外的处理，因此可以排除 qsctl 的嫌疑。也就是说，问题出在 Python SDK 上。阅读一下 Python SDK 中 <a href=https://github.com/yunify/qingstor-sdk-python/blob/master/qingstor/sdk/service/bucket.py#L1148>PutObject</a> 相关方法的源代码：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>put_object_request</span>(self, object_key, body<span style=color:#666>=</span>None):
    operation <span style=color:#666>=</span> {
        <span style=color:#4070a0>&#34;API&#34;</span>: <span style=color:#4070a0>&#34;PutObject&#34;</span>,
        <span style=color:#4070a0>&#34;Method&#34;</span>: <span style=color:#4070a0>&#34;PUT&#34;</span>,
        <span style=color:#4070a0>&#34;URI&#34;</span>: <span style=color:#4070a0>&#34;/&lt;bucket-name&gt;/&lt;object-key&gt;&#34;</span>,
        <span style=color:#4070a0>&#34;Headers&#34;</span>: {
            <span style=color:#4070a0>&#34;Host&#34;</span>: <span style=color:#4070a0>&#34;&#34;</span><span style=color:#666>.</span>join([self<span style=color:#666>.</span>properties[<span style=color:#4070a0>&#34;zone&#34;</span>], <span style=color:#4070a0>&#34;.&#34;</span>, self<span style=color:#666>.</span>config<span style=color:#666>.</span>host]),
        },
        <span style=color:#4070a0>&#34;Properties&#34;</span>: self<span style=color:#666>.</span>properties,
        <span style=color:#4070a0>&#34;Body&#34;</span>: body
    }
    operation[<span style=color:#4070a0>&#34;Properties&#34;</span>][<span style=color:#4070a0>&#34;object-key&#34;</span>] <span style=color:#666>=</span> object_key
    self<span style=color:#666>.</span>put_object_validate(operation)
    <span style=color:#007020;font-weight:700>return</span> Request(self<span style=color:#666>.</span>config, operation)

<span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>put_object</span>(self, object_key, body<span style=color:#666>=</span>None):
    req <span style=color:#666>=</span> self<span style=color:#666>.</span>put_object_request(object_key, body<span style=color:#666>=</span>body)
    resp <span style=color:#666>=</span> self<span style=color:#666>.</span>client<span style=color:#666>.</span>send(req<span style=color:#666>.</span>sign())
    <span style=color:#007020;font-weight:700>return</span> Unpacker(resp)</code></pre></div><p>忽略掉一些无关的代码之后，我们可以得到上面的简化代码。其中 <code>self</code> 也就是这个 <code>Bucket</code> 类会在一开始就初始化，之后的所有线程都会共享这一变量。顺着这个思路下去，很快发现一处可能导致出现问题的代码：<code>&quot;Properties&quot;: self.properties</code>。显然的，在 Python SDK 开发者（其实是我- -）认为，此处将会对 <code>self.properties</code> 进行一次复制，下面的 <code>operation[&quot;Properties&quot;][&quot;object-key&quot;] = object_key</code> 操作不会影响其它的线程。那这个想法是否正确？我们需要做个实验。</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#666>&gt;&gt;&gt;</span> a <span style=color:#666>=</span> {}
<span style=color:#666>&gt;&gt;&gt;</span> b <span style=color:#666>=</span> a
<span style=color:#666>&gt;&gt;&gt;</span> b[<span style=color:#4070a0>&#34;x&#34;</span>] <span style=color:#666>=</span> <span style=color:#4070a0>&#34;y&#34;</span>
<span style=color:#666>&gt;&gt;&gt;</span> a
{<span style=color:#4070a0>&#39;x&#39;</span>: <span style=color:#4070a0>&#39;y&#39;</span>}</code></pre></div><p>显然，Python SDK 开发者的想法是错误的。此处对 <code>operation[&quot;Properties&quot;]</code> 将会修改 <code>self.properties</code>，从而导致多个线程可能会覆盖掉同一个 Object，进而导致上传了错误的内容。</p><h2 id=修复>修复</h2><p>想要修改这个问题只需要每次创建 operation 字典时传递一个 <code>self.properties</code> 的副本，保证接下来的修改不会影响到 <code>self.properties</code> 本身即可。此处使用了 Python 字典提供的 <a href=file:///home/xuanwo/.local/share/Zeal/Zeal/docsets/Python_3.docset/Contents/Resources/Documents/doc/library/stdtypes.html#dict>copy 方法</a>：</p><ul><li><a href=https://github.com/yunify/qingstor-sdk-python/pull/43/commits/208172502fb72b9be85e7f1a494673810ee2e974>Fix concurrency issue in object related methods</a></li></ul><h2 id=思考>思考</h2><p>问题已经解决了，但是思考还在继续。</p><ul><li>Python 中的引用和复制是什么关系？</li></ul><p>为了解决这个问题，首先需要知道以下两个关键的事实：</p><ol><li>变量只是用来指代对象的名称 (<em>Variables are simply names that refer to objects.</em>)</li><li>List，Dict 是可变对象 (<em>Lists are mutable, which means that you can change their content.</em>)</li></ol><h3 id=事实-1>事实 1</h3><p><strong>变量只是用来指代对象的名称 (<em>Variables are simply names that refer to objects.</em>)</strong></p><p>先来看一段简短的代码：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#666>&gt;&gt;&gt;</span> a<span style=color:#666>=</span><span style=color:#40a070>2</span>
<span style=color:#666>&gt;&gt;&gt;</span> b<span style=color:#666>=</span>a
<span style=color:#666>&gt;&gt;&gt;</span> <span style=color:#007020>id</span>(a)
<span style=color:#40a070>9128416</span>
<span style=color:#666>&gt;&gt;&gt;</span> <span style=color:#007020>id</span>(b)
<span style=color:#40a070>9128416</span></code></pre></div><blockquote><p><a href=https://docs.python.org/3/library/functions.html#id><code>id</code></a> 函数会返回每一个 Object 的唯一 ID，并且保证在这个对象的整个生命周期中保持不变。对于 CPython 的实现而言，这个函数会返回这个对象在内存中的地址。也就是说，如果两个对象的 ID 相同，表示他们是同一个对象。</p></blockquote><p>在类 C 的语言当中，每个变量都代表着一块内存区域；但是在 Python 当中，一切都是对象，变量只是对象的一个名称（a.k.a. 标签，引用），变量本身没有类型信息，类型信息存储在对象当中。上述的代码中 <code>a=2</code>，实际上是先创建了 Int 对象 <code>2</code> ，然后将变量 <code>a</code> 绑定到了 <code>2</code> 上。接下来的 <code>b=a</code> 则是在对象 <code>2</code> 上绑定了一个新的变量 <code>b</code>。</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#666>&gt;&gt;&gt;</span> a <span style=color:#666>=</span> {}
<span style=color:#666>&gt;&gt;&gt;</span> b <span style=color:#666>=</span> a
<span style=color:#666>&gt;&gt;&gt;</span> <span style=color:#007020>id</span>(a)
<span style=color:#40a070>140092073651336</span>
<span style=color:#666>&gt;&gt;&gt;</span> <span style=color:#007020>id</span>(b)
<span style=color:#40a070>140092073651336</span>
<span style=color:#666>&gt;&gt;&gt;</span> b[<span style=color:#4070a0>&#34;x&#34;</span>] <span style=color:#666>=</span> <span style=color:#4070a0>&#34;y&#34;</span>
<span style=color:#666>&gt;&gt;&gt;</span> a
{<span style=color:#4070a0>&#39;x&#39;</span>: <span style=color:#4070a0>&#39;y&#39;</span>}</code></pre></div><p>在了解上述事实之后，我们就能理解这段代码了：这里的 <code>a</code> 与 <code>b</code> 指向了同一个对象，因此通过 <code>b</code> 进行的修改相当于通过 <code>a</code> 进行同样的修改。</p><h3 id=事实-2>事实 2</h3><p><strong>List，Dict 是可变对象 (<em>Lists are mutable, which means that you can change their content.</em>)</strong></p><p>通过事实 1 我们已经明白了 <strong>变量</strong> 与 <strong>对象</strong> 的关系，但是还是不够，因为我们无法解释下面这段代码：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#666>&gt;&gt;&gt;</span> a<span style=color:#666>=</span><span style=color:#40a070>2</span>
<span style=color:#666>&gt;&gt;&gt;</span> b<span style=color:#666>=</span>a
<span style=color:#666>&gt;&gt;&gt;</span> a<span style=color:#666>=</span>a<span style=color:#666>+</span><span style=color:#40a070>1</span>
<span style=color:#666>&gt;&gt;&gt;</span> <span style=color:#007020>id</span>(a)
<span style=color:#40a070>9128448</span>
<span style=color:#666>&gt;&gt;&gt;</span> <span style=color:#007020>id</span>(b)
<span style=color:#40a070>9128416</span></code></pre></div><p>按照刚才得出的结论，<code>a</code> 和 <code>b</code> 应该指向同一个对象，为什么对 <code>a</code> 进行的操作没有反应在 <code>b</code> 上呢？因为 Int 类型是一个不可变对象(immutable)。</p><p>在 Python 中有两类对象类型：</p><ul><li>可变对象(mutable): list, dict 等</li><li>不可变对象(immutable): int, string, float, tuple 等</li></ul><p>不可变对象是不变的。在 <code>a=a+1</code> 这一操作中没有修改 <code>a</code> 之前对应的对象 <code>2</code> 的值，而是创建了一个新的对象 <code>3</code> 并且将 <code>a</code> 绑定了上去。</p><p>而可变对象则可以通过某些函数来修改这个对象。需要注意的是，并不是所有的可变对象的操作都是修改可变对象本身。Python 标准库会通过函数是否返回 <code>None</code> 来区分这个函数是修改了这个对象，还是创建了一个新的对象。比如 List 的 <code>append</code> 和 <code>sort</code> 函数返回 <code>None</code>，这表示它们修改了这个 List 本身；而 <code>sorted()</code> 函数则是会返回一个排序后的对象，这说明它创建了一个新的对象。</p><h3 id=总结>总结</h3><p>根据对上述两个事实的分析，可以得出以下结论：</p><ul><li>对可变对象而言，我们可以修改它并且所有指向它的变量都会观察到这一变更</li><li>对不可变对象而言，所有指向它的变量都会始终看到同一个值，对它的修改操作总是会创建一个新的对象</li></ul><p>现在我们就能够解决我们最开始提出的那些问题了：</p><blockquote><p>Python 中的引用和拷贝是什么关系？</p></blockquote><p>其实没啥关系。对于赋值操作而言，<code>b=a</code> 实际上是将 <code>b</code> 绑定到了 <code>a</code> 所对应的那个对象。而 <code>b=a.copy()</code> 这是将 <code>b</code> 绑定到了新创建的与 <code>a</code> 所对应的那个对象的副本上。特别的，Python 中还有 <code>浅拷贝</code> 和 <code>深拷贝</code> 的概念，<code>浅拷贝</code> 只会复制对象最外层的元素，而 <code>深拷贝</code> 则会递归的复制整个对象。当对象内的元素全都是不可变对象时，它们两者并没有差异；而当对象内的元素中有可变对象时，<code>浅拷贝</code> 会创建一个到该可变对象的新绑定，<code>深拷贝</code> 则会创建一个与该可变对象相同的新对象并对这个可变对象继续做 <code>深拷贝</code>。</p><h3 id=测试>测试</h3><blockquote><p>先思考得出答案，然后再实际运行，并做出解释。</p></blockquote><h4 id=case-1>Case 1</h4><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>test</span>(arg):
    arg <span style=color:#666>=</span> <span style=color:#40a070>2</span>
    <span style=color:#007020;font-weight:700>print</span>(arg)

a <span style=color:#666>=</span> <span style=color:#40a070>1</span>
test(a)
<span style=color:#007020;font-weight:700>print</span>(a)</code></pre></div><h4 id=case-2>Case 2</h4><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>test</span>(arg):
    arg<span style=color:#666>.</span>append(<span style=color:#40a070>1</span>)
    <span style=color:#007020;font-weight:700>print</span>(arg)

a <span style=color:#666>=</span> []
test(a)
<span style=color:#007020;font-weight:700>print</span>(a)</code></pre></div><h4 id=case-3>Case 3</h4><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>test</span>(arg):
    arg <span style=color:#666>=</span> arg <span style=color:#666>+</span> [<span style=color:#40a070>1</span>]
    <span style=color:#007020;font-weight:700>print</span>(arg)

a <span style=color:#666>=</span> []
test(a)
<span style=color:#007020;font-weight:700>print</span>(a)</code></pre></div><h4 id=case-4>Case 4</h4><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>test</span>(arg):
    arg <span style=color:#666>+=</span> [<span style=color:#40a070>1</span>]
    <span style=color:#007020;font-weight:700>print</span>(arg)

a <span style=color:#666>=</span> []
test(a)
<span style=color:#007020;font-weight:700>print</span>(a)</code></pre></div><h4 id=case-5>Case 5</h4><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>test</span>(arg<span style=color:#666>=</span>[]):
    arg<span style=color:#666>.</span>append(<span style=color:#40a070>1</span>)
    <span style=color:#007020;font-weight:700>print</span>(arg)

test()
test()</code></pre></div><h2 id=参考>参考</h2><ul><li><a href=https://docs.python.org/3/faq/programming.html#why-did-changing-list-y-also-change-list-x>Why did changing list ‘y’ also change list ‘x’?</a></li><li><a href=http://winterttr.me/2015/10/24/python-passing-arguments-as-value-or-reference/>Python的函数参数传递：传值？引用？</a></li><li><a href=https://foofish.net/python-function-args.html>Python 函数中，参数是传值，还是传引用？</a></li></ul><h2 id=动态>动态</h2><ul><li>通关了《尼尔：机械纪元》，最后十分感动地共享出了自己所有的存档，不说了，六周目见。</li></ul></div><div id=disqus_thread></div><script type=application/javascript>let disqus_config=function(){this.page.identifier='\/2018\/04\/15\/reference-and-copy-in-python\/';this.page.title='Python 中的引用与拷贝';this.page.url='https:\/\/xuanwo.io\/2018\/04\/15\/reference-and-copy-in-python\/';};(function(){let d=document,s=d.createElement('script');s.async=true;s.src='//only0god.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class="footer container"><a class=main-nav-link href=/categories/>分类</a>
<a class=main-nav-link href=/tags/>标签</a>
<a class=main-nav-link href=/series/>专题</a>
<a class=main-nav-link href=/blogroll/>友链</a>
<a class=main-nav-link href=/index.xml>订阅</a>
<script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-51515330-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></footer></body></html>