<!doctype html><html><head><title>Xuanwo&#39;s Blog</title><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="A blog maintained by an interesting programmer."><meta name=keywords content=Technology,Code,Program,Linux,><meta name=author content=Xuanwo><meta property=og:title content="Xuanwo's Blog"><meta property=og:description content="A blog maintained by an interesting programmer."><meta property=og:type content=website><meta property=og:locale content=en_US><meta property=og:url content=https://xuanwo.io/><link href=https://xuanwo.io/index.xml rel=alternate type=application/rss+xml title="Xuanwo's Blog"><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.0/normalize.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/milligram@1.3.0/dist/milligram.min.css integrity="sha256-Ro/wP8uUi8LR71kwIdilf78atpu8bTEwrK5ZotZo+Zc=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.css><link href=http://gmpg.org/xfn/11 rel=profile><meta name=generator content="Hugo 0.54.0"></head><body><div id=container><header id=header><div id=header-outer class=outer><div id=header-inner class=inner><a id=main-nav-toggle class=nav-icon href=javascript:;><svg width="1em" height="1em" viewBox="0 0 100 100"><use xlink:href="/svg/fontawesome.svg#bars"/></svg></a><a id=logo class=logo-text href=https://xuanwo.io>Xuanwo&#39;s Blog</a><nav id=main-nav><a class=main-nav-link href=/categories/>分类</a>
<a class=main-nav-link href=/tags/>标签</a>
<a class=main-nav-link href=/series/>专题</a>
<a class=main-nav-link href=/blogroll/>友链</a>
<a class=main-nav-link href=/index.xml>订阅</a>
<a class=main-nav-link href=/about/>关于我</a></nav></div></div></header><section id=main class=outer><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=/2014/11/21/cf-12d/>Codeforces Beta Round 12 D Ball (Div.2 Only)</a></h1></header><div class=article-meta><a href=/2014/11/21/cf-12d/ class=article-date><time datetime=2014-11-21T22:35:22.000&#43;00:00 itemprop=datePublished>2014-11-21</time></a><div class=post-categories><div class=article-category><a class=article-category-link href=https://xuanwo.io/categories/code>Code</a></div></div></div><div class=article-entry itemprop=articleBody><p><h2 id=题目>题目</h2><p>源地址：</p><p><a href=http://codeforces.com/contest/12/problem/D>http://codeforces.com/contest/12/problem/D</a></p><h1 id=理解>理解</h1><p>一个很神奇的题目= =。
给你N个女人的Beauty，Intelect，Richness值。在i女人和j女人之间如果有Bi&lt;Bj&amp;&amp;Ii&lt;Ij&amp;&amp;Ri&lt;Rj,那么i女人就会去自杀！。！问总共有多少个女人会自杀= =。（这心理是有多阴暗。。。。）
实际上感觉就是一个三维的排序，不过有些细节需要处理。
首先开一个结构体来保存b，i，r以及id号。然后对每一个女人的beauty值排序，然后将b值离散化，作为这个树状数组的下标。然后再对i值进行排序，这样，每次只要getmax(lady[j].id+1)，就能得到当前最大的女的r值。</p></p><p class=article-more-link><a href=/2014/11/21/cf-12d/>Read More</a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=/2014/11/21/cf-13c/>Codeforces Beta Round 13 C Sequence</a></h1></header><div class=article-meta><a href=/2014/11/21/cf-13c/ class=article-date><time datetime=2014-11-21T22:06:59.000&#43;00:00 itemprop=datePublished>2014-11-21</time></a><div class=post-categories><div class=article-category><a class=article-category-link href=https://xuanwo.io/categories/code>Code</a></div></div></div><div class=article-entry itemprop=articleBody><p><h2 id=题目>题目</h2><p>源地址：</p><p><a href=http://codeforces.com/problemset/problem/13/C>http://codeforces.com/problemset/problem/13/C</a></p><h1 id=理解>理解</h1><p>给定一个序列，然后对于每一个数，你都可以进行自增或者自减操作。要求求出使得这个序列变为非减序列的最少操作次数。
我一开始的想法比较朴素，我想，只要找到一个比较的标准，比这个标准大我就&ndash;，比这个标准小我就++，这样就能得到这个非减序列的最少次操作。然后我就开始寻找这样的标准，后来发现，这是一个不可能的任务。因为给定的序列什么可能都有，我没有办法来衡量每一个数对于整体值的重要程度，然后也没有办法来计算操作的次数。
没有思路之后就开始开脑洞了。很显然，我可以得到这样一个结论，对于一个序列中的某一个数而言，步数最少的，肯定是变成左边或者右边的那个数。如果再考虑到对于整体数列的影响（因为这是一个循环的过程，整个数列都有整体上移或者下移的趋势），这个数可能的取值，肯定是这个数列中已经存在的数。不难猜想，如果这个数变成的最后结果不是这个数列中的数，说明这个解一定不是最优解。（因为要么就多操作了，要么就少操作了。
这么说好像有点难懂，我来举一个栗子吧，就是数列<code>4 1 9</code>。很显然，我们一眼就能看出，最优解的状态应该是<code>4 4 9</code>，也就是这个1恰好变成了4。试想，如果1变成了3，状态变为<code>4 3 9</code>，不合题意；如果1变成了5，状态变为<code>4 5 9</code>，符合题意，但是操作数多了1。那么问题来了，我变成<code>3 3 9</code>，难道不好吗？确实是这样，符合题意，而且结果最优。但是我们可以继续想，<code>3 3 9</code>可以，<code>2 2 9</code>可以吗？再继续，<code>1 1 9</code>可以吗？<code>0 0 9</code>可以吗？然后我们就能看出，位于<code>4 4 9</code>到<code>1 1 9</code>之间的数列都是可以的，超过了就不行了。这里的4和1，都是原来数列里面的数。我想，这或许并不是能不能问题，而是算法设计方便的问题。如果取原来数列的数，我们直接进行判断即可；如果不是，我们依然是要取原来数列里的数，判断是否在区间内。
根据上面的讨论，我们不妨得出这样的结论：对任何数进行的操作，最后的结果都是把它们变成原数列中的某个数。
解决了理论上的问题之后，下面进入实际的编码过程。直接开二维数组暴力搞的话，这个问题的时间复杂度过高，不可行。所以我们需要对原数组来一次sort，保证b数组是递增的。然后我们可以看到，dp的过程中，只会用到前后两个数，因此我们可以使用滚动数组来降低空间复杂度。这样，这个问题就得到解了。</p></p><p class=article-more-link><a href=/2014/11/21/cf-13c/>Read More</a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=/2014/11/21/cf-14b/>Codeforces Beta Round 14 B Young Photographer (Div. 2)</a></h1></header><div class=article-meta><a href=/2014/11/21/cf-14b/ class=article-date><time datetime=2014-11-21T21:56:23.000&#43;00:00 itemprop=datePublished>2014-11-21</time></a><div class=post-categories><div class=article-category><a class=article-category-link href=https://xuanwo.io/categories/code>Code</a></div></div></div><div class=article-entry itemprop=articleBody><p><h2 id=题目>题目</h2><p>源地址：</p><p><a href=http://codeforces.com/problemset/problem/14/B>http://codeforces.com/problemset/problem/14/B</a></p><h1 id=理解>理解</h1><p>一个摄影师要拍摄运动员比赛的照片，然后给定摄影师的坐标，以及每一位运动员的活动范围。要求计算出摄影是需要活动的最小步数。
首先我们需要对输入的数据进行一次处理，也就是必须保证左端比右段小。处理完毕之后，两端分别进行sort，这样就得到了运动员活动范围的起点和终点的有序列。显然，只有当最大的起点比最小的终点还小的时候，摄影师才有可能同时看到。然后，如果当前摄影师的坐标比最大的起点小，他只要移动到最大起点即可；如果当前摄影师的坐标比最小的终点大，他就需要移动到最小终点。
这样，我们就得到了摄影师需要移动的距离。</p></p><p class=article-more-link><a href=/2014/11/21/cf-14b/>Read More</a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=/2014/11/21/cf-12c/>Codeforces Beta Round 12 C Fruits (Div.2 Only)</a></h1></header><div class=article-meta><a href=/2014/11/21/cf-12c/ class=article-date><time datetime=2014-11-21T21:54:07.000&#43;00:00 itemprop=datePublished>2014-11-21</time></a><div class=post-categories><div class=article-category><a class=article-category-link href=https://xuanwo.io/categories/code>Code</a></div></div></div><div class=article-entry itemprop=articleBody><p><h2 id=题目>题目</h2><p>源地址：</p><p><a href=http://codeforces.com/contest/12/problem/C>http://codeforces.com/contest/12/problem/C</a></p><h1 id=理解>理解</h1><p>题意并不复杂：给定一些标价牌，然后再给定一些水果的名字，每种水果对应一个标价牌。要求输出水果总价的最大值和最小值。
第一眼感觉很简单，贪心乱搞。标价牌排序之后，如果求最小值就从前往后选；如果求最大值，就从后往前选。这个思路没有太大的问题，然后问题来了，我怎么样才能够得到一个去除重复项，并且能计算出每种水果数量的数据结构呢？
然后我就开始SB了，因为循环的时候字符串写得搓，debug半天，都不符合我的预期。等到队友们基本都过了，我才勉强A题。</p></p><p class=article-more-link><a href=/2014/11/21/cf-12c/>Read More</a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=/2014/11/21/cf-12a/>Codeforces Beta Round 12 A Super Agent (Div.2 Only)</a></h1></header><div class=article-meta><a href=/2014/11/21/cf-12a/ class=article-date><time datetime=2014-11-21T21:44:24.000&#43;00:00 itemprop=datePublished>2014-11-21</time></a><div class=post-categories><div class=article-category><a class=article-category-link href=https://xuanwo.io/categories/code>Code</a></div></div></div><div class=article-entry itemprop=articleBody><p><h2 id=题目>题目</h2><p>源地址：</p><p><a href=http://codeforces.com/problemset/problem/12/A>http://codeforces.com/problemset/problem/12/A</a></p><h1 id=理解>理解</h1><p>问题很简单，要求判断是不是一个中心对称的图形。
直接暴力搞，判断了六次。</p></p><p class=article-more-link><a href=/2014/11/21/cf-12a/>Read More</a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=/2014/11/19/contest-cugb-cf4/>CF拉练第四场</a></h1></header><div class=article-meta><a href=/2014/11/19/contest-cugb-cf4/ class=article-date><time datetime=2014-11-19T15:59:18.000&#43;00:00 itemprop=datePublished>2014-11-19</time></a><div class=post-categories><div class=article-category><a class=article-category-link href=https://xuanwo.io/categories/code>Code</a></div></div></div><div class=article-entry itemprop=articleBody><p>比赛地址 http://acm.hust.edu.cn/vjudge/contest/view.action?cid=62931#overview
比赛总结 这场比赛开的时候，我还在南京= =，并没有好好做，过了水题之后就没有继续往下做了。 剩下的都是赛后补的题，不过自己的DP确实弱，很多都是自己想不明白，一看题解就懂。
分题讲解 A题（阅读题） 题意理解题，只要读懂题目就能A，并不是很难。 http://xuanwo.io/2014/11/13/CF-9A/
B题（字符串） C题（模拟） 感觉也是题意理解题，没有什么算法，只要模拟出翻面的操作就可以。 http://xuanwo.io/2014/11/13/CF-7A/
D题（扩展欧几里得） 用到了扩展欧几里得，模板题。 http://xuanwo.io/2014/11/19/CF-7C/
E题（状态压缩DP） 一开始不是特别明白，折腾了很久才看懂这个递推的公式。 http://xuanwo.io/2014/11/19/CF-8C/
更新日志 2014年11月19日 初稿。</p><p class=article-more-link><a href=/2014/11/19/contest-cugb-cf4/>Read More</a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=/2014/11/19/cf-8c/>Codeforces Beta Round 8 C Looking for Order</a></h1></header><div class=article-meta><a href=/2014/11/19/cf-8c/ class=article-date><time datetime=2014-11-19T13:11:43.000&#43;00:00 itemprop=datePublished>2014-11-19</time></a><div class=post-categories><div class=article-category><a class=article-category-link href=https://xuanwo.io/categories/code>Code</a></div></div></div><div class=article-entry itemprop=articleBody><p><h2 id=题目>题目</h2><p>源地址：</p><p><a href=http://codeforces.com/problemset/problem/8/C>http://codeforces.com/problemset/problem/8/C</a></p><h1 id=理解>理解</h1><p>群里面讨论时，萌神说是一个状态压缩DP，然后我就主动放弃了这道题= =。
实际上，如果用枚举的方法来更新DP，肯定会超时的，有一个小小的技巧在于，小女孩拿东西是没有顺序的。然后在每一次拿东西的时候，都需要更新出两个状态，一种是只拿一个，另一种是拿两个。</p></p><p class=article-more-link><a href=/2014/11/19/cf-8c/>Read More</a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=/2014/11/19/cf-7c/>Codeforces Beta Round 7 C Line</a></h1></header><div class=article-meta><a href=/2014/11/19/cf-7c/ class=article-date><time datetime=2014-11-19T10:40:15.000&#43;00:00 itemprop=datePublished>2014-11-19</time></a><div class=post-categories><div class=article-category><a class=article-category-link href=https://xuanwo.io/categories/code>Code</a></div></div></div><div class=article-entry itemprop=articleBody><p><h2 id=题目>题目</h2><p>源地址：</p><p><a href=http://codeforces.com/problemset/problem/7/C>http://codeforces.com/problemset/problem/7/C</a></p><h1 id=理解>理解</h1><p>扩展欧几里得算法的模板题。
题意很简单，给定方程Ax + By + C = 0。要求满足该方程的两个整数解x，y。
通过简单的变形之后就可以得到x = x<em>(-C/gcd(A,B)) , y = y</em>(-C/gcd(A,B))。</p></p><p class=article-more-link><a href=/2014/11/19/cf-7c/>Read More</a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=/2014/11/16/uva-10003-cutting-sticks/>UVa 10003 Cutting Sticks</a></h1></header><div class=article-meta><a href=/2014/11/16/uva-10003-cutting-sticks/ class=article-date><time datetime=2014-11-16T17:12:15.000&#43;00:00 itemprop=datePublished>2014-11-16</time></a><div class=post-categories><div class=article-category><a class=article-category-link href=https://xuanwo.io/categories/code>Code</a></div></div></div><div class=article-entry itemprop=articleBody><p><h2 id=题目>题目</h2><p>源地址：</p><p><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=944">http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=944</a></p><h1 id=理解>理解</h1><p>之前在COJ上好像做过类似的题目。
同样是木材切割，不过这次每次切割都会消耗跟木棒长度相同的代价，要求的是最小代价的切割。
小脑一动就可以知道，存在递推公式：
<code>dp[x][y]=min(dp[x][y],dp[x][a[k]]+dp[a[k]][y]+y-x)</code></p></p><p class=article-more-link><a href=/2014/11/16/uva-10003-cutting-sticks/>Read More</a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=/2014/11/16/uva-11400-lighting-system-design/>UVa 11400 Lighting System Design</a></h1></header><div class=article-meta><a href=/2014/11/16/uva-11400-lighting-system-design/ class=article-date><time datetime=2014-11-16T16:33:57.000&#43;00:00 itemprop=datePublished>2014-11-16</time></a><div class=post-categories><div class=article-category><a class=article-category-link href=https://xuanwo.io/categories/code>Code</a></div></div></div><div class=article-entry itemprop=articleBody><p><h2 id=题目>题目</h2><p>源地址：</p><p><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2395">http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2395</a></p><h1 id=理解>理解</h1><p>变量多的题目确实头疼，我来稍微捋一下。
题目中给出n中灯泡，不同的灯泡要用不同的电源，相同的灯泡可以使用相同的电源。然后每种灯泡有着四种参数，电压v，电源费用k，每个灯泡的费用c，所需要的该种灯泡的数量l。小脑一动就能明白，每次更换只会采用同一种灯泡，因为不同中灯泡的话要买两种电源，一定不是最优解。
这样的话，按照电压进行排序之后，可以得到递推公式：
<code>dp[i]=min(dp[i], dp[j]+(sum[i]-sum[j])*s[i].c+s[i].k)</code>
其中sum[i]=sum[i-1]+s[i].l;</p></p><p class=article-more-link><a href=/2014/11/16/uva-11400-lighting-system-design/>Read More</a></p></div></div></article><nav id=page-nav><a href=/page/11/ rel=prev class="extend prev">&laquo; Prev</a>
<a href=/>1</a>
<a href=/page/2/>2</a>
<a href=/page/3/>3</a>
<span aria-hidden=true>&hellip;</span>
<a href=/page/11/>11</a>
<span class="page-number current">12</span>
<a href=/page/13/>13</a>
<span aria-hidden=true>&hellip;</span>
<a href=/page/44/>44</a>
<a href=/page/13/ rel=next class="extend next">Next &raquo;</a></nav></section><footer id=footer><div class=outer><div id=footer-info class=inner>&copy; 2019 Xuanwo&#39;s Blog&nbsp;
Powered by <a href=https://gohugo.io target=_blank>Hugo</a></div></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-51515330-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script src=https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js></script><script>tocbot.init({tocSelector:'.article-toc',contentSelector:'.article-entry',headingSelector:'h1, h2, h3, h4, h5',});</script><script>document.getElementById('main-nav-toggle').addEventListener('click',function(){var header=document.getElementById('header');if(header.classList.contains('mobile-on')){header.classList.remove('mobile-on');}else{header.classList.add('mobile-on');}});</script></footer></div></body></html>