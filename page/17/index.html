<!doctype html><html><head><title>Xuanwo&#39;s Blog</title><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="A blog maintained by an interesting programmer."><meta name=keywords content=Technology,Code,Program,Linux,><meta name=author content=Xuanwo><meta property=og:title content="Xuanwo's Blog"><meta property=og:description content="A blog maintained by an interesting programmer."><meta property=og:type content=website><meta property=og:locale content=en_US><meta property=og:url content=https://xuanwo.io/><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.0/normalize.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/milligram@1.3.0/dist/milligram.min.css integrity="sha256-Ro/wP8uUi8LR71kwIdilf78atpu8bTEwrK5ZotZo+Zc=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.css><link href=http://gmpg.org/xfn/11 rel=profile><meta name=generator content="Hugo 0.54.0"></head><body><div id=container><header id=header><div id=header-outer class=outer><div id=header-inner class=inner><a id=main-nav-toggle class=nav-icon href=javascript:;><svg width="1em" height="1em" viewBox="0 0 100 100"><use xlink:href="/svg/fontawesome.svg#bars"/></svg></a><a id=logo class=logo-text href=https://xuanwo.io>Xuanwo&#39;s Blog</a><nav id=main-nav><a class=main-nav-link href=/categories/>分类</a>
<a class=main-nav-link href=/tags/>标签</a>
<a class=main-nav-link href=/series/>专题</a>
<a class=main-nav-link href=/blogroll/>友链</a>
<a class=main-nav-link href=/index.xml>订阅</a>
<a class=main-nav-link href=/about/>关于我</a></nav></div></div></header><section id=main class=outer><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=/2014/11/03/cf-2b/>Codeforces Beta Round 2 B The least round way</a></h1></header><div class=article-meta><a href=/2014/11/03/cf-2b/ class=article-date><time datetime=2014-11-03T15:02:38.000&#43;00:00 itemprop=datePublished>2014-11-03</time></a><div class=post-categories><div class=article-category><a class=article-category-link href=https://xuanwo.io/categories/code>Code</a></div></div></div><div class=article-entry itemprop=articleBody><p><h2 id=题目>题目</h2><p>源地址：</p><p><a href=http://codeforces.com/contest/2/problem/B>http://codeforces.com/contest/2/problem/B</a></p><h1 id=理解>理解</h1><p>比赛的时候没有做出来，一看就知道应该是一个DP，选取一个2或者5最少的路径。
首先处理一下，设TWO为0，FIVE为1。在输入的时候就进行判断，当前输入的数和&rsquo;0&rsquo;，&rsquo;2&rsquo;，&rsquo;5&rsquo;之间的关系。得到的结果存在一个数组中，这样就得到整个数组中最多的0的个数。然后对2和5的数量进行比较，只需要考虑比较少的那个。
然后对第一个数为0的情况进行特判，此时只要随手输出就可以了。如果第一个数不为0，则开始取2比较少的路径开始行走。</p><blockquote><p>大概是我写得不是很优美= =，在提交的时候遇到了各种问题，debug了半天，还是没有找出究竟错在哪里。直到我脑洞一开，把所有变量的定义放在了main函数的里面，居然过了！过了！！了！！！
蛋疼，不知道问题到底在哪里= =，唉，存疑。</p></blockquote></p><p class=article-more-link><a href=/2014/11/03/cf-2b/>Read More</a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=/2014/11/03/cf-4a/>Codeforces Beta Round 4 A Watermelon</a></h1></header><div class=article-meta><a href=/2014/11/03/cf-4a/ class=article-date><time datetime=2014-11-03T11:23:56.000&#43;00:00 itemprop=datePublished>2014-11-03</time></a><div class=post-categories><div class=article-category><a class=article-category-link href=https://xuanwo.io/categories/code>Code</a></div></div></div><div class=article-entry itemprop=articleBody><p><h2 id=题目>题目</h2><p>源地址：</p><p><a href=http://codeforces.com/contest/4/problem/A>http://codeforces.com/contest/4/problem/A</a></p><h1 id=理解>理解</h1><p>真不愧是过了1W+的题= =，水的真可怕。
唯一的trick是当w等于2的时候，不能分成两个偶数。</p></p><p class=article-more-link><a href=/2014/11/03/cf-4a/>Read More</a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=/2014/11/03/cf-3a/>Codeforces Beta Round 3 A Shortest path of the king</a></h1></header><div class=article-meta><a href=/2014/11/03/cf-3a/ class=article-date><time datetime=2014-11-03T11:03:26.000&#43;00:00 itemprop=datePublished>2014-11-03</time></a><div class=post-categories><div class=article-category><a class=article-category-link href=https://xuanwo.io/categories/code>Code</a></div></div></div><div class=article-entry itemprop=articleBody><p><h2 id=题目>题目</h2><p>源地址：</p><p><a href=http://codeforces.com/contest/3/problem/A>http://codeforces.com/contest/3/problem/A</a></p><h1 id=理解>理解</h1><p>第一开始的想法是可以用DFS或者BFS搞定。后来仔细想了想，发现其实不需要这么复杂，通过建立一个坐标系，可以轻松搞定这个问题。
首先坐标化，将A~H转化为1~8，方便后续的处理，同时计算出终点与起点位移在x，y轴上的投影，分别设为mx，my。
然后下面是模拟的步骤：
- 处理斜角：循环对mx和my进行递增或者递减的操作，直到有一个值变为零。
- 处理直线：对mx或者my进行递增或者递减的操作，直到这个值也为零，此时已经模拟完毕。</p><p>有两个值得注意的地方：
- 首先需要输出步数，很显然，步数就是<code>max(abs(mx),abs(my))</code>。
- 不需要记忆路径，每次处理mx和my的时候，顺便把路径输出即可。</p></p><p class=article-more-link><a href=/2014/11/03/cf-3a/>Read More</a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=/2014/11/02/cf-3c/>Codeforces Beta Round 3 C Tic-tac-toe</a></h1></header><div class=article-meta><a href=/2014/11/02/cf-3c/ class=article-date><time datetime=2014-11-02T17:30:22.000&#43;00:00 itemprop=datePublished>2014-11-02</time></a><div class=post-categories><div class=article-category><a class=article-category-link href=https://xuanwo.io/categories/code>Code</a></div></div></div><div class=article-entry itemprop=articleBody><p><h2 id=题目>题目</h2><p>源地址：</p><p><a href=http://codeforces.com/problemset/problem/3/C>http://codeforces.com/problemset/problem/3/C</a></p><h1 id=理解>理解</h1><p>一开始看到3*3，第一反应是想要枚举出所有可能的情况，也就是总共有9^3次种，但是发现自己很难处理这些情况，后来还是决定用暴力模拟的方法来做。</p><h2 id=错误解法>错误解法</h2><p>为了简化情况的讨论，我取&rsquo;.&lsquo;为0，&rsquo;X&rsquo;为1，&rsquo;0&rsquo;为2。这样，只要三个数的积为0，说明没有人胜利；三个数的积为1，说明先手胜；三个数的积为8，说明后手胜。这样，在判定胜负的时候，情况就简单了很多。
但是，我犯的错误就是对非法的状况考虑得不全面，或者说，懒得去自己判定是否非法，直接将非法的判断写在else语句里面，导致这段语句摆在前面挂test4，摆在后面挂test8这样尴尬局面的发生。</p><h2 id=正确解法>正确解法</h2><p>赛后我重新写了这道题，正面强干，没有转换成int数组来处理。将胜负判定和非法判定全都写成了独立的函数，在最开始先判断是否非法，然后判定有没有出现胜者，最后判定是谁进行下一步。</p></p><p class=article-more-link><a href=/2014/11/02/cf-3c/>Read More</a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=/2014/11/02/uva-1374-power-calculus/>UVa 1374 Power Calculus</a></h1></header><div class=article-meta><a href=/2014/11/02/uva-1374-power-calculus/ class=article-date><time datetime=2014-11-02T15:04:43.000&#43;00:00 itemprop=datePublished>2014-11-02</time></a><div class=post-categories><div class=article-category><a class=article-category-link href=https://xuanwo.io/categories/code>Code</a></div></div></div><div class=article-entry itemprop=articleBody><p><h2 id=题目>题目</h2><p>源地址：</p><p><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=512&amp;page=show_problem&amp;problem=4120">http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=512&amp;page=show_problem&amp;problem=4120</a></p><h1 id=理解>理解</h1><p>这次的题意比较清楚，就是给定n，求出从1变换到n的最小步数。
同样的迭代深搜，- -，我不行了= =，一口气补了三道，整个人都虚了。。</p><p>还是来小结一下吧。以前做的DFS都是裸题，很容易就能看出来。而迭代深搜这一类的题目，通常都是给定一些条件，要求求出指定条件的一些组合，可能是字符串也有可能是数。而且，通常都会有暴力的做法，不过姿势不优越的话，很容易超时。
然后在迭代深搜的过程中，一定要注意初始状态和边界条件，要不然很容易陷入死循环或者无法得到完整的结果。</p></p><p class=article-more-link><a href=/2014/11/02/uva-1374-power-calculus/>Read More</a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=/2014/11/02/uva-129-krypton-factor/>UVa 129 Krypton Factor</a></h1></header><div class=article-meta><a href=/2014/11/02/uva-129-krypton-factor/ class=article-date><time datetime=2014-11-02T14:52:47.000&#43;00:00 itemprop=datePublished>2014-11-02</time></a><div class=post-categories><div class=article-category><a class=article-category-link href=https://xuanwo.io/categories/code>Code</a></div></div></div><div class=article-entry itemprop=articleBody><p><h2 id=题目>题目</h2><p>源地址：</p><p><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=3&amp;page=show_problem&amp;problem=65">http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=3&amp;page=show_problem&amp;problem=65</a></p><h1 id=理解>理解</h1><p>题意不是很好懂= =，我搬运一下翻译。</p><blockquote><p>Problem
“超级氪因素大赛”(译注：英国的一档电视心智竞答节目）的主办方雇你来对付那些足智多谋的参赛选手。在比赛的一个环节中，节目主持人将念出一长串的字母来考验选手的记忆能力。因为许多选手都是分析字串模式的高手，为了增加一些比赛的难度，主办方决定不再使用那些含有特定重复子串的字串。但是他们又不能将所有重复的子串都删掉，如果那样的话字串中就不存在两个相同的单字了，这反倒会让问题变的非常简单。为了解决这一问题，他们决定仅删除那些包含相邻重复子串的字串。我们将存在上述相邻重复情况的字串称为“easy”（简单），否则称为“hard”（难）。</p><p>Input and Output
为了能给节目主持人提供无限量的问题字串，要求你来写一个程序执行生成运算。程序从输入中读取多行数据，每行包括两个整数n和L（即按此顺序给出），其中n &gt; 0，L的范围是1 ≤ L ≤ 26。根据这些输入，程序要按照字母表升序打印出第n个“hard”字串（由字母表中的前L个字母构成），并在接下来的一行打印这个串的长度。按照上述规则，第一个串应该是“A”。对于给定的n和L，你可以认为第n个“hard”串是一定存在的。
比方说，当L = 3时，头7个“hard”字串为：
A
AB
ABA
ABAC
ABACA
ABACAB
ABACABA
字串可能很长，因此要将它们分成4个字为一组，中间用空格隔开。如果超过16组，则换一行，再接着输出第17组。
ABAC ABA
7
输入由一行两个零表示结束。你的程序可以限定最大的字串长度为80。</p></blockquote><p>回溯搜索，还用到了string的一些比较方便的函数。</p></p><p class=article-more-link><a href=/2014/11/02/uva-129-krypton-factor/>Read More</a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=/2014/11/02/uva-524-prime-ring-problem/>UVa 524 Prime Ring Problem</a></h1></header><div class=article-meta><a href=/2014/11/02/uva-524-prime-ring-problem/ class=article-date><time datetime=2014-11-02T13:47:34.000&#43;00:00 itemprop=datePublished>2014-11-02</time></a><div class=post-categories><div class=article-category><a class=article-category-link href=https://xuanwo.io/categories/code>Code</a></div></div></div><div class=article-entry itemprop=articleBody><p><h2 id=题目>题目</h2><p>源地址：</p><p><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=465">http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=465</a></p><h1 id=理解>理解</h1><p>一开始写了一个特别暴力的程序，吃饭之前让它一直跑，但是一直到我吃完饭回来还在跑14- -，默然泪。
然后推倒重来，开始用回朔法重写。实际上，我并不需要把所有的排列完全生成出来再进行判断，通过回朔法，我可以在生成排列的同时进行判断。这里也运用了深搜的思想，实际上是一个n*n的矩阵，我要找出满足表达式<code>i+A[cur-1]</code>为指数的那条路径。
搞定了主要的算法，下面就是一些细节的处理。首先，我不需要每一次都调用isPrime函数，因为n&lt;=16，也就是可能出现的最大和是小于32的，我可以在预处理中先判断好是否为质数再拿来用。其次，事先必须指定A[0]=1，vis[1]=1，同时dfs()是从1开始的，注意数组的下标。最后，是输出的处理：每一行末尾的空格，每组数据之间的空行，不要多也不要少，虽然琐碎但是却会决定你能否AC。</p></p><p class=article-more-link><a href=/2014/11/02/uva-524-prime-ring-problem/>Read More</a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=/2014/11/02/uva-725-division/>UVa 725 Division</a></h1></header><div class=article-meta><a href=/2014/11/02/uva-725-division/ class=article-date><time datetime=2014-11-02T11:58:24.000&#43;00:00 itemprop=datePublished>2014-11-02</time></a><div class=post-categories><div class=article-category><a class=article-category-link href=https://xuanwo.io/categories/code>Code</a></div></div></div><div class=article-entry itemprop=articleBody><p><h2 id=题目>题目</h2><p>源地址：</p><p><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=9&amp;page=show_problem&amp;problem=666">http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=9&amp;page=show_problem&amp;problem=666</a></p><h1 id=理解>理解</h1><p>提议比较简单，给你0~9这十个数字，要求将其组合为两个五位数X和Y，使得其满足<code>X/Y=N</code>这样的形式。然后就想到了用STL里面的next_permutation函数，很快把代码写了出来，中间还用到了queue来存储答案。不过WA了两发之后开始怀疑是不是STL效率太低导致T了，改用数组模拟，但是还是WA了。经过三个小时的漫长Debug之路，才发现原来问题出在<strong>输入输出</strong>，<strong>我多输出了一个空行！！！</strong>
真的是。。。太。。。</p></p><p class=article-more-link><a href=/2014/11/02/uva-725-division/>Read More</a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=/2014/11/01/codevs-1011/>CodeVS 1011 数的计算</a></h1></header><div class=article-meta><a href=/2014/11/01/codevs-1011/ class=article-date><time datetime=2014-11-01T10:39:19.000&#43;00:00 itemprop=datePublished>2014-11-01</time></a><div class=post-categories><div class=article-category><a class=article-category-link href=https://xuanwo.io/categories/code>Code</a></div></div></div><div class=article-entry itemprop=articleBody><p><h2 id=题目>题目</h2><p>源地址：</p><p><a href=http://codevs.cn/problem/1011/>http://codevs.cn/problem/1011/</a></p><h1 id=理解>理解</h1><p>题目的分类是递推，自然就往递推那个方向去想。
通过简单的推理可以发现，f[n]的值恰好等于f[1]~f[n/2]的和，之后的代码就比较简单了。</p></p><p class=article-more-link><a href=/2014/11/01/codevs-1011/>Read More</a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=/2014/11/01/codevs-1012/>CodeVS 1012 最大公约数和最小公倍数问题</a></h1></header><div class=article-meta><a href=/2014/11/01/codevs-1012/ class=article-date><time datetime=2014-11-01T10:17:25.000&#43;00:00 itemprop=datePublished>2014-11-01</time></a><div class=post-categories><div class=article-category><a class=article-category-link href=https://xuanwo.io/categories/code>Code</a></div></div></div><div class=article-entry itemprop=articleBody><p><h2 id=题目>题目</h2><p>源地址：</p><p><a href=http://codevs.cn/problem/1012/>http://codevs.cn/problem/1012/</a></p><h1 id=理解>理解</h1><p>自然是水题= =。只要用一个循环就可以搞定，最大公约数用gcd，最小公倍数就是i*j/gcd(i,j)，没有什么问题。
不过这个题意不是很清晰，是否为同一组数字的判断并没有讲到。实际上，<code>3 60</code>和<code>60 3</code>是两组数组。这个理解上的问题，导致我的结果一直都是标准答案的一半，折腾了一会儿。
除此之外，这个简单的思路还有很多可以优化的地方，比如在判断了gcd是否等于x之后，后面判断最小公倍数只要使用i*j/x就可以了；还有，一开始令i=x之后，后面每一次都递增x就可以保证i与j始终为x的约束，但注意，还是要用gcd来判断最大公约数是不是x；过题之后找了一下题解，发现有人提出，循环的最大值是sqrt(y)，稍微想了想，确实如此，这个优化也能省下很多循环。</p></p><p class=article-more-link><a href=/2014/11/01/codevs-1012/>Read More</a></p></div></div></article><nav id=page-nav><a href=/page/16/ rel=prev class="extend prev">&laquo; Prev</a>
<a href=/>1</a>
<a href=/page/2/>2</a>
<a href=/page/3/>3</a>
<span aria-hidden=true>&hellip;</span>
<a href=/page/16/>16</a>
<span class="page-number current">17</span>
<a href=/page/18/>18</a>
<span aria-hidden=true>&hellip;</span>
<a href=/page/44/>44</a>
<a href=/page/18/ rel=next class="extend next">Next &raquo;</a></nav></section><footer id=footer><div class=outer><div id=footer-info class=inner>&copy; 2019 Xuanwo&#39;s Blog&nbsp;
Powered by <a href=https://gohugo.io target=_blank>Hugo</a></div></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-51515330-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script src=https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js></script><script>tocbot.init({tocSelector:'.article-toc',contentSelector:'.article-entry',headingSelector:'h1, h2, h3, h4, h5',});</script><script>document.getElementById('main-nav-toggle').addEventListener('click',function(){var header=document.getElementById('header');if(header.classList.contains('mobile-on')){header.classList.remove('mobile-on');}else{header.classList.add('mobile-on');}});</script></footer></div></body></html>