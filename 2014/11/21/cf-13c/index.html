<!doctype html><html><head><title>Codeforces Beta Round 13 C Sequence</title><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="A blog maintained by an interesting programmer."><meta name=keywords content="Technology,Code,Program,Linux,"><meta name=author content="Xuanwo"><meta property="og:title" content="Codeforces Beta Round 13 C Sequence"><meta property="og:description" content="A blog maintained by an interesting programmer."><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://xuanwo.io/2014/11/21/cf-13c/"><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=https://xuanwo.io/css/main.min.be107db044369d658c06efdc8f7f5462fda2b704c0a580ab8c227b3dad6ac109.css integrity="sha256-vhB9sEQ2nWWMBu/cj39UYv2itwTApYCrjCJ7Pa1qwQk="><script data-ad-client=ca-pub-8380875817494486 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><link href=http://gmpg.org/xfn/11 rel=profile><meta name=generator content="Hugo 0.65.3"></head><body><nav class=nav><div class=nav-container><div class=brand><a href=https://xuanwo.io>Xuanwo's Blog</a></div><div class=links><a class=main-nav-link href=/about/>关于我</a>
<a class=main-nav-link href=/posts/>文章</a></div></div></nav><main id=main-content><article class="single container"><header class=single-header><div class=flex><h1>Codeforces Beta Round 13 C Sequence</h1><div class=post-meta><time class=date datetime=2014-11-21T22:06:59.000+00:00 itemprop=datePublished>2014-11-21</time>
/
<span><a href=#disqus_thread class=comment-link>Comments</a></span></div><div class=tag-container></div></div></header><div class=post><h2 id=题目>题目</h2><p>源地址：</p><p><a href=http://codeforces.com/problemset/problem/13/C>http://codeforces.com/problemset/problem/13/C</a></p><h1 id=理解>理解</h1><p>给定一个序列，然后对于每一个数，你都可以进行自增或者自减操作。要求求出使得这个序列变为非减序列的最少操作次数。
我一开始的想法比较朴素，我想，只要找到一个比较的标准，比这个标准大我就&ndash;，比这个标准小我就++，这样就能得到这个非减序列的最少次操作。然后我就开始寻找这样的标准，后来发现，这是一个不可能的任务。因为给定的序列什么可能都有，我没有办法来衡量每一个数对于整体值的重要程度，然后也没有办法来计算操作的次数。
没有思路之后就开始开脑洞了。很显然，我可以得到这样一个结论，对于一个序列中的某一个数而言，步数最少的，肯定是变成左边或者右边的那个数。如果再考虑到对于整体数列的影响（因为这是一个循环的过程，整个数列都有整体上移或者下移的趋势），这个数可能的取值，肯定是这个数列中已经存在的数。不难猜想，如果这个数变成的最后结果不是这个数列中的数，说明这个解一定不是最优解。（因为要么就多操作了，要么就少操作了。
这么说好像有点难懂，我来举一个栗子吧，就是数列<code>4 1 9</code>。很显然，我们一眼就能看出，最优解的状态应该是<code>4 4 9</code>，也就是这个1恰好变成了4。试想，如果1变成了3，状态变为<code> 4 3 9</code>，不合题意；如果1变成了5，状态变为<code>4 5 9</code>，符合题意，但是操作数多了1。那么问题来了，我变成<code>3 3 9</code>，难道不好吗？确实是这样，符合题意，而且结果最优。但是我们可以继续想，<code>3 3 9</code>可以，<code>2 2 9</code>可以吗？再继续，<code>1 1 9</code>可以吗？<code>0 0 9</code>可以吗？然后我们就能看出，位于<code>4 4 9</code>到<code>1 1 9</code>之间的数列都是可以的，超过了就不行了。这里的4和1，都是原来数列里面的数。我想，这或许并不是能不能问题，而是算法设计方便的问题。如果取原来数列的数，我们直接进行判断即可；如果不是，我们依然是要取原来数列里的数，判断是否在区间内。
根据上面的讨论，我们不妨得出这样的结论：对任何数进行的操作，最后的结果都是把它们变成原数列中的某个数。
解决了理论上的问题之后，下面进入实际的编码过程。直接开二维数组暴力搞的话，这个问题的时间复杂度过高，不可行。所以我们需要对原数组来一次sort，保证b数组是递增的。然后我们可以看到，dp的过程中，只会用到前后两个数，因此我们可以使用滚动数组来降低空间复杂度。这样，这个问题就得到解了。</p><h1 id=代码>代码</h1><pre><code>
#define MAXN 5000+10

ll n;
ll a[MAXN];
ll b[MAXN];
ll dp[MAXN];
ll small,ans,flag;

void init()
{
    memset(dp, 0, sizeof(dp));
    scanf(&quot;%I64d&quot;, &amp;n);
    for(int i=0;i&lt;n;i++)
    {
        scanf(&quot;%I64d&quot;, &amp;a[i]);
        b[i]=a[i];
    }
    sort(b,b+n);
}

int main(int argc, char const *argv[])
{
    init();
    for(int i=0;i&lt;n;i++)
    {
        for(int j=0;j&lt;n;j++)
        {
            dp[j]+=abs(a[i]-b[j]);
            if(j&gt;1)
            {
                dp[j]=min(dp[j-1],dp[j]);
            }
        }
    }
    printf(&quot;%I64d\n&quot;, dp[n-1]);
    return 0;
}

</code></pre><h1 id=更新日志>更新日志</h1><ul><li>2014年11月21日 已AC。</li></ul></div><div id=disqus_thread></div><script type=application/javascript async>let disqus_config=function(){this.page.identifier='\/2014\/11\/21\/cf-13c\/';this.page.title='Codeforces Beta Round 13 C Sequence';this.page.url='https:\/\/xuanwo.io\/2014\/11\/21\/cf-13c\/';};(function(){let d=document,s=d.createElement('script');s.async=true;s.src='//only0god.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script></article></main><footer class="footer container"><a class=main-nav-link href=/categories/>分类</a>
<a class=main-nav-link href=/tags/>标签</a>
<a class=main-nav-link href=/series/>专题</a>
<a class=main-nav-link href=/blogroll/>友链</a>
<a class=main-nav-link href=/index.xml>订阅</a>
<script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-51515330-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></footer></body></html>