<!doctype html><html><head><title>Golang Panic 行为探秘</title><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="A blog maintained by an interesting programmer."><meta name=keywords content="Technology,Code,Program,Linux,"><meta name=author content="Xuanwo"><meta property="og:title" content="Golang Panic 行为探秘"><meta property="og:description" content="A blog maintained by an interesting programmer."><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://xuanwo.io/2019/05/25/go-panic/"><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=https://xuanwo.io/css/main.min.5a9ffcf343273240b691845bba645faa19f2008c05742711b684042a3063818b.css integrity="sha256-Wp/880MnMkC2kYRbumRfqhnyAIwFdCcRtoQEKjBjgYs="><script data-ad-client=ca-pub-8380875817494486 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><link href=http://gmpg.org/xfn/11 rel=profile><meta name=generator content="Hugo 0.68.3"></head><body><nav class=nav><div class=nav-container><div class=brand><a href=https://xuanwo.io>Xuanwo's Blog</a></div><div class=links><a class=main-nav-link href=/about/>About</a>
<a class=main-nav-link href=/posts/>Posts</a></div></div></nav><main id=main-content><article class="single container"><header class=single-header><div class=flex><h1>Golang Panic 行为探秘</h1><div class=post-meta><time class=date datetime=2019-05-25T01:00:00.000+00:00 itemprop=datePublished>2019-05-25</time></div><div class=tag-container><a style=text-decoration:none href=https://xuanwo.io/tags/golang><span>golang</span></a></div></div></header><div class=post><blockquote><p>This post is the 1 / 2 post in
<a href=https://xuanwo.io/series/satisfy-curiosity>Satisfy Curiosity</a> Series.</p></blockquote><p>为了满足分布式系统测试的需求，我们经常需要在代码中埋下断点，以便于通过修改编译参数或者注册特定 Hook 的方式来强迫程序走特定的逻辑。这篇文章主要分享了我在实现 BreakPoint 时发现的 Golang Panic && Recover 的一个好玩行为及其背后的原因。</p><h2 id=复现>复现</h2><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#007020;font-weight:700>package</span> runtime

<span style=color:#007020;font-weight:700>import</span> (
	<span style=color:#4070a0>&#34;testing&#34;</span>
)

<span style=color:#007020;font-weight:700>func</span> <span style=color:#06287e>TestRecover</span>(t <span style=color:#666>*</span>testing.T) {
	<span style=color:#007020;font-weight:700>defer</span> <span style=color:#007020;font-weight:700>func</span>() {
		<span style=color:#007020>recover</span>()
	}()
	<span style=color:#007020>panic</span>(<span style=color:#4070a0>&#34;panic in test&#34;</span>)
}

<span style=color:#007020;font-weight:700>func</span> <span style=color:#06287e>TestRecoverInClosure</span>(t <span style=color:#666>*</span>testing.T) {
	<span style=color:#007020;font-weight:700>defer</span> <span style=color:#007020;font-weight:700>func</span>() {
		<span style=color:#60a0b0;font-style:italic>// This should be the callback function of a break point.
</span><span style=color:#60a0b0;font-style:italic></span>		<span style=color:#60a0b0;font-style:italic>// Let&#39;s call them directly for simpler example.
</span><span style=color:#60a0b0;font-style:italic></span>		<span style=color:#007020;font-weight:700>func</span>() {
			<span style=color:#007020>recover</span>()
		}()
	}()
	<span style=color:#007020>panic</span>(<span style=color:#4070a0>&#34;panic in test&#34;</span>)
}
</code></pre></div><p><code>TestRecover</code> 演示的是一个比较常见的情况，业务逻辑中可能会出现 panic，我们在 defer 的函数中执行 recover 并做进一步的处理。而 <code>TestRecoverInClosure</code> 中演示的则是我原本想要实现的逻辑，断点在触发时去调用在注册断点时传入的回调函数，在回调函数中去执行 recover 并获得 panic 的现场内容。但是事实证明这样是行不通的，在 <code>TestRecoverInClosure</code> 中，panic 并没有被捕获，而是直接抛到了最外层，在闭包中的 recover 也自然是什么都没有拿到，翻车现场如下：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#666>==</span>= RUN   TestRecoverInClosure
<span style=color:#666>---</span> FAIL: <span style=color:#06287e>TestRecoverInClosure</span> (<span style=color:#40a070>0.00</span>s)
panic: panic in test [recovered]
	panic: panic in test

goroutine <span style=color:#40a070>6</span> [running]:
testing.tRunner.<span style=color:#06287e>func1</span>(<span style=color:#40a070>0xc000138400</span>)
	<span style=color:#666>/</span>usr<span style=color:#666>/</span>lib<span style=color:#666>/</span><span style=color:#007020;font-weight:700>go</span><span style=color:#666>/</span>src<span style=color:#666>/</span>testing<span style=color:#666>/</span>testing.<span style=color:#007020;font-weight:700>go</span>:<span style=color:#40a070>830</span> <span style=color:#666>+</span><span style=color:#40a070>0x392</span>
<span style=color:#007020>panic</span>(<span style=color:#40a070>0x8c1140</span>, <span style=color:#40a070>0xb4d1a0</span>)
	<span style=color:#666>/</span>usr<span style=color:#666>/</span>lib<span style=color:#666>/</span><span style=color:#007020;font-weight:700>go</span><span style=color:#666>/</span>src<span style=color:#666>/</span>runtime<span style=color:#666>/</span>panic.<span style=color:#007020;font-weight:700>go</span>:<span style=color:#40a070>522</span> <span style=color:#666>+</span><span style=color:#40a070>0x1b5</span>
xuanwo<span style=color:#666>/</span>playground<span style=color:#666>/</span>runtime.<span style=color:#06287e>TestRecoverInClosure</span>(<span style=color:#40a070>0xc000138400</span>)
	<span style=color:#666>/</span>home<span style=color:#666>/</span>xuanwo<span style=color:#666>/</span>Code<span style=color:#666>/</span>xuanwo<span style=color:#666>/</span>playground<span style=color:#666>/</span>runtime<span style=color:#666>/</span>panic_test.<span style=color:#007020;font-weight:700>go</span>:<span style=color:#40a070>22</span> <span style=color:#666>+</span><span style=color:#40a070>0x55</span>
testing.<span style=color:#06287e>tRunner</span>(<span style=color:#40a070>0xc000138400</span>, <span style=color:#40a070>0xad0678</span>)
	<span style=color:#666>/</span>usr<span style=color:#666>/</span>lib<span style=color:#666>/</span><span style=color:#007020;font-weight:700>go</span><span style=color:#666>/</span>src<span style=color:#666>/</span>testing<span style=color:#666>/</span>testing.<span style=color:#007020;font-weight:700>go</span>:<span style=color:#40a070>865</span> <span style=color:#666>+</span><span style=color:#40a070>0xc0</span>
created by testing.(<span style=color:#666>*</span>T).Run
	<span style=color:#666>/</span>usr<span style=color:#666>/</span>lib<span style=color:#666>/</span><span style=color:#007020;font-weight:700>go</span><span style=color:#666>/</span>src<span style=color:#666>/</span>testing<span style=color:#666>/</span>testing.<span style=color:#007020;font-weight:700>go</span>:<span style=color:#40a070>916</span> <span style=color:#666>+</span><span style=color:#40a070>0x35a</span>
</code></pre></div><h2 id=原因>原因</h2><p>为了搞清楚问题的原因，首先需要知道 panic && defer 是怎么工作。Golang 中 panic 和 defer 实现的相关代码主要是在 <code>/usr/lib/go/src/runtime/panic.go</code> 中，下文贴出来的代码来自于 Go 1.12.5。</p><h3 id=defer>defer</h3><p>在了解 panic 之前，首先看看 defer 是如何实现并存储的：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#60a0b0;font-style:italic>// Allocate a Defer, usually using per-P pool.
</span><span style=color:#60a0b0;font-style:italic>// Each defer must be released with freedefer.
</span><span style=color:#60a0b0;font-style:italic>//
</span><span style=color:#60a0b0;font-style:italic>// This must not grow the stack because there may be a frame without
</span><span style=color:#60a0b0;font-style:italic>// stack map information when this is called.
</span><span style=color:#60a0b0;font-style:italic>//
</span><span style=color:#60a0b0;font-style:italic>//go:nosplit
</span><span style=color:#60a0b0;font-style:italic></span><span style=color:#007020;font-weight:700>func</span> <span style=color:#06287e>newdefer</span>(siz <span style=color:#902000>int32</span>) <span style=color:#666>*</span>_defer {
	<span style=color:#007020;font-weight:700>var</span> d <span style=color:#666>*</span>_defer
	sc <span style=color:#666>:=</span> <span style=color:#06287e>deferclass</span>(<span style=color:#007020>uintptr</span>(siz))
	gp <span style=color:#666>:=</span> <span style=color:#06287e>getg</span>()
	<span style=color:#007020;font-weight:700>if</span> sc &lt; <span style=color:#007020>uintptr</span>(<span style=color:#007020>len</span>(p{}.deferpool)) {
		<span style=color:#666>...</span>
	}
	<span style=color:#007020;font-weight:700>if</span> d <span style=color:#666>==</span> <span style=color:#007020;font-weight:700>nil</span> {
		<span style=color:#60a0b0;font-style:italic>// Allocate new defer+args.
</span><span style=color:#60a0b0;font-style:italic></span>		<span style=color:#06287e>systemstack</span>(<span style=color:#007020;font-weight:700>func</span>() {
			total <span style=color:#666>:=</span> <span style=color:#06287e>roundupsize</span>(<span style=color:#06287e>totaldefersize</span>(<span style=color:#007020>uintptr</span>(siz)))
			d = (<span style=color:#666>*</span>_defer)(<span style=color:#06287e>mallocgc</span>(total, deferType, <span style=color:#007020;font-weight:700>true</span>))
		})
		<span style=color:#666>...</span>
	}
	d.siz = siz
	d.link = gp._defer
	gp._defer = d
	<span style=color:#007020;font-weight:700>return</span> d
}
</code></pre></div><blockquote><p>这里的 <code>getg()</code> 返回的是当前正在执行的 goroutine。</p></blockquote><p>这里可以忽略掉具体的实现细节，只需要关注初始化 defer 和更新 <code>gp._defer</code> 的过程。不难看出 <code>_defer</code> 结构体是以链表的形式存储在 gouroutine 中的，下面 panic 的实现会高度依赖这一点。</p><h3 id=panic>panic</h3><p>下面来看一下 panic 的实现，首先看一下整体的结构，然后挑出一些我认为需要关注的地方展开聊一聊。</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#60a0b0;font-style:italic>// The implementation of the predeclared function panic.
</span><span style=color:#60a0b0;font-style:italic></span><span style=color:#007020;font-weight:700>func</span> <span style=color:#06287e>gopanic</span>(e <span style=color:#007020;font-weight:700>interface</span>{}) {
	gp <span style=color:#666>:=</span> <span style=color:#06287e>getg</span>()

	<span style=color:#666>...</span>

	<span style=color:#007020;font-weight:700>var</span> p _panic
	p.arg = e
	p.link = gp._panic
	gp._panic = (<span style=color:#666>*</span>_panic)(<span style=color:#06287e>noescape</span>(unsafe.<span style=color:#06287e>Pointer</span>(<span style=color:#666>&amp;</span>p)))

	atomic.<span style=color:#06287e>Xadd</span>(<span style=color:#666>&amp;</span>runningPanicDefers, <span style=color:#40a070>1</span>)

	<span style=color:#007020;font-weight:700>for</span> {
		d <span style=color:#666>:=</span> gp._defer
		<span style=color:#007020;font-weight:700>if</span> d <span style=color:#666>==</span> <span style=color:#007020;font-weight:700>nil</span> {
			<span style=color:#007020;font-weight:700>break</span>
		}

		<span style=color:#60a0b0;font-style:italic>// If defer was started by earlier panic or Goexit (and, since we&#39;re back here, that triggered a new panic),
</span><span style=color:#60a0b0;font-style:italic></span>		<span style=color:#60a0b0;font-style:italic>// take defer off list. The earlier panic or Goexit will not continue running.
</span><span style=color:#60a0b0;font-style:italic></span>		<span style=color:#007020;font-weight:700>if</span> d.started {
			<span style=color:#007020;font-weight:700>if</span> d._panic <span style=color:#666>!=</span> <span style=color:#007020;font-weight:700>nil</span> {
				d._panic.aborted = <span style=color:#007020;font-weight:700>true</span>
			}
			d._panic = <span style=color:#007020;font-weight:700>nil</span>
			d.fn = <span style=color:#007020;font-weight:700>nil</span>
			gp._defer = d.link
			<span style=color:#06287e>freedefer</span>(d)
			<span style=color:#007020;font-weight:700>continue</span>
		}

		<span style=color:#60a0b0;font-style:italic>// Mark defer as started, but keep on list, so that traceback
</span><span style=color:#60a0b0;font-style:italic></span>		<span style=color:#60a0b0;font-style:italic>// can find and update the defer&#39;s argument frame if stack growth
</span><span style=color:#60a0b0;font-style:italic></span>		<span style=color:#60a0b0;font-style:italic>// or a garbage collection happens before reflectcall starts executing d.fn.
</span><span style=color:#60a0b0;font-style:italic></span>		d.started = <span style=color:#007020;font-weight:700>true</span>

		<span style=color:#60a0b0;font-style:italic>// Record the panic that is running the defer.
</span><span style=color:#60a0b0;font-style:italic></span>		<span style=color:#60a0b0;font-style:italic>// If there is a new panic during the deferred call, that panic
</span><span style=color:#60a0b0;font-style:italic></span>		<span style=color:#60a0b0;font-style:italic>// will find d in the list and will mark d._panic (this panic) aborted.
</span><span style=color:#60a0b0;font-style:italic></span>		d._panic = (<span style=color:#666>*</span>_panic)(<span style=color:#06287e>noescape</span>(unsafe.<span style=color:#06287e>Pointer</span>(<span style=color:#666>&amp;</span>p)))

		p.argp = unsafe.<span style=color:#06287e>Pointer</span>(<span style=color:#06287e>getargp</span>(<span style=color:#40a070>0</span>))
		<span style=color:#06287e>reflectcall</span>(<span style=color:#007020;font-weight:700>nil</span>, unsafe.<span style=color:#06287e>Pointer</span>(d.fn), <span style=color:#06287e>deferArgs</span>(d), <span style=color:#007020>uint32</span>(d.siz), <span style=color:#007020>uint32</span>(d.siz))
		p.argp = <span style=color:#007020;font-weight:700>nil</span>

		<span style=color:#666>...</span>

		pc <span style=color:#666>:=</span> d.pc
		sp <span style=color:#666>:=</span> unsafe.<span style=color:#06287e>Pointer</span>(d.sp) <span style=color:#60a0b0;font-style:italic>// must be pointer so it gets adjusted during stack copy
</span><span style=color:#60a0b0;font-style:italic></span>		<span style=color:#06287e>freedefer</span>(d)
		<span style=color:#007020;font-weight:700>if</span> p.recovered {
			atomic.<span style=color:#06287e>Xadd</span>(<span style=color:#666>&amp;</span>runningPanicDefers, <span style=color:#666>-</span><span style=color:#40a070>1</span>)

			gp._panic = p.link
			<span style=color:#60a0b0;font-style:italic>// Aborted panics are marked but remain on the g.panic list.
</span><span style=color:#60a0b0;font-style:italic></span>			<span style=color:#60a0b0;font-style:italic>// Remove them from the list.
</span><span style=color:#60a0b0;font-style:italic></span>			<span style=color:#007020;font-weight:700>for</span> gp._panic <span style=color:#666>!=</span> <span style=color:#007020;font-weight:700>nil</span> <span style=color:#666>&amp;&amp;</span> gp._panic.aborted {
				gp._panic = gp._panic.link
			}
			<span style=color:#007020;font-weight:700>if</span> gp._panic <span style=color:#666>==</span> <span style=color:#007020;font-weight:700>nil</span> { <span style=color:#60a0b0;font-style:italic>// must be done with signal
</span><span style=color:#60a0b0;font-style:italic></span>				gp.sig = <span style=color:#40a070>0</span>
			}
			<span style=color:#60a0b0;font-style:italic>// Pass information about recovering frame to recovery.
</span><span style=color:#60a0b0;font-style:italic></span>			gp.sigcode0 = <span style=color:#007020>uintptr</span>(sp)
			gp.sigcode1 = pc
			<span style=color:#06287e>mcall</span>(recovery)
			<span style=color:#06287e>throw</span>(<span style=color:#4070a0>&#34;recovery failed&#34;</span>) <span style=color:#60a0b0;font-style:italic>// mcall should not return
</span><span style=color:#60a0b0;font-style:italic></span>		}
	}

	<span style=color:#60a0b0;font-style:italic>// ran out of deferred calls - old-school panic now
</span><span style=color:#60a0b0;font-style:italic></span>	<span style=color:#60a0b0;font-style:italic>// Because it is unsafe to call arbitrary user code after freezing
</span><span style=color:#60a0b0;font-style:italic></span>	<span style=color:#60a0b0;font-style:italic>// the world, we call preprintpanics to invoke all necessary Error
</span><span style=color:#60a0b0;font-style:italic></span>	<span style=color:#60a0b0;font-style:italic>// and String methods to prepare the panic strings before startpanic.
</span><span style=color:#60a0b0;font-style:italic></span>	<span style=color:#06287e>preprintpanics</span>(gp._panic)

	<span style=color:#06287e>fatalpanic</span>(gp._panic) <span style=color:#60a0b0;font-style:italic>// should not return
</span><span style=color:#60a0b0;font-style:italic></span>	<span style=color:#666>*</span>(<span style=color:#666>*</span><span style=color:#902000>int</span>)(<span style=color:#007020;font-weight:700>nil</span>) = <span style=color:#40a070>0</span>      <span style=color:#60a0b0;font-style:italic>// not reached
</span><span style=color:#60a0b0;font-style:italic></span>}
</code></pre></div><p>跟 <code>_defer</code> 一样，<code>_panic</code> 结构也是以链表形式存储在 goroutine 中的。</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#007020;font-weight:700>var</span> p _panic
p.arg = e
p.link = gp._panic
gp._panic = (<span style=color:#666>*</span>_panic)(<span style=color:#06287e>noescape</span>(unsafe.<span style=color:#06287e>Pointer</span>(<span style=color:#666>&amp;</span>p)))
</code></pre></div><p>首先取出第一个 panic 节点，然后进入 for 循环。</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang>d <span style=color:#666>:=</span> gp._defer
<span style=color:#007020;font-weight:700>if</span> d <span style=color:#666>==</span> <span style=color:#007020;font-weight:700>nil</span> {
	<span style=color:#007020;font-weight:700>break</span>
}
</code></pre></div><p>取出对头的第一个 <code>_defer</code> 结构，开始执行 defer 函数，如果为空的话会直接 break 并抛出错误的堆栈。</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#60a0b0;font-style:italic>// If defer was started by earlier panic or Goexit (and, since we&#39;re back here, that triggered a new panic),
</span><span style=color:#60a0b0;font-style:italic>// take defer off list. The earlier panic or Goexit will not continue running.
</span><span style=color:#60a0b0;font-style:italic></span><span style=color:#007020;font-weight:700>if</span> d.started {
	<span style=color:#007020;font-weight:700>if</span> d._panic <span style=color:#666>!=</span> <span style=color:#007020;font-weight:700>nil</span> {
		d._panic.aborted = <span style=color:#007020;font-weight:700>true</span>
	}
	d._panic = <span style=color:#007020;font-weight:700>nil</span>
	d.fn = <span style=color:#007020;font-weight:700>nil</span>
	gp._defer = d.link
	<span style=color:#06287e>freedefer</span>(d)
	<span style=color:#007020;font-weight:700>continue</span>
}

<span style=color:#60a0b0;font-style:italic>// Mark defer as started, but keep on list, so that traceback
</span><span style=color:#60a0b0;font-style:italic>// can find and update the defer&#39;s argument frame if stack growth
</span><span style=color:#60a0b0;font-style:italic>// or a garbage collection happens before reflectcall starts executing d.fn.
</span><span style=color:#60a0b0;font-style:italic></span>d.started = <span style=color:#007020;font-weight:700>true</span>

<span style=color:#60a0b0;font-style:italic>// Record the panic that is running the defer.
</span><span style=color:#60a0b0;font-style:italic>// If there is a new panic during the deferred call, that panic
</span><span style=color:#60a0b0;font-style:italic>// will find d in the list and will mark d._panic (this panic) aborted.
</span><span style=color:#60a0b0;font-style:italic></span>d._panic = (<span style=color:#666>*</span>_panic)(<span style=color:#06287e>noescape</span>(unsafe.<span style=color:#06287e>Pointer</span>(<span style=color:#666>&amp;</span>p)))
</code></pre></div><p>当一个 defer 函数开始执行时会将 <code>started</code> 标志置为 <code>true</code>，这样就可以知道是不是在这个 defer 函数执行过程中再次出现了 panic。下面修改 <code>_panic</code> 指针也是类似的操作，这些与我本次分享主题无关，就不展开叙述了。</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang>p.argp = unsafe.<span style=color:#06287e>Pointer</span>(<span style=color:#06287e>getargp</span>(<span style=color:#40a070>0</span>))
<span style=color:#06287e>reflectcall</span>(<span style=color:#007020;font-weight:700>nil</span>, unsafe.<span style=color:#06287e>Pointer</span>(d.fn), <span style=color:#06287e>deferArgs</span>(d), <span style=color:#007020>uint32</span>(d.siz), <span style=color:#007020>uint32</span>(d.siz))
p.argp = <span style=color:#007020;font-weight:700>nil</span>
</code></pre></div><p>这里出现了函数执行逻辑的切换，gopanic 中会调用 <code>reflectcall</code> 去复制 defer 函数的参数并执行 defer 函数。</p><p>在 <code>reflectcall</code> 执行前修改 <code>p.argp</code> 为 <code>unsafe.Pointer(getargp(0))</code> ，是当前 defer 函数调用的参数指针，或者说是 defer 函数的内存地址（<strong>这个地方我理解的可能有些问题</strong>），在 <code>reflectcall</code> 执行成功后再修改为 nil 避免影响下一次的循环。</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#007020;font-weight:700>if</span> p.recovered {
	atomic.<span style=color:#06287e>Xadd</span>(<span style=color:#666>&amp;</span>runningPanicDefers, <span style=color:#666>-</span><span style=color:#40a070>1</span>)

	<span style=color:#666>...</span>

	<span style=color:#06287e>mcall</span>(recovery)
	<span style=color:#06287e>throw</span>(<span style=color:#4070a0>&#34;recovery failed&#34;</span>) <span style=color:#60a0b0;font-style:italic>// mcall should not return
</span><span style=color:#60a0b0;font-style:italic></span>}
</code></pre></div><p>在 defer 函数执行成功后，通过 <code>p.recovered</code> 来判断是否已经成功 recover 并执行 recovery，这里不再展开。</p><h3 id=recover>recover</h3><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#007020;font-weight:700>func</span> <span style=color:#06287e>gorecover</span>(argp <span style=color:#902000>uintptr</span>) <span style=color:#007020;font-weight:700>interface</span>{} {
	<span style=color:#60a0b0;font-style:italic>// Must be in a function running as part of a deferred call during the panic.
</span><span style=color:#60a0b0;font-style:italic></span>	<span style=color:#60a0b0;font-style:italic>// Must be called from the topmost function of the call
</span><span style=color:#60a0b0;font-style:italic></span>	<span style=color:#60a0b0;font-style:italic>// (the function used in the defer statement).
</span><span style=color:#60a0b0;font-style:italic></span>	<span style=color:#60a0b0;font-style:italic>// p.argp is the argument pointer of that topmost deferred function call.
</span><span style=color:#60a0b0;font-style:italic></span>	<span style=color:#60a0b0;font-style:italic>// Compare against argp reported by caller.
</span><span style=color:#60a0b0;font-style:italic></span>	<span style=color:#60a0b0;font-style:italic>// If they match, the caller is the one who can recover.
</span><span style=color:#60a0b0;font-style:italic></span>	gp <span style=color:#666>:=</span> <span style=color:#06287e>getg</span>()
	p <span style=color:#666>:=</span> gp._panic
	<span style=color:#007020;font-weight:700>if</span> p <span style=color:#666>!=</span> <span style=color:#007020;font-weight:700>nil</span> <span style=color:#666>&amp;&amp;</span> !p.recovered <span style=color:#666>&amp;&amp;</span> argp <span style=color:#666>==</span> <span style=color:#007020>uintptr</span>(p.argp) {
		p.recovered = <span style=color:#007020;font-weight:700>true</span>
		<span style=color:#007020;font-weight:700>return</span> p.arg
	}
	<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020;font-weight:700>nil</span>
}
</code></pre></div><blockquote><p>传入 <code>gorecover</code> 函数的 <code>argp</code> 是 <code>recover</code> 这个函数的调用者的地址。</p></blockquote><p>recover 主要做的事情就是检查当前 goroutine 中是否存在 panic，panic 是否已经被 recover，以及调用者是否一致。如果检查通过的话就修改 <code>p.recovered</code> 为 true，并返回 panic 创建时传入的参数，否则就直接返回 nil。</p><h2 id=解释>解释</h2><p>刚才简单分析了一下 defer && panic && recover 是如何工作的，下面可以利用刚才了解到的原理来解释我遇到的现象了：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#007020;font-weight:700>func</span> <span style=color:#06287e>TestRecoverInClosure</span>(t <span style=color:#666>*</span>testing.T) {
	<span style=color:#007020;font-weight:700>defer</span> <span style=color:#007020;font-weight:700>func</span>() {          <span style=color:#666>&lt;----</span> argp: <span style=color:#40a070>0x01</span>
		<span style=color:#60a0b0;font-style:italic>// This should be the callback function of a break point.
</span><span style=color:#60a0b0;font-style:italic></span>		<span style=color:#60a0b0;font-style:italic>// Let&#39;s call them directly for simpler example.
</span><span style=color:#60a0b0;font-style:italic></span>		<span style=color:#007020;font-weight:700>func</span>() {
			<span style=color:#007020>recover</span>()       <span style=color:#666>&lt;----</span> argp: <span style=color:#40a070>0x02</span>
		}()
	}()
	<span style=color:#007020>panic</span>(<span style=color:#4070a0>&#34;panic in test&#34;</span>)
}
</code></pre></div><ol><li>将这个 defer 函数加入 goroutine 的 <code>_defer</code> 列表</li><li>执行 panic，检查是否存在 defer 函数并执行</li><li>修改 <code>p.argp</code> 为 0x01，开始执行内部的匿名函数</li><li>recover 取到当前的调用者 argp 为 0x02，判断不通过，直接返回 nil</li><li>此时 <code>p.recovered</code> 仍然为 <code>false</code>，又没有更多的 defer 函数，进入 fatalpanic</li></ol><h2 id=困惑>困惑</h2><p>上面对照着分析可以大概解释明白为什么 TestRecoverInClosure 中的 panic 捕获不到，但是很多被忽略的细节还是没有搞明白。</p><h3 id=getargp>getargp</h3><p><code>getargp</code> 实现非常简单：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#60a0b0;font-style:italic>// getargp returns the location where the caller
</span><span style=color:#60a0b0;font-style:italic>// writes outgoing function call arguments.
</span><span style=color:#60a0b0;font-style:italic>//go:nosplit
</span><span style=color:#60a0b0;font-style:italic>//go:noinline
</span><span style=color:#60a0b0;font-style:italic></span><span style=color:#007020;font-weight:700>func</span> <span style=color:#06287e>getargp</span>(x <span style=color:#902000>int</span>) <span style=color:#902000>uintptr</span> {
	<span style=color:#60a0b0;font-style:italic>// x is an argument mainly so that we can return its address.
</span><span style=color:#60a0b0;font-style:italic></span>	<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>uintptr</span>(<span style=color:#06287e>noescape</span>(unsafe.<span style=color:#06287e>Pointer</span>(<span style=color:#666>&amp;</span>x)))
}
</code></pre></div><p>为什么这就是当前 defer 函数调用的参数指针呢？</p><h3 id=recover--gorecover>recover && gorecover</h3><p><code>recover</code> 是没有参数的，但是 <code>gorecover</code> 却有 argp 作为参数，跟下去可以看到这样的调用：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#06287e>mkcall</span>(<span style=color:#4070a0>&#34;gorecover&#34;</span>, n.Type, init, <span style=color:#06287e>nod</span>(OADDR, nodfp, <span style=color:#007020;font-weight:700>nil</span>))
</code></pre></div><p>所以是 <code>nod(OADDR, nodfp, nil)</code> 取到了调用者的地址么？</p><h2 id=总结>总结</h2><p>搞明白这个问题花费的时间比我想象的要更久，一方面是因为我对 go 内部的实现确实不太熟悉，另一方面是因为大多数的分享都集中在如何使用 或者最佳实践之类的，讨论内部实现的文章不是很多。我要特别的推荐一下 <a href=https://ieevee.com>@伊布</a> 的文章，他写的 <a href=https://ieevee.com/tech/2017/11/23/go-panic.html>Golang: 深入理解panic and recover</a> 非常赞，对 panic && recover 切换和恢复过程具体实现感兴趣的同学不妨一读，定会有所收获。</p><h2 id=参考资料>参考资料</h2><ul><li><a href=https://go101.org/article/panic-and-recover-more.html>The Right Places to Call the recover Function</a></li><li><a href=https://draveness.me/golang-function-call>理解 Golang 中函数调用的原理</a></li><li><a href=https://ieevee.com/tech/2017/11/23/go-panic.html>Golang: 深入理解panic and recover</a></li></ul></div><div id=gitalk-container><div class=gt-container><div class=gt-meta><span class=gt-counts>4 comments</span></div><div class=gt-header><a class=gt-avatar-github><span class="gt-avatar gt-comment-avatar"><img src=https://www.gravatar.com/avatar/></span></a><div class=gt-header-comment><form class=gt-header-form target=comment-iframe method=post action=https://gitqus.now.sh/v0/comments/github.com/Xuanwo/xuanwo.github.io/master><input type=hidden name=slug value=static/2019/05/25/go-panic/>
<input class=gt-header-input type=text name=name placeholder=Name required>
<input class=gt-header-input type=email name=email placeholder=Email required>
<textarea class=gt-header-textarea name=content placeholder="Leave a comment"></textarea><div class=gt-header-controls><button class=gt-btn><span class=gt-btn-text>Submit</span></button></div><iframe name=comment-iframe hidden id=frame></iframe></form></div></div><div class=gt-comments><div class="gt-comment gt-comment-admin"><div class="gt-avatar gt-comment-avatar"><img src=https://www.gravatar.com/avatar/></div><div class=gt-comment-content><div class=gt-comment-header><a class=gt-comment-username href=https://github.com/booxood>依云</a>
<span class=gt-comment-text>commented</span>
<span class=gt-comment-date>2019-05-25T15:27:01</span></div><div class="gt-comment-body markdown-body">Go 好复杂啊……<br>话说这种事情，为什么不看 spec 呢？虽然 spec 也说得不清不楚……</div></div></div><div class="gt-comment gt-comment-admin"><div class="gt-avatar gt-comment-avatar"><img src=https://www.gravatar.com/avatar/></div><div class=gt-comment-content><div class=gt-comment-header><a class=gt-comment-username href=https://github.com/booxood>依云</a>
<span class=gt-comment-text>commented</span>
<span class=gt-comment-date>2019-05-25T15:32:00</span></div><div class="gt-comment-body markdown-body"><p>突然觉得还是 Python 简单～</p><p><a href=https://img.vim-cn.com/7c/baf6e5799095ef6e19e1d693ac8c3feb3e06f8.png title=https://img.vim-cn.com/7c/baf6e5799095ef6e19e1d693ac8c3feb3e06f8.png>https://img.vim-cn.com/7c/b&mldr;</a></p></div></div></div><div class="gt-comment gt-comment-admin"><div class="gt-avatar gt-comment-avatar"><img src=https://www.gravatar.com/avatar/></div><div class=gt-comment-content><div class=gt-comment-header><a class=gt-comment-username href=https://github.com/booxood>漩涡</a>
<span class=gt-comment-text>commented</span>
<span class=gt-comment-date>2019-05-25T15:47:04</span></div><div class="gt-comment-body markdown-body">因为 spec 也没说清楚？。。</div></div></div><div class="gt-comment gt-comment-admin"><div class="gt-avatar gt-comment-avatar"><img src=https://www.gravatar.com/avatar/></div><div class=gt-comment-content><div class=gt-comment-header><a class=gt-comment-username href=https://github.com/booxood>漩涡</a>
<span class=gt-comment-text>commented</span>
<span class=gt-comment-date>2019-05-25T15:47:19</span></div><div class="gt-comment-body markdown-body">emmmm，涨姿势了，你这里贴的我有好多都不知道</div></div></div></div></div></div></article></main><footer class="footer container"><a class=main-nav-link href=/categories/>Categories</a>
<a class=main-nav-link href=/tags/>Tags</a>
<a class=main-nav-link href=/series/>Series</a>
<a class=main-nav-link href=/blogroll/>Blogroll</a>
<a class=main-nav-link href=/index.xml>Subscribe</a>
<script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-51515330-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></footer></body></html>