<!doctype html><html><head><title>Jenkins Pipeline 介绍</title><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="A blog maintained by an interesting programmer."><meta name=keywords content="Technology,Code,Program,Linux,"><meta name=author content="Xuanwo"><meta property="og:title" content="Jenkins Pipeline 介绍"><meta property="og:description" content="A blog maintained by an interesting programmer."><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://xuanwo.io/2019/08/30/jenkins-pipeline-intro/"><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=https://xuanwo.io/css/main.min.5a9ffcf343273240b691845bba645faa19f2008c05742711b684042a3063818b.css integrity="sha256-Wp/880MnMkC2kYRbumRfqhnyAIwFdCcRtoQEKjBjgYs="><script data-ad-client=ca-pub-8380875817494486 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><link href=http://gmpg.org/xfn/11 rel=profile><meta name=generator content="Hugo 0.68.3"></head><body><nav class=nav><div class=nav-container><div class=brand><a href=https://xuanwo.io>Xuanwo's Blog</a></div><div class=links><a class=main-nav-link href=/about/>About</a>
<a class=main-nav-link href=/posts/>Posts</a></div></div></nav><main id=main-content><article class="single container"><header class=single-header><div class=flex><h1>Jenkins Pipeline 介绍</h1><div class=post-meta><time class=date datetime=2019-08-30T01:00:00.000+00:00 itemprop=datePublished>2019-08-30</time></div><div class=tag-container><a style=text-decoration:none href=https://xuanwo.io/tags/jenkins><span>Jenkins</span></a>
<a style=text-decoration:none href=https://xuanwo.io/tags/groovy><span>Groovy</span></a></div></div></header><div class=post><blockquote><p>This post is the 4 / 5 post in
<a href=https://xuanwo.io/series/engineering-efficiency>Engineering Efficiency</a> Series.</p></blockquote><p>前一段时间推动整个 Team 都转向了 Go Modules，最近一段时间的工作主要是在推动自动化构建与测试。我们最后选定的方案是 <code>Jenkins</code> + <code>Multibranch Pipelines</code>，本文将会简单介绍一下 Jenkins Pipeline 以及常用的技巧。</p><h2 id=pipeline-是什么>Pipeline 是什么</h2><p>Jenkins Pipeline 实际上是基于 Groovy 实现的 CI/CD 领域特定语言（DSL），主要分为两类，一类叫做 <code>Declarative Pipeline</code>，一类叫做 <code>Scripted Pipeline</code>。</p><p><code>Declarative Pipeline</code> 体验上更接近于我们熟知的 <code>travis CI</code> 的 <code>travis.yml</code>，通过声明自己要做的事情来规范流程，形如：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy>pipeline <span style=color:#666>{</span>
    agent any
    stages <span style=color:#666>{</span>
        stage<span style=color:#666>(</span><span style=color:#4070a0>&#39;Build&#39;</span><span style=color:#666>)</span> <span style=color:#666>{</span>
            steps <span style=color:#666>{</span>
                <span style=color:#60a0b0;font-style:italic>//
</span><span style=color:#60a0b0;font-style:italic></span>            <span style=color:#666>}</span>
        <span style=color:#666>}</span>
        stage<span style=color:#666>(</span><span style=color:#4070a0>&#39;Test&#39;</span><span style=color:#666>)</span> <span style=color:#666>{</span>
            steps <span style=color:#666>{</span>
                <span style=color:#60a0b0;font-style:italic>//
</span><span style=color:#60a0b0;font-style:italic></span>            <span style=color:#666>}</span>
        <span style=color:#666>}</span>
        stage<span style=color:#666>(</span><span style=color:#4070a0>&#39;Deploy&#39;</span><span style=color:#666>)</span> <span style=color:#666>{</span>
            steps <span style=color:#666>{</span>
                <span style=color:#60a0b0;font-style:italic>//
</span><span style=color:#60a0b0;font-style:italic></span>            <span style=color:#666>}</span>
        <span style=color:#666>}</span>
    <span style=color:#666>}</span>
<span style=color:#666>}</span>
</code></pre></div><p>而 <code>Scripted Pipeline</code> 则是旧版本中 Jenkins 支持的 Pipeline 模式，主要是写一些 groovy 的代码来制定流程：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy>node <span style=color:#666>{</span>  
    stage<span style=color:#666>(</span><span style=color:#4070a0>&#39;Build&#39;</span><span style=color:#666>)</span> <span style=color:#666>{</span>
        <span style=color:#60a0b0;font-style:italic>//
</span><span style=color:#60a0b0;font-style:italic></span>    <span style=color:#666>}</span>
    stage<span style=color:#666>(</span><span style=color:#4070a0>&#39;Test&#39;</span><span style=color:#666>)</span> <span style=color:#666>{</span>
        <span style=color:#60a0b0;font-style:italic>//
</span><span style=color:#60a0b0;font-style:italic></span>    <span style=color:#666>}</span>
    stage<span style=color:#666>(</span><span style=color:#4070a0>&#39;Deploy&#39;</span><span style=color:#666>)</span> <span style=color:#666>{</span>
        <span style=color:#60a0b0;font-style:italic>//
</span><span style=color:#60a0b0;font-style:italic></span>    <span style=color:#666>}</span>
<span style=color:#666>}</span>
</code></pre></div><p>一般情况下声明式的流水线已经可以满足我们的需要，只有在复杂的情况下才会需要脚本式流水线的参与。</p><p>过去大家经常在 Jenkins 的界面上直接写脚本来实现自动化，但是现在更鼓励大家通过在项目中增加 <code>Jenkinsfile</code> 的方式把流水线固定下来，实现 <code>Pipeline As Code</code>，Jenkins 的 Pipeline 插件将会自动发现并执行它。</p><h2 id=语法>语法</h2><p><code>Declarative Pipeline</code> 最外层有个 <code>pipeline</code> 表明它是一个声明式流水线，下面会有 4 个主要的部分：
<code>agent</code>，<code>post</code>，<code>stages</code>，<code>steps</code>，我会逐一介绍一下。</p><h3 id=agent>Agent</h3><p><code>agent</code> 主要用于描述整个 Pipeline 或者指定的 Stage 由什么规则来选择节点执行。Pipeline 级别的 agent 可以视为 Stage 级别的默认值，如果 stage 中没有指定，将会使用与 Pipeline 一致的规则。在最新的 Jenkins 版本中，可以支持指定任意节点(<code>any</code>)，不指定(<code>none</code>)，标签(<code>label</code>)，节点(<code>node</code>)，<code>docker</code>，<code>dockerfile</code> 和 <code>kubernetes</code> 等，具体的配置细节可以查看文档，下面是一个使用 docker 的样例：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy>agent <span style=color:#666>{</span>
    docker <span style=color:#666>{</span>
        image <span style=color:#4070a0>&#39;myregistry.com/node&#39;</span>
        label <span style=color:#4070a0>&#39;my-defined-label&#39;</span>
        registryUrl <span style=color:#4070a0>&#39;https://myregistry.com/&#39;</span>
        registryCredentialsId <span style=color:#4070a0>&#39;myPredefinedCredentialsInJenkins&#39;</span>
        args <span style=color:#4070a0>&#39;-v /tmp:/tmp&#39;</span>
    <span style=color:#666>}</span>
<span style=color:#666>}</span>
</code></pre></div><p>Tips:</p><ul><li>如果 Pipeline 选择了 none，那么 stage 必须要指定一个有效的 agent，否则无法执行</li><li>Jenkins 总是会使用 master 来执行 scan multibranch 之类的操作，即使 master 配置了 0 executors</li><li>agent 指定的是规则而不是具体的节点，如果 stage 各自配置了自己的 agent，需要注意是不是在同一个节点执行的</li></ul><h3 id=stages--stage>Stages && Stage</h3><p>Stages 是 Pipeline 中最主要的组成部分，Jenkins 将会按照 Stages 中描述的顺序从上往下的执行。Stages 中可以包括任意多个 Stage，而 Stage 与 Stages 又能互相嵌套，除此以外还有 <code>parallel</code> 指令可以让内部的 Stage 并行运行。实际上可以把 Stage 当作最小单元，Stages 指定的是顺序运行，而 parallel 指定的是并行运行。</p><p>接下来的这个 case 很好的说明了这一点：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy>pipeline <span style=color:#666>{</span>
    agent none
    stages <span style=color:#666>{</span>
        stage<span style=color:#666>(</span><span style=color:#4070a0>&#39;Sequential&#39;</span><span style=color:#666>)</span> <span style=color:#666>{</span>
            stages <span style=color:#666>{</span>
                stage<span style=color:#666>(</span><span style=color:#4070a0>&#39;In Sequential 1&#39;</span><span style=color:#666>)</span> <span style=color:#666>{</span>
                    steps <span style=color:#666>{</span>
                        echo <span style=color:#4070a0>&#34;In Sequential 1&#34;</span>
                    <span style=color:#666>}</span>
                <span style=color:#666>}</span>
                stage<span style=color:#666>(</span><span style=color:#4070a0>&#39;In Sequential 2&#39;</span><span style=color:#666>)</span> <span style=color:#666>{</span>
                    steps <span style=color:#666>{</span>
                        echo <span style=color:#4070a0>&#34;In Sequential 2&#34;</span>
                    <span style=color:#666>}</span>
                <span style=color:#666>}</span>
                stage<span style=color:#666>(</span><span style=color:#4070a0>&#39;Parallel In Sequential&#39;</span><span style=color:#666>)</span> <span style=color:#666>{</span>
                    parallel <span style=color:#666>{</span>
                        stage<span style=color:#666>(</span><span style=color:#4070a0>&#39;In Parallel 1&#39;</span><span style=color:#666>)</span> <span style=color:#666>{</span>
                            steps <span style=color:#666>{</span>
                                echo <span style=color:#4070a0>&#34;In Parallel 1&#34;</span>
                            <span style=color:#666>}</span>
                        <span style=color:#666>}</span>
                        stage<span style=color:#666>(</span><span style=color:#4070a0>&#39;In Parallel 2&#39;</span><span style=color:#666>)</span> <span style=color:#666>{</span>
                            steps <span style=color:#666>{</span>
                                echo <span style=color:#4070a0>&#34;In Parallel 2&#34;</span>
                            <span style=color:#666>}</span>
                        <span style=color:#666>}</span>
                    <span style=color:#666>}</span>
                <span style=color:#666>}</span>
            <span style=color:#666>}</span>
        <span style=color:#666>}</span>
    <span style=color:#666>}</span>
<span style=color:#666>}</span>
</code></pre></div><p>除了指定 Stage 之间的顺序关系之外，我们还可以通过 <code>when</code> 来指定某个 Stage 指定与否：比如要配置只有在 Master 分支上才执行 push，其他分支上都只运行 build</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy>stages <span style=color:#666>{</span>
  stage<span style=color:#666>(</span><span style=color:#4070a0>&#39;Build&#39;</span><span style=color:#666>)</span> <span style=color:#666>{</span>
    when <span style=color:#666>{</span>
      not <span style=color:#666>{</span> branch <span style=color:#4070a0>&#39;master&#39;</span> <span style=color:#666>}</span>
    <span style=color:#666>}</span>
    steps <span style=color:#666>{</span>
      sh <span style=color:#4070a0>&#39;./scripts/run.py build&#39;</span>
    <span style=color:#666>}</span>
  <span style=color:#666>}</span>
  stage<span style=color:#666>(</span><span style=color:#4070a0>&#39;Run&#39;</span><span style=color:#666>)</span> <span style=color:#666>{</span>
    when <span style=color:#666>{</span>
      branch <span style=color:#4070a0>&#39;master&#39;</span>
    <span style=color:#666>}</span>
    steps <span style=color:#666>{</span>
      sh <span style=color:#4070a0>&#39;./scripts/run.py push&#39;</span>
    <span style=color:#666>}</span>
  <span style=color:#666>}</span>
<span style=color:#666>}</span>
</code></pre></div><p>还能在 Stage 的级别设置 <code>environment</code>，这些就不展开了，文档里有更详细的描述。</p><h3 id=steps>Steps</h3><p><code>steps</code> 是 Pipeline 中最核心的部分，每个 Stage 都需要指定 Steps。Steps 内部可以执行一系列的操作，任意操作执行出错都会返回错误。完整的 Steps 操作列表可以参考 <a href=https://jenkins.io/doc/pipeline/steps/>Pipeline Steps Reference</a>，这里只说一些使用时需要注意的点。</p><ul><li>groovy 语法中有不同的字符串类型，其中 <code>'abc'</code> 是 Plain 字符串，不会转义 <code>${WROKSPACE}</code> 这样的变量，而 <code>"abc"</code> 会做这样的转换。此外还有 <code>''' xxx '''</code> 支持跨行字符串，<code>"""</code> 同理。</li><li>调用函数的 <code>()</code> 可以省略，使得函数调用形如 <code>updateGitlabCommitStatus name: 'build', state: 'success'</code>，通过 <code>,</code> 来分割不同的参数，支持换行。</li><li>可以在声明式流水线中通过 <code>script</code> 来插入一段 groovy 脚本</li></ul><h3 id=post>Post</h3><p><code>post</code> 部分将会在 pipeline 的最后执行，经常用于一些测试完毕后的清理和通知操作。文档中给出了一系列的情况，比较常用的是 <code>always</code>，<code>success</code> 和 <code>failure</code>。</p><p>比如说下面的脚本将会在成功和失败的时候更新 gitlab 的状态，在失败的时候发送通知邮件：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy>post <span style=color:#666>{</span>
  failure <span style=color:#666>{</span>
    updateGitlabCommitStatus <span style=color:#002070;font-weight:700>name:</span> <span style=color:#4070a0>&#39;build&#39;</span><span style=color:#666>,</span> <span style=color:#002070;font-weight:700>state:</span> <span style=color:#4070a0>&#39;failed&#39;</span>
    emailext <span style=color:#002070;font-weight:700>body:</span> <span style=color:#4070a0>&#39;$DEFAULT_CONTENT&#39;</span><span style=color:#666>,</span> <span style=color:#002070;font-weight:700>recipientProviders:</span> <span style=color:#666>[</span>culprits<span style=color:#666>()],</span> <span style=color:#002070;font-weight:700>subject:</span> <span style=color:#4070a0>&#39;$DEFAULT_SUBJECT&#39;</span>
  <span style=color:#666>}</span>
  success <span style=color:#666>{</span>
    updateGitlabCommitStatus <span style=color:#002070;font-weight:700>name:</span> <span style=color:#4070a0>&#39;build&#39;</span><span style=color:#666>,</span> <span style=color:#002070;font-weight:700>state:</span> <span style=color:#4070a0>&#39;success&#39;</span>
  <span style=color:#666>}</span>
<span style=color:#666>}</span>
</code></pre></div><p>每个状态其实都相当于于一个 <code>steps</code>，都能够执行一系列的操作，不同状态的执行顺序是事先规定好的，就是文档中列出的顺序。</p><h2 id=shared-libraries>Shared Libraries</h2><p>同一个 Team 产出的不同项目往往会有着相似的流程，比如 golang 的大部分项目都会执行同样的命令。这就导致了人们经常需要在不同的项目间复制同样的流程，而 Shared Libraries 就解决了这个问题。通过在 Pipeline 中引入共享库，把常用的流程抽象出来变成一个的指令，简化了大量重复的操作。</p><p>在配置好 lib 之后，Jenkins 会在每个 Pipeline 启动前去检查 lib 是否更新并 pull 到本地，根据配置决定是否直接加载。</p><p>所有的 Shared Libraries 都要遵循相同的项目结构：</p><pre><code>(root)
+- src                     # Groovy source files
|   +- org
|       +- foo
|           +- Bar.groovy  # for org.foo.Bar class
+- vars
|   +- foo.groovy          # for global 'foo' variable
|   +- foo.txt             # help for 'foo' variable
+- resources               # resource files (external libraries only)
|   +- org
|       +- foo
|           +- bar.json    # static helper data for org.foo.Bar
</code></pre><p>目前我们的使用比较低级，所以只用到了 <code>vars</code> 来存储全局的变量。</p><p>vars 下的每一个 <code>foo.groovy</code> 文件都是一个独立的 namespace，在 Pipeline 中可以以 <code>foo.XXX</code> 的形式来导入。比如我们有 <code>vars/log.groovy</code>：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy><span style=color:#902000>def</span> <span style=color:#06287e>info</span><span style=color:#666>(</span>message<span style=color:#666>)</span> <span style=color:#666>{</span>
    echo <span style=color:#4070a0>&#34;INFO: ${message}&#34;</span>
<span style=color:#666>}</span>

<span style=color:#902000>def</span> <span style=color:#06287e>warning</span><span style=color:#666>(</span>message<span style=color:#666>)</span> <span style=color:#666>{</span>
    echo <span style=color:#4070a0>&#34;WARNING: ${message}&#34;</span>
<span style=color:#666>}</span>
</code></pre></div><p>那么 Jenkinsfile 中就可以这样调用：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy><span style=color:#60a0b0;font-style:italic>// Jenkinsfile
</span><span style=color:#60a0b0;font-style:italic></span>steps <span style=color:#666>{</span>
  log<span style=color:#666>.</span><span style=color:#4070a0>info</span> <span style=color:#4070a0>&#39;Starting&#39;</span>
  log<span style=color:#666>.</span><span style=color:#4070a0>warning</span> <span style=color:#4070a0>&#39;Nothing to do!&#39;</span>
<span style=color:#666>}</span>
</code></pre></div><p>大家可能已经注意到了，在 <code>groovy</code> 文件中，我们可以直接像在 <code>steps</code> 中一样调用已有的方法，比如 <code>echo</code> 和 <code>sh</code> 等。</p><p>我们也能在 <code>groovy</code> 文件中去引用 Java 的库并返回一个变量，比如：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy><span style=color:#007020>#!/usr/bin/env groovy</span>
<span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>java.util.Random</span><span style=color:#666>;</span>

<span style=color:#902000>def</span> String <span style=color:#06287e>name</span><span style=color:#666>()</span> <span style=color:#666>{</span>
  <span style=color:#902000>def</span> rand <span style=color:#666>=</span> <span style=color:#007020;font-weight:700>new</span> Random<span style=color:#666>()</span>
  <span style=color:#902000>def</span> t <span style=color:#666>=</span> rand<span style=color:#666>.</span><span style=color:#4070a0>nextInt</span><span style=color:#666>(</span><span style=color:#40a070>1000</span><span style=color:#666>)</span>
  <span style=color:#007020;font-weight:700>return</span> String<span style=color:#666>.</span><span style=color:#4070a0>valueOf</span><span style=color:#666>(</span>t<span style=color:#666>)</span>
<span style=color:#666>}</span>
</code></pre></div><p>这样就能够在 <code>JenkinsFile</code> 中去设置一个环境变量：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy><span style=color:#60a0b0;font-style:italic>// Jenkinsfile
</span><span style=color:#60a0b0;font-style:italic></span>environment <span style=color:#666>{</span>
  NAME <span style=color:#666>=</span> random<span style=color:#666>.</span><span style=color:#4070a0>name</span><span style=color:#666>()</span>
<span style=color:#666>}</span>
</code></pre></div><p>除了定义方法之外，我们还能让这个文件本身就能被调用，只需要定义一个 call 方法：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy><span style=color:#007020>#!/usr/bin/env groovy</span>

<span style=color:#902000>def</span> <span style=color:#06287e>call</span><span style=color:#666>()</span> <span style=color:#666>{</span>
  sh <span style=color:#4070a0>&#34;hello, world&#34;</span>
<span style=color:#666>}</span>
</code></pre></div><p>还能够定义一个新的 section，接受一个 Block：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy><span style=color:#902000>def</span> <span style=color:#06287e>call</span><span style=color:#666>(</span>Closure body<span style=color:#666>)</span> <span style=color:#666>{</span>
    node<span style=color:#666>(</span><span style=color:#4070a0>&#39;windows&#39;</span><span style=color:#666>)</span> <span style=color:#666>{</span>
        body<span style=color:#666>()</span>
    <span style=color:#666>}</span>
<span style=color:#666>}</span>
</code></pre></div><p>这样可以让指定的 Body 在 windows 节点上调用：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy><span style=color:#60a0b0;font-style:italic>// Jenkinsfile
</span><span style=color:#60a0b0;font-style:italic></span>windows <span style=color:#666>{</span>
    bat <span style=color:#4070a0>&#34;cmd /?&#34;</span>
<span style=color:#666>}</span>
</code></pre></div><h2 id=常用技巧>常用技巧</h2><h3 id=发送邮件通知>发送邮件通知</h3><p>主要使用 <code>emailext</code>，需要在 Jenkins 的配置界面事先配置好，可用的环境变量和参数可以参考文档 <a href=https://wiki.jenkins.io/display/JENKINS/Email-ext+plugin#Email-extplugin-Globalconfiguration>Email-ext plugin</a></p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy>emailext <span style=color:#002070;font-weight:700>body:</span> <span style=color:#4070a0>&#39;$DEFAULT_CONTENT&#39;</span><span style=color:#666>,</span>  <span style=color:#002070;font-weight:700>recipientProviders:</span> <span style=color:#666>[</span>culprits<span style=color:#666>(),</span>developers<span style=color:#666>()],</span> <span style=color:#002070;font-weight:700>subject:</span> <span style=color:#4070a0>&#39;$DEFAULT_SUBJECT&#39;</span>
</code></pre></div><h3 id=结果同步到-gitlab>结果同步到 gitlab</h3><p>同样需要配置好 gitlab 插件，在 Pipeline 中指定 <code>options</code>：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy><span style=color:#60a0b0;font-style:italic>// Jenkisfile
</span><span style=color:#60a0b0;font-style:italic></span>options <span style=color:#666>{</span>
  gitLabConnection<span style=color:#666>(</span><span style=color:#4070a0>&#39;gitlab&#39;</span><span style=color:#666>)</span>
<span style=color:#666>}</span>
</code></pre></div><p>然后就可以在 post 中根据不同的状态来更新 gitlab 了：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy><span style=color:#60a0b0;font-style:italic>// Jenkisfile
</span><span style=color:#60a0b0;font-style:italic></span>failure <span style=color:#666>{</span>
  updateGitlabCommitStatus <span style=color:#002070;font-weight:700>name:</span> <span style=color:#4070a0>&#39;build&#39;</span><span style=color:#666>,</span> <span style=color:#002070;font-weight:700>state:</span> <span style=color:#4070a0>&#39;failed&#39;</span>
<span style=color:#666>}</span>
success <span style=color:#666>{</span>
  updateGitlabCommitStatus <span style=color:#002070;font-weight:700>name:</span> <span style=color:#4070a0>&#39;build&#39;</span><span style=color:#666>,</span> <span style=color:#002070;font-weight:700>state:</span> <span style=color:#4070a0>&#39;success&#39;</span>
<span style=color:#666>}</span>
</code></pre></div><p>文档参考：<a href=https://github.com/jenkinsci/gitlab-plugin#build-status-configuration>Build status configuration</a></p><h3 id=构建过程中可用的环境变量列表>构建过程中可用的环境变量列表</h3><p>Jenkins 会提供一个完整的列表，只需要访问 <code>&lt;your-jenkins-url>/env-vars.html/</code> 即可，别忘了需要使用 <code>"${WORKSPACE}"</code></p><h3 id=在-checkout-前执行自定义操作>在 checkout 前执行自定义操作</h3><p>在 Multibranch Pipeline 的默认流程中会在 checkout 之前和之后执行 <code>git clean -fdx</code>，如果在测试中以 root 权限创建了文件，那么 jenkins 会因为这个命令执行失败而报错。所以我们需要在 checkout 之前执行自定义的任务：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy><span style=color:#007020>#!/usr/bin/env groovy</span>

<span style=color:#60a0b0;font-style:italic>// var/pre.groovy
</span><span style=color:#60a0b0;font-style:italic></span><span style=color:#902000>def</span> <span style=color:#06287e>call</span><span style=color:#666>(</span>Closure body<span style=color:#666>)</span> <span style=color:#666>{</span>
  body<span style=color:#666>()</span>
  checkout scm
<span style=color:#666>}</span>
</code></pre></div><p>在 Jenkinsfile 中配置以跳过默认的 checkout 行为：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy><span style=color:#60a0b0;font-style:italic>// Jenkisfile
</span><span style=color:#60a0b0;font-style:italic></span>options <span style=color:#666>{</span>
  skipDefaultCheckout <span style=color:#007020;font-weight:700>true</span>
<span style=color:#666>}</span>
</code></pre></div><p>在每个 stage 中执行自定义的任务即可：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy><span style=color:#60a0b0;font-style:italic>// Jenkisfile
</span><span style=color:#60a0b0;font-style:italic></span>stage<span style=color:#666>(</span><span style=color:#4070a0>&#39;Compile&#39;</span><span style=color:#666>)</span> <span style=color:#666>{</span>
  agent any
  steps <span style=color:#666>{</span>
    pre <span style=color:#666>{</span>
      sh <span style=color:#4070a0>&#39;pre compile&#39;</span>
    <span style=color:#666>}</span>
    sh <span style=color:#4070a0>&#39;real compile&#39;</span>
  <span style=color:#666>}</span>
<span style=color:#666>}</span>
</code></pre></div><h2 id=总结>总结</h2><p>Jenkins 作为使用最为广泛的 CI/CD 平台，网上流传着无数的脚本和攻略，在学习和开发的时候一定要从基本出发，了解内部原理，多看官方的文档，不要拿到一段代码就开始用，这样才能不会迷失在各式各样的脚本之中。</p><p>更重要的是要结合自己的业务需求，开发和定制属于自己的流程，不要被 Jenkins 的框架限制住。比如我们是否可以定义一个自己的 YAML 配置文件，然后根据 YAML 来生成 Pipeline，不需要业务自己写 Pipeline 脚本，规范使用，提前检查不合法的脚本，核心的模块共同升级，避免了一个流程小改动需要所有项目组同步更新。这是我现在正在做的事情，有机会再跟大家分享～</p><h2 id=参考资料>参考资料</h2><ul><li><a href=https://jenkins.io/doc/book/pipeline/syntax/>Pipeline Syntax</a></li><li><a href=https://groovy-lang.org/syntax.html>Groovy Syntax</a></li><li><a href=https://jenkins.io/doc/book/pipeline/shared-libraries/>Extending with Shared Libraries</a></li></ul></div><div id=gitalk-container><div class=gt-container><div class=gt-meta><span class=gt-counts>1 comments</span></div><div class=gt-header><a class=gt-avatar-github><span class="gt-avatar gt-comment-avatar"><img src=https://www.gravatar.com/avatar/></span></a><div class=gt-header-comment><form class=gt-header-form target=comment-iframe method=post action=https://gitqus.now.sh/v0/comments/github.com/Xuanwo/xuanwo.github.io/master><input type=hidden name=slug value=/2019/08/30/jenkins-pipeline-intro/>
<input class=gt-header-input type=text name=name placeholder=Name required>
<input class=gt-header-input type=email name=email placeholder=Email required>
<textarea class=gt-header-textarea name=content placeholder="Leave a comment"></textarea><div class=gt-header-controls><button class=gt-btn><span class=gt-btn-text>Submit</span></button></div><iframe name=comment-iframe hidden id=frame></iframe></form></div></div><div class=gt-comments><div class="gt-comment gt-comment-admin"><div class="gt-avatar gt-comment-avatar"><img src=https://www.gravatar.com/avatar/></div><div class=gt-comment-content><div class=gt-comment-header><a class=gt-comment-username href=https://github.com/booxood>a-wing</a>
<span class=gt-comment-text>commented</span>
<span class=gt-comment-date>2019-09-09T07:15:43</span></div><div class="gt-comment-body markdown-body">我还是觉得 gitlab-ci 更好用（</div></div></div></div></div></div></article></main><footer class="footer container"><a class=main-nav-link href=/categories/>Categories</a>
<a class=main-nav-link href=/tags/>Tags</a>
<a class=main-nav-link href=/series/>Series</a>
<a class=main-nav-link href=/blogroll/>Blogroll</a>
<a class=main-nav-link href=/index.xml>Subscribe</a>
<script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-51515330-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></footer></body></html>