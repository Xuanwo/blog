<!doctype html><html><head><title>有趣的网页乱码问题</title><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="A blog maintained by an interesting programmer."><meta name=keywords content="Technology,Code,Program,Linux,"><meta name=author content="Xuanwo"><meta property="og:title" content="有趣的网页乱码问题"><meta property="og:description" content="A blog maintained by an interesting programmer."><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://xuanwo.io/2016/11/22/garbled-page/"><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=https://xuanwo.io/css/main.min.a285da0837b674a21742d9d9056c807cf8074d0e7b0cd2e85d30ed1ddf2acddd.css integrity="sha256-ooXaCDe2dKIXQtnZBWyAfPgHTQ57DNLoXTDtHd8qzd0="><script data-ad-client=ca-pub-8380875817494486 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><link href=http://gmpg.org/xfn/11 rel=profile><meta name=generator content="Hugo 0.61.0"></head><body><nav class=nav><div class=nav-container><div class=brand><a href=https://xuanwo.io>Xuanwo's Blog</a></div><div class=links><a class=main-nav-link href=/about/>关于我</a>
<a class=main-nav-link href=/posts/>文章</a></div></div></nav><main id=main-content><article class="single container"><header class=single-header><div class=flex><h1>有趣的网页乱码问题</h1><div class=post-meta><time class=date datetime=2016-11-22T00:00:00.000+00:00 itemprop=datePublished>2016-11-22</time>
/
<span><a href=#disqus_thread class=comment-link>Comments</a></span></div><div class=tag-container><a style=text-decoration:none href=https://xuanwo.io/tags/web><span>Web</span></a></div></div></header><div class=post><p>这是来自segmentfault的一个问题：<a href=https://segmentfault.com/q/1010000007540588>node.js中抓取utf-8编码的网页为什么也是乱码</a>，解答完这个问题之后，决定探讨一下网页乱码这个问题。</p><p>网页乱码之所以产生，是因为我们处理数据的方式与期待的方式不一致。比如说：</p><ul><li>文本编码不一致</li><li>数据编码不一致</li></ul><p>下面分别来介绍一下这两种情况：</p><h2 id=heading>文本编码不一致</h2><p>这个问题比较常见，常常发生在一些比较老的网站上，采用<code>gbk</code>或者<code>gb2312</code>编码，但是大多数语言都是默认使用<code>utf-8</code>进行解释，这时就会导致乱码。</p><p>这种情况解决起来比较容易，只需要使用恰当的编码去解释即可。一个比较稳妥的方案是通过<code>Response Headers</code>中的<code>Content-Type</code>去获取内容的<code>charset</code>。当然，服务器端的开发者首先需要尽可能的遵循规范，统一使用<code>utf-8</code>编码，其次，就算是采用比较特别的编码，也需要在HTML或者headers中显式指定出来，不要让用户来猜测你的编码类型。</p><p>最坑爹的一种情况是明明是使用<code>gbk</code>编码的，却标注为<code>utf-8</code>，这种坑爹的网站建议不要再使用他们的服务了，迟早要完。</p><h2 id=heading-1>数据编码不一致</h2><p>数据是文本更为底层的表示，如果数据编解码不正确，那么文本肯定无法正常显示。这里来讲一讲我们遇到的这个问题。</p><h3 id=heading-2>问题介绍</h3><p>请求的页面是一个纯的静态页面： <a href=http://www.runoob.com/nodejs/nodejs-tutorial.html>http://www.runoob.com/nodejs/nodejs-tutorial.html</a> ，题主使用了这样的代码来进行抓取：</p><pre><code class=language-nodejs data-lang=nodejs>var http=require(&quot;http&quot;);
var go=require(&quot;iconv-lite&quot;)
http.get(&quot;http://www.runoob.com/nodejs/nodejs-tutorial.html&quot;,function(res){
    var html=&quot;&quot;;
    res.on(&quot;data&quot;,function(data){
       /* html +=go.decode(data,&quot;gb2312&quot;);*/
        html+=data;
    })
    res.on(&quot;end&quot;,function(){
        console.log(html);
    }).on(&quot;error&quot;,function(){
        console.log(&quot;获取失败&quot;)
    })
})
</code></pre><p>主要进行了两种尝试，第一种是直接拼接后抓取，第二种是使用了<code>iconv-lite</code>进行了网页编码的转换。
实际上，这个网页在<code>&lt;head></code>部分已经注明：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#062873;font-weight:700>meta</span> <span style=color:#4070a0>http-equiv</span><span style=color:#666>=</span><span style=color:#4070a0>&#34;Content-Type&#34;</span> <span style=color:#4070a0>content</span><span style=color:#666>=</span><span style=color:#4070a0>&#34;text/html; charset=UTF-8&#34;</span> /&gt;
</code></pre></div><p>其实这也是题主困惑的地方，明明编码使用的<code>utf-8</code>，为什么得不到正确的结果？</p><h3 id=heading-3>问题分析</h3><p>问题出在<code>Response</code>的数据编码上，可以通过浏览器查看到<code>Response Headers</code>：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>Connection:keep-alive
Content-Encoding:gzip
Content-Length:11902
Content-Type:text/html; charset=utf-8
Date:Mon, 21 Nov 2016 23:53:49 GMT
Server:Tengine
</code></pre></div><p>可以看到这样一行：<code>Content-Encoding:gzip</code>，当前网页已经使用<code>gzip</code>进行了加密。就好比说别人发给你一个rar的压缩包，但是你直接当成<code>utf-8</code>的文本文件进行解码，当然得不到正确的结果。想要得到正确的结果的话，需要先脱鞋子再脱袜子（先解压缩再进行文本编码）：</p><pre><code class=language-nodejs data-lang=nodejs>var http = require(&quot;http&quot;);
var zlib = require('zlib');

http.get(&quot;http://www.runoob.com/nodejs/nodejs-tutorial.html&quot;, function(res) {
    var html = [];
    res.on(&quot;data&quot;, function(data) {
        html.push(data);
    })
    res.on(&quot;end&quot;, function() {
        var buffer = Buffer.concat(html);
        zlib.gunzip(buffer, function(err, decoded) {
            console.log(decoded.toString());
        })
    }).on(&quot;error&quot;, function() {
        console.log(&quot;获取失败&quot;)
    })
})
</code></pre><p>实际上大多数现代语言内部的字符串都使用了<code>utf-8</code>编码，所以此处解压缩之后就可以得到自己想要的结果。</p><h3 id=heading-4>问题深入</h3><p>其实题主的代码中隐藏着这样的一个问题：</p><p>他认为得到数据已经是文本类型了，所以直接使用<code>html+=data;</code>这种方式来进行拼接。但实际上，服务器端传递过来的数据是二进制数据，对分块后的二进制数据进行拼接或者是编解码操作，可能会导致最后生成的字符串出现截断。所以正确的方式应该是使用内置的<code>Buffer</code>类型进行操作。</p><p>后来题主通过私信问了我这样一个问题：</p><blockquote><p>为什么网页上都有Content-Encoding:gzip，有的需要解压gzip，而有的不需要？</p></blockquote><p>我认为要看服务器端是怎么实现的，很多服务器会先检测<code>Request Headers</code>中的<code>Accept-Encoding</code>，然后再决定发送什么样的数据。<code>runoob.com</code>这个网站很有可能就是没有做这样的处理，统一返回的gzip之后的页面。</p><h3 id=heading-5>问题解决</h3><p>这个问题已经解决了，下面需要考虑的是怎么样去避免这个问题。</p><p>从客户端开发者的角度来看，如果不能确定访问的网页的数据类型，需要自己做一下判断：</p><pre><code class=language-nodejs data-lang=nodejs>var contentEncoding = res.headers[&quot;content-encoding&quot;];
...
if (contentEncoding === &quot;gzip&quot;) {
    xxxxx;
} else if (contentEncoding === &quot;deflate&quot;) {
    xxxxx;
} else {

}
</code></pre><p>从服务器端开发者的角度来看，不能假定用户会以我们期待的方式去处理数据，所以一定要显式的指定我们数据的呈现形式。</p><p>包括但不限于：</p><ul><li>在<code>HTML</code>中显式指定<code>Content-Type</code></li></ul><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#062873;font-weight:700>meta</span> <span style=color:#4070a0>http-equiv</span><span style=color:#666>=</span><span style=color:#4070a0>&#34;Content-Type&#34;</span> <span style=color:#4070a0>content</span><span style=color:#666>=</span><span style=color:#4070a0>&#34;text/html; charset=UTF-8&#34;</span> /&gt;
</code></pre></div><ul><li>服务器端返回的<code>Response Headers</code>中要显式指定内容编码和类型</li></ul><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>Content-Encoding:gzip
Content-Type:text/html; charset=utf-8
</code></pre></div><h2 id=heading-6>总结</h2><p>其实在web开发这个领域，规范已经非常详细了，文本的编码，Headers的定义，服务器端的返回值等等。不要把规范当成默认，一定要显式指定规范中描述的参数，不要让用户来猜测你的数据类型。作为开发者，在严格遵守相应规范的同时，也要考虑兼容用户不符合规范的行为。当然，这种兼容也要有一定的尺度，强行兼容所有可能的用户行为往往吃力不讨好，落入了过度设计与提早优化的深渊。</p><p>个中尺度的把握，往往能够看出一个程序员的火候。</p><p>以此自勉。</p></div><div id=disqus_thread></div><script type=application/javascript async>let disqus_config=function(){this.page.identifier='\/2016\/11\/22\/garbled-page\/';this.page.title='有趣的网页乱码问题';this.page.url='https:\/\/xuanwo.io\/2016\/11\/22\/garbled-page\/';};(function(){let d=document,s=d.createElement('script');s.async=true;s.src='//only0god.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script></article></main><footer class="footer container"><a class=main-nav-link href=/categories/>分类</a>
<a class=main-nav-link href=/tags/>标签</a>
<a class=main-nav-link href=/series/>专题</a>
<a class=main-nav-link href=/blogroll/>友链</a>
<a class=main-nav-link href=/index.xml>订阅</a>
<script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-51515330-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></footer></body></html>