<!doctype html><html><head><title>UVa 1594 Ducci Sequence</title><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="A blog maintained by an interesting programmer."><meta name=keywords content="Technology,Code,Program,Linux,"><meta name=author content="Xuanwo"><meta property="og:title" content="UVa 1594 Ducci Sequence"><meta property="og:description" content="A blog maintained by an interesting programmer."><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://xuanwo.io/2015/08/16/uva-1594-ducci-sequence/"><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=https://xuanwo.io/css/main.min.a285da0837b674a21742d9d9056c807cf8074d0e7b0cd2e85d30ed1ddf2acddd.css integrity="sha256-ooXaCDe2dKIXQtnZBWyAfPgHTQ57DNLoXTDtHd8qzd0="><link href=http://gmpg.org/xfn/11 rel=profile><meta name=generator content="Hugo 0.61.0"></head><body><nav class=nav><div class=nav-container><div class=brand><a href=https://xuanwo.io>Xuanwo's Blog</a></div><div class=links><a class=main-nav-link href=/about/>关于我</a>
<a class=main-nav-link href=/posts/>文章</a></div></div></nav><main id=main-content><article class="single container"><header class=single-header><div class=flex><h1>UVa 1594 Ducci Sequence</h1><div class=post-meta><time class=date datetime=2015-08-16T04:04:26.000+00:00 itemprop=datePublished>2015-08-16</time>
/
<span><a href=#disqus_thread class=comment-link>Comments</a></span></div><div class=tag-container></div></div></header><div class=post><h2 id=heading>题目</h2><p>源地址：</p><p><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4469">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4469</a></p><h1 id=heading-1>理解</h1><h2 id=heading-2>题意分析</h2><p>题意十分简单，给定一个序列的变换，每一次都把当前位置上的数变为当前位置与下一个位置差的绝对值。然后问你这个序列最后是变成一个循环还是全都变为0。</p><h2 id=heading-3>暴力做法</h2><p>一开始看题目的时候感觉很难下手，不知道应该怎样去判断这个序列能否构成一个循环。但是注意到另外一个条件——题目中给出了最大的循环次数，1000次。再加上n的值比较小，也就是说，我完全可以暴力模拟一千次，如果还是没有全为0的串的话，这个串一定是一个循环的串。基于这种想法，我可以得到一个非常简单的暴力算法。</p><h2 id=floyd>Floyd判圈算法</h2><h3 id=heading-4>概述</h3><p>这道题已经AC了，但是问题并没有结束。回到我最一开始的想法——我该如何判断一个序列是否构成了循环呢？这样，我们就引出了一个算法：<a href=https://zh.wikipedia.org/zh/Floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95>Floyd判圈算法</a>。是的，这个Floyd就是那个最短路算法的发明者。
这个算法可以在有限状态机，迭代函数或者链表上判断是否存在环，并求出该环的起点和长度的算法。</p><h3 id=heading-5>介绍</h3><p>下面请允许我引用维基百科上对于该算法的介绍：</p><blockquote></blockquote><p>如果有限状态机、迭代函数或者链表上存在环，那么在某个环上以不同速度前进的2个指针必定会在某个时刻相遇。同时显然地，如果从同一个起点(即使这个起点不在某个环上)同时开始以不同速度前进的2个指针最终相遇，那么可以判定存在一个环，且可以求出2者相遇处所在的环的起点与长度。</p><h3 id=heading-6>实现</h3><p>如果有限状态机、迭代函数或者链表存在环，那么一定存在一个起点可以到达某个环的某处(这个起点也可以在某个环上)。</p><p>初始状态下，假设已知某个起点节点为节点S。现设两个指针t和h，将它们均指向S。</p><p>接着，同时让t和h往前推进，但是二者的速度不同：t每前进1步，h前进2步。只要二者都可以前进而且没有相遇，就如此保持二者的推进。当h无法前进，即到达某个没有后继的节点时，就可以确定从S出发不会遇到环。反之当t与h再次相遇时，就可以确定从S出发一定会进入某个环，设其为环C。</p><p>如果确定了存在某个环，就可以求此环的起点与长度。</p><p>上述算法刚判断出存在环C时，显然t和h位于同一节点，设其为节点M。显然，仅需令h不动，而t不断推进，最终又会返回节点M，统计这一次t推进的步数，显然这就是环C的长度。</p><p>为了求出环C的起点，只要令h仍均位于节点M，而令t返回起点节点S。随后，同时让t和h往前推进，且保持二者的速度相同：t每前进1步，h前进1步。持续该过程直至t与h再一次相遇，设此次相遇时位于同一节点P，则节点P即为从节点S出发所到达的环C的第一个节点，即环C的一个起点。</p><h3 id=heading-7>伪代码</h3><pre><code>t := &amp;S
h := &amp;S                 //令指针t和h均指向起点节点S。
repeat
  t := t-&gt;next
  h := h-&gt;next
  if h is not NULL      //要注意这一判断一般不能省略
       h := h-&gt;next
until t = h or h = NULL
if h != NULL            //如果存在环的话
   n := 0
   repeat               //求环的长度
       t := t-&gt;next
       n := n+1
   until t = h
   t := &amp;S              //求环的一个起点
   while t != h
         t := t-&gt;next
         h := h-&gt;next
   P := *t

</code></pre><h3 id=heading-8>本题应用</h3><p>具体到本题中，我只需要将输入的数据分别存入两个数组a和b，然后让a每次操作一次，让b每次操作两次。这样就使得a和b有了不一样的速度，然后每次都进行判断，根据前面讲解的算法，只要a和b相等，那就意味着这个数组一定是循环的。然后再处理一下均为0的情况，这道题的Floyd判圈算法的版本就出来了。</p><h3 id=brent>速度更快的Brent判圈算法</h3><p>在维基百科的条目中还提到了一个比Floyd判断算法快36%的Brent判圈算法，不过目前貌似资料不足，所以这个部分就暂时按下不表了。</p><h1 id=heading-9>代码</h1><h2 id=heading-10>暴力算法</h2><pre><code>const int maxn = 100;

int t,n,a[maxn],b[maxn];

bool judge()
{
    for(int i=1; i&lt;=n; ++i)
    {
        if(a[i]!=0) return false;
    }
    return true;
}

void next()
{
    for(int i=1; i&lt;=n; ++i)
    {
        b[i]=abs(a[i]-a[i+1]);
    }
    for(int i=1; i&lt;=n; ++i)
    {
        a[i]=b[i];
    }
    a[n+1]=a[1];
}

bool ans;

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    while(t--)
    {
        ans = false;
        scanf(&quot;%d&quot;, &amp;n);
        for(int i=1; i&lt;=n; ++i)   scanf(&quot;%d&quot;, &amp;a[i]);
        a[0]=a[n];
        a[n+1]=a[1];
        for(int k=1; k&lt;=1000; ++k)
        {
            if(judge())
            {
                ans=true;
                break;
            }
            else
            {
                next();
            }
        }
        if(!ans) printf(&quot;LOOP\n&quot;);
        else printf(&quot;ZERO\n&quot;);
    }
}

</code></pre><h2 id=floyd-1>Floyd判圈算法</h2><pre><code>const int maxn = 100;
int t,n,a[maxn];
int b[maxn],c[maxn]= {0};

void next(int a[])
{
    for(int i=1; i&lt;=n; ++i)
    {
        a[i]=abs(a[i]-a[i+1]);
    }
    a[n+1]=a[1];
}

bool equal(int a[], int b[])
{
    for(int i=1; i&lt;=n; ++i)
    {
        if(a[i]!=b[i])  return false;
    }
    return true;
}

int main()
{
    scanf(&quot;%d&quot;, &amp;t);
    while(t--)
    {
        scanf(&quot;%d&quot;, &amp;n);
        for(int i=1; i&lt;=n; ++i)
        {
            scanf(&quot;%d&quot;, &amp;a[i]);
            b[i]=a[i];
        }
        a[n+1]=b[n+1]=a[1];
        bool loop =true;
        for(int i=0; i&lt;1010; ++i)
        {
            next(a);
            next(b);
            next(b);
            if(equal(a,c))
            {
                loop = false;
                break;
            }
            if(equal(a,b))
            {
                loop = true;
                break;
            }
            if(equal(b,c))
            {
                loop = false;
                break;
            }
        }
        if(loop)    printf(&quot;LOOP\n&quot;);
        else printf(&quot;ZERO\n&quot;);
    }
}

</code></pre><h1 id=heading-11>更新日志</h1><ul><li>2015年08月16日 本题已经用两种方法AC</li></ul></div><div id=disqus_thread></div><script type=application/javascript>let disqus_config=function(){this.page.identifier='\/2015\/08\/16\/uva-1594-ducci-sequence\/';this.page.title='UVa 1594 Ducci Sequence';this.page.url='https:\/\/xuanwo.io\/2015\/08\/16\/uva-1594-ducci-sequence\/';};(function(){let d=document,s=d.createElement('script');s.async=true;s.src='//only0god.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class="footer container"><a class=main-nav-link href=/categories/>分类</a>
<a class=main-nav-link href=/tags/>标签</a>
<a class=main-nav-link href=/series/>专题</a>
<a class=main-nav-link href=/blogroll/>友链</a>
<a class=main-nav-link href=/index.xml>订阅</a>
<script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-51515330-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></footer></body></html>