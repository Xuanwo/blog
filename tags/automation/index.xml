<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Automation on Xuanwo&#39;s Blog</title><link>https://xuanwo.io/tags/automation/</link><description>Recent content in Automation on Xuanwo&#39;s Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 14 Jan 2018 10:07:00 +0000</lastBuildDate><atom:link href="https://xuanwo.io/tags/automation/index.xml" rel="self" type="application/rss+xml"/><item><title>基于 AWS Lambda 实现自动化</title><link>https://xuanwo.io/2018/01/14/automation-based-on-aws-lambda/</link><pubDate>Sun, 14 Jan 2018 10:07:00 +0000</pubDate><guid>https://xuanwo.io/2018/01/14/automation-based-on-aws-lambda/</guid><description>&lt;p&gt;在上一篇文章中我们介绍了 &lt;a href=&#34;https://xuanwo.io/2017/12/03/integromat-intro/&#34;&gt;Integrmat&lt;/a&gt; 这个自动化平台，但是在实际的应用当中，它还是有一些不太符合我们项目需求的地方。基于 AWS Lambda 实现的自动化工具就是我们找到的替代方案，接下来我会将阐述一下项目的需求，然后根据对项目的需求分析为什么 Integrmat 不适合以及基于 AWS Lambda 实现的好处在哪里。之后会介绍一下 AWS Lambda 是什么以及如何实现我们的自动化工具，并分享一些在实现自动化工具中遇到的一些坑。&lt;/p&gt;
&lt;h2 id=&#34;项目需求&#34;&gt;项目需求&lt;/h2&gt;
&lt;p&gt;我们项目中主要有一下几个部分需要用到自动化工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Jenkins 上运行的自动构建出错时自动在 Trello 中创建 Card&lt;/li&gt;
&lt;li&gt;Grafana 报警时自动在 Trello 中创建 Card&lt;/li&gt;
&lt;li&gt;移动到 Done 列表的超过两周的 Card 自动归档&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;why-not-integrmat&#34;&gt;Why not Integrmat&lt;/h3&gt;
&lt;p&gt;以 &lt;code&gt;Jenkins 出错后在 Trello 中创建 Card&lt;/code&gt; 这个需求为例，我们需要的不仅仅是简单的出错之后加个 Card 就可以了。我们需要的是一个 Jenkins 出错到恢复的全生命周期的管理，也就是说根据上一次 Jenkins Job 执行的状态和本次状态，我们会有如下几种情况：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;上次状态&lt;/th&gt;
&lt;th&gt;本次状态&lt;/th&gt;
&lt;th&gt;执行操作&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;成功&lt;/td&gt;
&lt;td&gt;成功&lt;/td&gt;
&lt;td&gt;忽略&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;成功&lt;/td&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;创建一个新 Card&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;在之前创建的 Card 中增加新的评论&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;成功&lt;/td&gt;
&lt;td&gt;归档对应的 Card&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这就会带来除了创建 Card 之外额外的操作次数调用，而这些都是计费的。&lt;/p&gt;
&lt;p&gt;不仅如此，我们的 Jenkins 每天 24 小时都在不停的执行 Job，按照并行三个 Job，单个 Job 执行 1 分钟来计算，每天会触发 8640 次。每次 Job 如果失败的话需要操作大约 5 次，成功的话需要操作 2 次。按照 1% 的失败率来计算，我们一个月需要的操作数为 596160 次。对应到 Integrmat 的收费政策，我们需要开通每月 299 刀的最顶级套餐 = =。&lt;/p&gt;
&lt;p&gt;Integrmat 在其优质服务，良好体验的背后，带来是不菲的开销。显然，此路不通。&lt;/p&gt;
&lt;h3 id=&#34;why-aws-lambda&#34;&gt;Why AWS Lambda&lt;/h3&gt;
&lt;p&gt;分析完了上面的为什么不是 Integrmat 之后，使用 AWS Lambda 的理由就变得非常明显了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不想自己从头撸一个 FaaS 框架&lt;/li&gt;
&lt;li&gt;AWS Lambda 很便宜&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AWS 提供的免费套餐中有着如下几条：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lambda 每月 100 万个免费请求 （永久）&lt;/li&gt;
&lt;li&gt;DynamoDB 25GB 存储 （永久）&lt;/li&gt;
&lt;li&gt;API Gateway 每月接收 100 万次 （12 个月免费）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结合前面的计算，AWS 的免费套餐已经完全可以覆盖我们的需求。&lt;/p&gt;
&lt;h2 id=&#34;aws-lambda-faas-介绍&#34;&gt;AWS Lambda / FaaS 介绍&lt;/h2&gt;
&lt;p&gt;FaaS 是指给 Function 提供运行环境和调度的服务，而 AWS Lambda 则是目前 FaaS 中运用比较广泛的一个服务。用户只需要实现业务逻辑，将代码上传到 AWS 之后，AWS 会负责处理接下来的所有事情：调度，伸缩，高可用，日志等等。而这些只有在方法被调用的时候才会计费，可以真正的做到按需运行，按毫秒计费。更详细的介绍可以看老王之前写的一篇文章 —— &lt;a href=&#34;http://jolestar.com/serverless-faas-current-status-and-future/&#34;&gt;Serverless/FaaS 的现状和未来&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要说明的是，从理论上来说任何 FaaS 框架都可以用来实现本文中描述功能，本文以 AWS Lambda 为例只是因为我们项目中刚好在用以及比较便宜而已，并不代表本人的任何倾向。老王的文章中也有介绍各个平台的 FaaS 服务，感兴趣的同学可以去看一看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;如何实现自动化&#34;&gt;如何实现自动化&lt;/h2&gt;
&lt;p&gt;我们主要用到了以下工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lambda&lt;/li&gt;
&lt;li&gt;DynamoDB&lt;/li&gt;
&lt;li&gt;API Gateway&lt;/li&gt;
&lt;li&gt;CloudWatch&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 Lambda 会提供函数运行的环境，我们主要使用了 Python 3.6。Lambda 每次运行都是一个完全独立的环境，我们需要接入 DynamoDB 来提供持久化存储的能力。API Gateway 则会对外暴露出一个链接作为 Webhook 来触发 Lambda 运行，CloudWatch 除了收集日志之外，还能够定时触发任务。这四件套下来，基本上就能够覆盖我们开发自动化工具所需要的大部分功能。下面我们就以 &lt;code&gt;Jenkins 出错后在 Trello 中创建 Card&lt;/code&gt; 这个需求为例，讲解一下如何实现基于 AWS Lambda 的自动化工具。&lt;/p&gt;
&lt;h3 id=&#34;创建函数&#34;&gt;创建函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;进入 Lambda 的界面，点击右上方的 &lt;code&gt;创建函数&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;选择 &lt;code&gt;从头开始创作&lt;/code&gt; 即可。&lt;/li&gt;
&lt;li&gt;填写函数的名字，这个名字在创建好之后是不能修改的。&lt;/li&gt;
&lt;li&gt;选择运行语言，根据自己的喜好选择即可&lt;/li&gt;
&lt;li&gt;选择运行角色，这里我推荐 &lt;code&gt;创建自定义角色&lt;/code&gt;。为每一个函数都创建一个独立的角色，这样方便控制权限，以后比较容易分得清。AWS 的 IAM 超级恶心，这是我摸索出来的不太容易出问题的步骤。对 AWS IAM 熟悉的同学可以忽略我的建议。&lt;/li&gt;
&lt;li&gt;点击 &lt;code&gt;创建函数&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样我们的一个函数就创建好了。&lt;/p&gt;
&lt;h3 id=&#34;接入服务&#34;&gt;接入服务&lt;/h3&gt;
&lt;p&gt;为了能够实现我们上述的需求，我们还需要接入对应的服务： DynamoDB，API Gateway 和 CloudWatch。其中每个函数会默认添加一个 CloudWatch，因此不需要再做额外的配置。DynamoDB 和 API Gateway 都建议先再外部创建好，然后再在 Lambda 中去添加，要不然 AWS 自动创建的 IAM 规则会非常乱，很容易出现各种奇怪的问题。如果对稳定性要求比较高的同学可以将 API Gateway 绑定到一个固定的 version 上，比如创建一个 version 叫做 &lt;code&gt;production&lt;/code&gt;，然后再将 &lt;code&gt;production&lt;/code&gt; 指向某个具体的版本，这样可以保证线上运行的代码始终是不变的，同时也方便使用 API Gateway 的流量调度来做一些灰度测试之类的。没有这方面需求的同学，可以直接将 API Gateway 绑定到 &lt;code&gt;$LASTEST&lt;/code&gt; 上，这样所有的请求都会由最新的代码来执行。&lt;/p&gt;
&lt;h3 id=&#34;编辑函数&#34;&gt;编辑函数&lt;/h3&gt;
&lt;p&gt;函数创建好之后就进入了函数的配置界面。这个地方 AWS 嵌入了 Cloud9 的在线编辑器，自带语言高亮，缩进和提示，还是比较好用的。当然除了在线编辑之外也可以上传 zip 包或者选择从 S3 上传，之后用到的时候再讲。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;os&lt;/span&gt;
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;json&lt;/span&gt;
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;boto3&lt;/span&gt;
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#0e84b5;font-weight:bold&#34;&gt;trello&lt;/span&gt; &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;import&lt;/span&gt; TrelloClient
trello &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; TrelloClient(
api_key&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;os&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;environ[&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;TRELLO_API_KEY&amp;#39;&lt;/span&gt;],
api_secret&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;os&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;environ[&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;TRELLO_API_SECRET&amp;#39;&lt;/span&gt;],
token&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;os&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;environ[&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;TRELLO_TOKEN&amp;#39;&lt;/span&gt;],
token_secret&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;os&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;environ[&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;TRELLO_TOKEN_SECRET&amp;#39;&lt;/span&gt;]
)
board &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; trello&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;get_board(os&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;environ[&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;TRELLO_BOARD_ID&amp;#39;&lt;/span&gt;])
todo_list &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; board&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;get_list(os&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;environ[&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;TRELLO_TODO_LIST_ID&amp;#39;&lt;/span&gt;])
done_list &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; board&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;get_list(os&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;environ[&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;TRELLO_DONE_LIST_ID&amp;#39;&lt;/span&gt;])
dynamodb &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; boto3&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;resource(&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;dynamodb&amp;#39;&lt;/span&gt;)
table &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; dynamodb&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;Table(os&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;environ[&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;DYNAMODB_TABLE&amp;#39;&lt;/span&gt;])
SUCCESS &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;SUCCESS&amp;#39;&lt;/span&gt;]
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#06287e&#34;&gt;main&lt;/span&gt;(event, context):
event &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; json&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;loads(event[&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;body&amp;#39;&lt;/span&gt;])
name &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; event[&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;]
status &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; event[&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;build&amp;#39;&lt;/span&gt;][&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;status&amp;#39;&lt;/span&gt;]
q &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; table&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;get_item(Key&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;{&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;project&amp;#39;&lt;/span&gt;: name})
&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;# Create a new card if this project is not exist.&lt;/span&gt;
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;Item&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;in&lt;/span&gt; q:
&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;# Nothing need to do if event is successful.&lt;/span&gt;
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;if&lt;/span&gt; status &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;in&lt;/span&gt; SUCCESS:
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;return&lt;/span&gt;
card &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; todo_list&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;add_card(
name&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#70a0d0;font-style:italic&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt; #&lt;/span&gt;&lt;span style=&#34;color:#70a0d0;font-style:italic&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt; Build &lt;/span&gt;&lt;span style=&#34;color:#70a0d0;font-style:italic&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;%&lt;/span&gt; (name, event[&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;build&amp;#39;&lt;/span&gt;][&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;number&amp;#39;&lt;/span&gt;], status),
desc&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;event[&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;build&amp;#39;&lt;/span&gt;][&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;full_url&amp;#39;&lt;/span&gt;],
position&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;top&amp;#39;&lt;/span&gt;
)
table&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;put_item(Item&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;{
&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;project&amp;#39;&lt;/span&gt;: name,
&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;status&amp;#39;&lt;/span&gt;: status,
&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;card_id&amp;#39;&lt;/span&gt;: card&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#007020&#34;&gt;id&lt;/span&gt;
})
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;return&lt;/span&gt;
&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;# If project exists, we should update card depends on project status.&lt;/span&gt;
item &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; q[&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;Item&amp;#39;&lt;/span&gt;]
card &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; trello&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;get_card(card_id&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;item[&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;card_id&amp;#39;&lt;/span&gt;])
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;if&lt;/span&gt; status &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;in&lt;/span&gt; SUCCESS:
table&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;delete_item(Key&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;{&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;project&amp;#39;&lt;/span&gt;: name})
card&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;comment(
&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#70a0d0;font-style:italic&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt; #&lt;/span&gt;&lt;span style=&#34;color:#70a0d0;font-style:italic&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt; Build &lt;/span&gt;&lt;span style=&#34;color:#70a0d0;font-style:italic&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#4070a0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#70a0d0;font-style:italic&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;%&lt;/span&gt;
(name, event[&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;build&amp;#39;&lt;/span&gt;][&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;number&amp;#39;&lt;/span&gt;], status, event[&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;build&amp;#39;&lt;/span&gt;][&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;full_url&amp;#39;&lt;/span&gt;]))
card&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;set_closed(True)
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;return&lt;/span&gt;
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;if&lt;/span&gt; status &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;in&lt;/span&gt; SUCCESS:
card&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;comment(
&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#70a0d0;font-style:italic&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt; #&lt;/span&gt;&lt;span style=&#34;color:#70a0d0;font-style:italic&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt; Build &lt;/span&gt;&lt;span style=&#34;color:#70a0d0;font-style:italic&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#4070a0;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#70a0d0;font-style:italic&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;%&lt;/span&gt;
(name, event[&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;build&amp;#39;&lt;/span&gt;][&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;number&amp;#39;&lt;/span&gt;], status, event[&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;build&amp;#39;&lt;/span&gt;][&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;full_url&amp;#39;&lt;/span&gt;]))
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;return&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上就是我们实现 &lt;code&gt;Jenkins 出错后在 Trello 中创建 Card&lt;/code&gt; 的全部代码。有几个需要拿出来单独讲一下的地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数运行是调用的 Handler 函数是可以修改的，比如这里就是修改成了 &lt;code&gt;main.main&lt;/code&gt;，Lambda 会在代码中寻找 &lt;code&gt;main.py&lt;/code&gt; 文件并执行该文件中的 &lt;code&gt;main&lt;/code&gt; 函数。&lt;/li&gt;
&lt;li&gt;Handler 函数主要接收两个参数，event 与 context，event 中就是外部传入的数据。如果在 Lambda 外面套了 API Gateway 的话，API Gateway 会增加额外的内容，并且把请求体放到 &lt;code&gt;event[&#39;body&#39;]&lt;/code&gt; 中，因此我们需要 &lt;code&gt;json.loads(event[&#39;body&#39;])&lt;/code&gt; 才能取到外部传过来的真实值。&lt;/li&gt;
&lt;li&gt;Lambda 环境中自带了 boto3 并且与 IAM 集成了，因此可以不需要额外的认证直接调用已经授权的服务，比如这个地方用到的 &lt;code&gt;dynamodb&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Lambda 支持设置环境变量，因此可以将一些参数都放到环境变量中并通过 &lt;code&gt;os.environ&lt;/code&gt; 来读取。&lt;/li&gt;
&lt;li&gt;如果要在 Lambda 中引用外部的库，则需要将这些库一起打包上传。以这里的 &lt;code&gt;trello&lt;/code&gt; 库为例，我们需要执行 &lt;code&gt;pip install py-trello -t .&lt;/code&gt; 将这个库及其相关依赖下载到当前目录，然后使用 &lt;code&gt;zip -r ../code.zip *&lt;/code&gt; 压缩后上传。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体的实现就不再多讲，相信大家都能看懂。&lt;/p&gt;
&lt;h3 id=&#34;调试函数&#34;&gt;调试函数&lt;/h3&gt;
&lt;p&gt;在代码写好之后，我们可以在页面直接调试。页面右上方可以配置一些测试事件，点击 &lt;code&gt;保存&lt;/code&gt; 后点 &lt;code&gt;测试&lt;/code&gt; 即可直接运行。运行结果会有对应的日志展示出来，也可以到 CloudWatch 中去查看更为完整的日志，根据日志反馈的情况修改自己的代码即可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从国内上传代码很是恶心，开着代理也经常出问题，不知道啥原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;这篇文章主要介绍了如何基于 AWS Lambda 来实现一个自动化脚本。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除了偶尔请求 timeout 之外，服务很稳定，上线之后不用费心维护&lt;/li&gt;
&lt;li&gt;自动集成的 CloudWatch 日志挺好用，调试很方便&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调试的过程比较麻烦，不能接入外部的 Git 服务，只能用 AWS 自己的那个&lt;/li&gt;
&lt;li&gt;上线的脚本多了之后维护起来很麻烦，没有一个统一管理的方案&lt;/li&gt;
&lt;li&gt;强依赖 AWS 自己的服务，日后迁移要大改脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;动态&#34;&gt;动态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这篇文章是一月份写的，但是一直到今天（2018.3.4）才写好结尾发出来 = =&lt;/li&gt;
&lt;li&gt;我的 github profile 是有多像一个前端以至于所有公司给我发的 JD 都是前端？&lt;/li&gt;
&lt;li&gt;尼尔半价了，2B 小姐姐赛高&lt;/li&gt;
&lt;li&gt;我永远喜欢薇尔莉特.jpg&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Integromat -- 最强大的自动化平台</title><link>https://xuanwo.io/2017/12/03/integromat-intro/</link><pubDate>Sun, 03 Dec 2017 10:07:00 +0000</pubDate><guid>https://xuanwo.io/2017/12/03/integromat-intro/</guid><description>&lt;p&gt;&lt;img src=&#34;https://xuanwo.io/imgs/opinion/integromat-example.png&#34; alt=&#34;Integrmat Example&#34; /&gt;&lt;/p&gt;
&lt;p&gt;今天想跟大家分享一个类似于 IFTTT 的自动化平台： &lt;a href=&#34;https://www.integromat.com&#34;&gt;Integromat&lt;/a&gt;。与 IFTTT 最大的区别是它允许用户通过操作每一次请求的输入和输出来构建一个完整的链条，比如上图的这个例子就是实现了这样的一个功能：当完成 Todoist 中带有指定属性的任务时，将这个任务移动到 &lt;code&gt;Done&lt;/code&gt; 列表，并将其放到 &lt;code&gt;Done&lt;/code&gt; 列表的顶端。&lt;/p&gt;
&lt;p&gt;接下来我会先简单地介绍一下 Integromat，然后讲解一下 Integromat 涉及到的一些元素，最后讲讲如何定制并调试自己的场景。&lt;/p&gt;
&lt;h2 id=&#34;0x00-介绍&#34;&gt;0x00 介绍&lt;/h2&gt;
&lt;p&gt;Integromat 是由一家专门做系统集成和外包服务的公司 &lt;a href=&#34;www.integrators.cz&#34;&gt;Integrators&lt;/a&gt; 推出的产品，2012 年开始开发， 2016 年正式面向大众推出。目前团队中有 19 人，其中负责技术的有 9 人。他们愿景是要做互联网的胶水，同时自称 Integromat 是最先进的在线自动化平台，在使用了他们的服务之后我发现他们没有骗我。&lt;/p&gt;
&lt;h2 id=&#34;0x01-特点&#34;&gt;0x01 特点&lt;/h2&gt;
&lt;p&gt;详细的特性列表可以参考此处： &lt;a href=&#34;https://www.integromat.com/en/features&#34;&gt;https://www.integromat.com/en/features&lt;/a&gt; ，下面我只列出一些我认为有用 &amp;amp; 特别的特性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完整的 ACID 事务支持，拥有处理异常的能力&lt;/li&gt;
&lt;li&gt;可视化操作界面，可以看到每一步操作的详细数据，调试便利程度 Max&lt;/li&gt;
&lt;li&gt;支持路由功能，可以实现多条分支的处理&lt;/li&gt;
&lt;li&gt;支持常用函数（数值，时间和字符串的常用操作，甚至还有正则）&lt;/li&gt;
&lt;li&gt;支持解析 JSON 到预设的数据结构当中&lt;/li&gt;
&lt;li&gt;支持 Webhook 和 定时器 两种触发器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为一个互联网自动化爱好者，我先后使用过 &lt;a href=&#34;https://ifttt.com/&#34;&gt;IFTTT&lt;/a&gt;，&lt;a href=&#34;https://zapier.com&#34;&gt;Zapier&lt;/a&gt; 等商业服务，也部署过 &lt;a href=&#34;https://github.com/muesli/beehive&#34;&gt;Beehive&lt;/a&gt;，&lt;a href=&#34;https://github.com/huginn/huginn&#34;&gt;Huginn&lt;/a&gt; 这样的开源服务，但是没有一个像 Integromat 这么强大，更何况，它的界面也是相当的简洁好看。&lt;/p&gt;
&lt;h2 id=&#34;0x02-概念介绍&#34;&gt;0x02 概念介绍&lt;/h2&gt;
&lt;p&gt;强大的功能通常都意味着陡峭的学习曲线，Integromat 也不例外。为了实现上文中提到的诸多特性，Integromat 引入了很多概念，这使得它的上手难度比 IFTTT 和 Zapier 高上不少。但是 Integromat 的工程师们在前端的引导和设计上下了很多功夫，尽可能地降低了新用户的门槛。根据我的实际经验，有初步编程开发经验的同学只要摸索上几分钟就能上手，而零编程基础的同学如果不使用那些高级特性的话，只需要十几分钟就能捣鼓出一个实际可用的场景。&lt;/p&gt;
&lt;p&gt;为了更好的帮助新同学使用 Integromat，下面我会简单的介绍一下 Integromat 涉及到的一些元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Scenario（场景）：场景是 Integromat 中一系列任务的组合，相当于 IFTTT 中的 Applets。&lt;/li&gt;
&lt;li&gt;Service（服务）：服务是 Integromat 中预设好的一些服务，比如 Dropbox，Gmail 等，相当于 IFTTT 中的 Service。
&lt;ul&gt;
&lt;li&gt;Trigger（触发器）：满足一定条件的时候会触发这个服务&lt;/li&gt;
&lt;li&gt;Instant（实时）：某些触发器会标着实时，这意味着这个触发器可以通过 Webhook 来实时触发，否则就只能使用 Integromat 的定时器来触发。&lt;/li&gt;
&lt;li&gt;Action（操作）：这个服务通过一定的输入来执行对应的操作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Connection（联接）：联接是 Integromat 中绑定的服务，联接与服务是多对一的关系，可以通过创建同一个服务的多个联接来实现多帐号。&lt;/li&gt;
&lt;li&gt;Webhook：某些服务支持在满足某些条件的时候向预先设置好的 Webhook 发送信息，Integromat 可以创建这样的 webhook 来接受指定的信息，注意这个 Webhook 跟服务的触发器是绑定的。&lt;/li&gt;
&lt;li&gt;Key：Integromat 可以上传一些加密的文件来支持某些敏感的操作&lt;/li&gt;
&lt;li&gt;Device： 与 IFTTT 一样， Integromat 可以与一些设备绑定来支持设备相关的操作&lt;/li&gt;
&lt;li&gt;Data structure（数据结构）： 对于预设的服务，Integromat 已经事先解析好了对应的结构体，但是如果是自己创建的 Webhook，那需要自己定义好对应的数据结构，可以通过上传一个 JSON 文件来创建。&lt;/li&gt;
&lt;li&gt;Data store：Integromat 提供了一个简单的 KV 存储，用于在多个场景或者同一个场景多次执行中共享数据，可以进行 Get，Set 和 Del 等操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Integromat 涉及到的元素确实要比 IFTTT 多上不少，但是新同学刚刚上手的时候只需要了解 Scenario，Service 和 Connection 就已经足够了，剩下的高级特性可以之后慢慢摸索。&lt;/p&gt;
&lt;h2 id=&#34;0x03-收费政策&#34;&gt;0x03 收费政策&lt;/h2&gt;
&lt;p&gt;Integromat 的收费政策可以参考： &lt;a href=&#34;https://www.integromat.com/en/pricing&#34;&gt;https://www.integromat.com/en/pricing&lt;/a&gt; ， 这里主要讲一下 Free 这一档：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;免费用户每个月可以进行 1000 次操作，有 100 M的流量，定时器的最小间隔为 15 分钟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所有用户的场景数量都是没有限制的，但是有着 1000 次的操作数量限制，在单个 Scenario 的历史记录当中可以看到每一次运行都进行了多少次操作。基本上可以看作有多少个 “圈” 就会有多少操作，没有执行到的部分不会进行计算。&lt;/p&gt;
&lt;p&gt;对于轻度用户而言，1000 次操作基本上刚刚够用；如果不用来在网盘之间同步东西的话，100M 的流量是绰绰有余的。对于重度用户而言，花个 9 刀或者 29 刀购买套餐也是个不错的主意，这么强大的服务值得为止付费。&lt;/p&gt;
&lt;h2 id=&#34;0x04-如何定制-调试&#34;&gt;0x04 如何定制 &amp;amp; 调试&lt;/h2&gt;
&lt;p&gt;Integromat 的图形化界面已经足够优秀了，官方也提供了不少的教程，比如 &lt;a href=&#34;https://www.integromat.com/en/kb/tutorial/get-a-tweet-on-twitter-when-a-new-tweet-from-google-sheet-row-is-created.html&#34;&gt;google sheet 中增加了一行就创建一个 tweet &lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这里主要讲讲我感觉需要注意的一些地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一个场景都必须从一个触发器开始。实际上每次创建一个场景，都会有一个无法删除的模块，你只需要点击并选择某个服务的触发器即可。&lt;/li&gt;
&lt;li&gt;两个模块连接的地方会有一个漏斗标志，点开之后可以设置过滤器，如果条件不满足就会在这个地方中止。&lt;/li&gt;
&lt;li&gt;Connections 和 Webhook 不需要提前创建好，只需要在开发场景的时候选择 &lt;code&gt;Add&lt;/code&gt; 即可。&lt;/li&gt;
&lt;li&gt;所有的模块运行一次之后就会在右上方出现一个带数字的小圆，点开之后可以看到本次运行的实际数据。所以调试的时候可以点一次 &lt;code&gt;Run once&lt;/code&gt;，然后就能看到真实的数据了，这样调试起来更加方便。&lt;/li&gt;
&lt;li&gt;左下角有一个像飞机的图标 &lt;code&gt;Explain flow&lt;/code&gt;，点击之后就会以动画的形式展示数据的流动。如果正在开发比较复杂的场景，不妨使用这个功能看看数据是怎么流动的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;0x05-总结&#34;&gt;0x05 总结&lt;/h2&gt;
&lt;p&gt;Integromat 适合以下人群：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;觉得 IFTTT 反应太慢了/可定制化程度太低了/没有想要的功能的普通用户&lt;/li&gt;
&lt;li&gt;想要跟自己的工作流做集成的工作人士&lt;/li&gt;
&lt;li&gt;闲着没事干就想折腾黑科技的 Geek 们&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Have fun in automation!&lt;/p&gt;
&lt;/blockquote&gt;</description></item></channel></rss>