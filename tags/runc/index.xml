<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>runC on Xuanwo's Blog</title><link>https://xuanwo.io/tags/runc/</link><description>Recent content in runC on Xuanwo's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 06 Aug 2019 01:00:00 +0000</lastBuildDate><atom:link href="https://xuanwo.io/tags/runc/index.xml" rel="self" type="application/rss+xml"/><item><title>My Solution for DNS Poisoning by AtomDNS</title><link>https://xuanwo.io/2020/04/05/my-solution-for-dns-poisoning-by-atomdns/</link><pubDate>Sun, 05 Apr 2020 01:00:00 +0000</pubDate><guid>https://xuanwo.io/2020/04/05/my-solution-for-dns-poisoning-by-atomdns/</guid><description>&lt;p>I used to be a big fan of &lt;a href="https://github.com/coredns/coredns">coredns&lt;/a>: I use it on my laptop, in our team&amp;rsquo;s internal infrastructure and maintain the package for &lt;a href="https://github.com/archlinuxcn/repo">archlinuxcn&lt;/a>. Until one day, I want to solve the DNS Pollution problem by &lt;a href="https://github.com/coredns/coredns">coredns&lt;/a>. But&amp;hellip;&lt;/p>
&lt;h2 id="coredns-is-not-for-dns-pollution">CoreDNS is not for DNS Pollution&lt;/h2>
&lt;p>It&amp;rsquo;s obvious that I&amp;rsquo;m not the only fan of &lt;a href="https://github.com/coredns/coredns">coredns&lt;/a>, there are mainly two solutions via coredns:&lt;/p>
&lt;ul>
&lt;li>Generate Corefile: as &lt;a href="https://minidump.info/blog/2019/07/coredns-no-dns-poisoning/">https://minidump.info/blog/2019/07/coredns-no-dns-poisoning/&lt;/a> does&lt;/li>
&lt;li>Write coredns plugin: like &lt;a href="https://github.com/blahgeek/coredns-chinadns">coredns-chinadns&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="why-not-generate-corefile">Why not generate corefile?&lt;/h3>
&lt;p>First of all, it&amp;rsquo;s ugly and not suitable for updates automatically. We have to generate the whole &lt;code>Corefile&lt;/code> every time domain list updated and make it hard to apply custom updates. For example, I need to forward some internal domains to a DNS server in a VPN. I need to add them in corefile build scripts or build another system to build corefile.&lt;/p>
&lt;p>Then, coredns forward except is not designed for large domains input. forward will read all zone in a slice, and check them one by one:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#60a0b0;font-style:italic">// Read all domains
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">parseBlock&lt;/span>(c &lt;span style="color:#666">*&lt;/span>caddy.Controller, f &lt;span style="color:#666">*&lt;/span>Forward) &lt;span style="color:#902000">error&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">switch&lt;/span> c.&lt;span style="color:#06287e">Val&lt;/span>() {
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> &lt;span style="color:#4070a0">&amp;#34;except&amp;#34;&lt;/span>:
ignore &lt;span style="color:#666">:=&lt;/span> c.&lt;span style="color:#06287e">RemainingArgs&lt;/span>()
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020">len&lt;/span>(ignore) &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> c.&lt;span style="color:#06287e">ArgErr&lt;/span>()
}
&lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>; i &amp;lt; &lt;span style="color:#007020">len&lt;/span>(ignore); i&lt;span style="color:#666">++&lt;/span> {
ignore[i] = plugin.&lt;span style="color:#06287e">Host&lt;/span>(ignore[i]).&lt;span style="color:#06287e">Normalize&lt;/span>()
}
f.ignored = ignore
&lt;span style="color:#666">...&lt;/span>
}
&lt;span style="color:#60a0b0;font-style:italic">// Check one by one
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> (f &lt;span style="color:#666">*&lt;/span>Forward) &lt;span style="color:#06287e">isAllowedDomain&lt;/span>(name &lt;span style="color:#902000">string&lt;/span>) &lt;span style="color:#902000">bool&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> dns.&lt;span style="color:#06287e">Name&lt;/span>(name) &lt;span style="color:#666">==&lt;/span> dns.&lt;span style="color:#06287e">Name&lt;/span>(f.from) {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">true&lt;/span>
}
&lt;span style="color:#007020;font-weight:bold">for&lt;/span> _, ignore &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#007020;font-weight:bold">range&lt;/span> f.ignored {
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> plugin.&lt;span style="color:#06287e">Name&lt;/span>(ignore).&lt;span style="color:#06287e">Matches&lt;/span>(name) {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">false&lt;/span>
}
}
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">true&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can use the builtin zone support for better performance:&lt;/p>
&lt;pre>&lt;code class="language-caddyfile" data-lang="caddyfile">. {
log
cache
forward . 8.8.8.8
}
abc.com def.com {
log
cache
forward . 114.114.114.114
}
&lt;/code>&lt;/pre>&lt;p>But we still need to maintain a huge corefile.&lt;/p>
&lt;h3 id="why-not-write-a-plugin">Why not write a plugin?&lt;/h3>
&lt;p>So, why not write a plugin to read domains from a file and forward it to different upstreams? Yes, I tried, and I found &lt;a href="https://github.com/coredns/coredns">coredns&lt;/a>&amp;lsquo;s plugin system is a mess.&lt;/p>
&lt;p>&lt;a href="https://github.com/coredns/coredns">coredns&lt;/a> is chain based, all dns query will be split via zones, so we can&amp;rsquo;t filter and forward them by domains. To handle all domains, we have to design a plugin under root:&lt;/p>
&lt;pre>&lt;code class="language-caddyfile" data-lang="caddyfile">. {
filter xxxxx
}
&lt;/code>&lt;/pre>&lt;p>Then, we need to design a config that matches something and forward to somewhere, maybe like the following:&lt;/p>
&lt;pre>&lt;code class="language-caddyfile" data-lang="caddyfile">. {
filter {
condition domain_in_file xxxxxxxxxx
action forward xxxxxxx
}
filter {
condition domain_not_in_file xxxxxxxxxx
action forward xxxxxx
}
}
&lt;/code>&lt;/pre>&lt;p>Looks perfect for now, let&amp;rsquo;s implement it. Ooooops, we need forward here, why not use the builtin forward? Sorry, we can&amp;rsquo;t. Plugin in coredns doesn&amp;rsquo;t been designed for run standalone or embedded, we can&amp;rsquo;t call other plugins or pass the query to other plugins conveniently. As I described in RFC &lt;a href="https://github.com/coredns/rfc/issues/6">embeddable plugin&lt;/a>, many plugins have to implement the same feature.&lt;/p>
&lt;p>So, don&amp;rsquo;t dig deeper, let&amp;rsquo;s jump out of the chaos.&lt;/p>
&lt;h2 id="so-what-am-i-need">So, what am I need?&lt;/h2>
&lt;p>After talking so much, what am I need?&lt;/p>
&lt;ul>
&lt;li>Forward DNS query to upstreams depends on conditions&lt;/li>
&lt;li>Human-readable config&lt;/li>
&lt;li>Simple deployment, no extra build needed&lt;/li>
&lt;li>No so bad performance&lt;/li>
&lt;/ul>
&lt;p>Although there are other good DNS servers like &lt;a href="https://github.com/shawn1m/overture">overture&lt;/a> and &lt;a href="https://github.com/pymumu/smartdns">smartdns&lt;/a>, let&amp;rsquo;s build a DNS server for ourselves.&lt;/p>
&lt;h2 id="say-hi-to-atomdns">Say Hi to AtomDNS!&lt;/h2>
&lt;p>With &lt;a href="https://github.com/miekg/dns">dns&lt;/a> package support, write a DNS server by go is so simple that we can build one in a half-day: &lt;a href="https://github.com/Xuanwo/atomdns">atomdns&lt;/a>.&lt;/p>
&lt;p>&lt;a href="https://github.com/Xuanwo/atomdns">atomdns&lt;/a> is built by three-part: &lt;code>upstream&lt;/code>, &lt;code>match&lt;/code> and &lt;code>rules&lt;/code>. &lt;code>upstream&lt;/code> means a set of DNS servers that dns been forwarded to. &lt;code>match&lt;/code> is the match policy, and we support &lt;code>in_domain_list&lt;/code> type for now. &lt;code>rules&lt;/code> will specify when match policy matched, this query should be forwarded to which &lt;code>upstream&lt;/code>.&lt;/p>
&lt;p>&lt;a href="https://github.com/Xuanwo/atomdns">atomdns&lt;/a>&amp;lsquo;s config is powered by &lt;a href="https://github.com/hashicorp/hcl/tree/hcl2">hcl2&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-hcl" data-lang="hcl">listen &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;127.0.0.1:53&amp;#34;&lt;/span>
&lt;span style="color:#007020;font-weight:bold">upstream&lt;/span> &lt;span style="color:#4070a0">&amp;#34;oversea&amp;#34;&lt;/span> {
type &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;dot&amp;#34;&lt;/span>
addr &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;185.222.222.222:853&amp;#34;&lt;/span>
tls_server_name &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;public-dns-a.dns.sb&amp;#34;&lt;/span>
}
&lt;span style="color:#007020;font-weight:bold">upstream&lt;/span> &lt;span style="color:#4070a0">&amp;#34;mainland&amp;#34;&lt;/span> {
type &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;udp&amp;#34;&lt;/span>
addr &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;114.114.114.114:53&amp;#34;&lt;/span>
}
&lt;span style="color:#007020;font-weight:bold">match&lt;/span> &lt;span style="color:#4070a0">&amp;#34;to_mainland&amp;#34;&lt;/span> {
type &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;in_domain_list&amp;#34;&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic"> # get this file from https://github.com/felixonmars/dnsmasq-china-list
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> path &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;/etc/atomdns/accelerated-domains.china.raw.txt&amp;#34;&lt;/span>
}
rules &lt;span style="color:#666">=&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">to_mainland&lt;/span>&lt;span style="">:&lt;/span> &lt;span style="color:#4070a0">&amp;#34;mainland&amp;#34;&lt;/span>,
&lt;span style="color:#007020;font-weight:bold">default&lt;/span>&lt;span style="">:&lt;/span> &lt;span style="color:#4070a0">&amp;#34;oversea&amp;#34;&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We have two &lt;code>upstream&lt;/code> here, and one names &lt;code>oversea&lt;/code>, the other names &lt;code>mainland&lt;/code>. When &lt;code>to_mainland&lt;/code> matched which is in the domain list we specify here, we will forward it to &lt;code>mainland&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">atomdns[164688]: 2020/04/06 22:09:13 [{wx1.qq.com. 1 1}]
atomdns[164688]: 2020/04/06 22:09:13 rule to_mainland matched, served via mainland
atomdns[164688]: 2020/04/06 22:12:18 [{github.githubassets.com. 1 1}]
atomdns[164688]: 2020/04/06 22:12:18 no rules matched, served via oversea
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Simple, but works.&lt;/p></description></item><item><title>公有云对象存储服务体验吐嘈</title><link>https://xuanwo.io/2020/03/03/object-storage/</link><pubDate>Tue, 03 Mar 2020 01:00:00 +0000</pubDate><guid>https://xuanwo.io/2020/03/03/object-storage/</guid><description>&lt;p>最近一直在做&lt;a href="https://xuanwo.io/2019/12/30/storage-intro/">面向应用的 Golang 抽象存储层&lt;/a>，目前已经对接了十个存储后端，其中有八个是对象存储服务，可以说是对接了大部分公有云对象存储服务了。在对接的过程中有很多感慨，这次整理起来盘点一下。&lt;/p>
&lt;p>截止到 &lt;a href="https://github.com/Xuanwo/storage/releases/tag/v0.7.1">v0.7.1&lt;/a>，&lt;a href="https://github.com/Xuanwo/storage">storage&lt;/a> 对接了如下对象存储服务：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#azblob">azblob&lt;/a>: &lt;a href="https://docs.microsoft.com/en-us/azure/storage/blobs/">Azure Blob storage&lt;/a>&lt;/li>
&lt;li>&lt;a href="#cos">cos&lt;/a>: &lt;a href="https://cloud.tencent.com/product/cos">Tencent Cloud Object Storage&lt;/a>&lt;/li>
&lt;li>&lt;a href="#gcs">gcs&lt;/a>: &lt;a href="https://cloud.google.com/storage/">Google Cloud Storage&lt;/a>&lt;/li>
&lt;li>&lt;a href="#kodo">kodo&lt;/a>: &lt;a href="https://www.qiniu.com/products/kodo">qiniu kodo&lt;/a>&lt;/li>
&lt;li>&lt;a href="#oss">oss&lt;/a>: &lt;a href="https://www.aliyun.com/product/oss">Aliyun Object Storage&lt;/a>&lt;/li>
&lt;li>&lt;a href="#qingstor">qingstor&lt;/a>: &lt;a href="https://www.qingcloud.com/products/qingstor/">QingStor Object Storage&lt;/a>&lt;/li>
&lt;li>&lt;a href="#s3">s3&lt;/a>: &lt;a href="https://aws.amazon.com/s3/">Amazon S3&lt;/a>&lt;/li>
&lt;li>&lt;a href="#uss">uss&lt;/a>: &lt;a href="https://www.upyun.com/products/file-storage">UPYUN Storage Service&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>每个服务会简单介绍一下，然后聊聊对应服务的 go SDK对接体验，并不涉及到性能/稳定性等方面的测试，也不是严肃的产品选型方案，请诸君明鉴。SDK 方面会统一以调用一次 &lt;code>Write&lt;/code> 为例展开，看看 SDK 的设计风格和相应的错误处理体验。&lt;/p>
&lt;h2 id="azblob">azblob&lt;/h2>
&lt;p>如今的云计算市场上，Azure 算是比较特别的，很多服务都是自成一格，没有采取跟随 AWS 的策略：跟 AWS 把块存储，文件存储，对象存储分为三个不同的服务不同，Azure 先构建好一个 Stream Layer，然后在上面支持各种存储形态，包括 &lt;a href="https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blobs-introduction">Blob&lt;/a>，&lt;a href="https://docs.microsoft.com/en-us/azure/storage/files/storage-files-introduction">Files&lt;/a>，&lt;a href="https://docs.microsoft.com/en-us/azure/storage/queues/storage-queues-introduction">Queue&lt;/a> 和 &lt;a href="https://docs.microsoft.com/en-us/azure/storage/tables/table-storage-overview">Table&lt;/a>，共同组成了 Azure Storage 服务。&lt;/p>
&lt;blockquote>
&lt;p>相关 Paper: &lt;a href="https://www.microsoft.com/en-us/research/publication/erasure-coding-in-windows-azure-storage/">Erasure Coding in Windows azure storage&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>我们这次要聊的就是 Azure Blob Storage，下面简写为 &lt;code>azblob&lt;/code>。&lt;/p>
&lt;p>&lt;code>azblob&lt;/code> 会涉及到三种资源：&lt;code>Account&lt;/code>，&lt;code>Container&lt;/code> 和 &lt;code>Blob&lt;/code>，关系如 Azure 官方文档给出的图：&lt;/p>
&lt;p>&lt;img src="./azblob-1.png" alt="">&lt;/p>
&lt;p>&lt;code>Container&lt;/code> 对应 &lt;code>s3&lt;/code> 的 &lt;code>Bucket&lt;/code>，&lt;code>Blob&lt;/code> 对应 &lt;code>s3&lt;/code> 的 &lt;code>Objcet&lt;/code>。比较特别的是 &lt;code>Account&lt;/code> 的概念，Azure 通过 &lt;code>Account&lt;/code> 来提供不同应用场景的优化，比如 &lt;code>General-purpose v2 accounts&lt;/code> 适用于大多数场景，而 &lt;code>BlockBlobStorage accounts&lt;/code> 适用于高吞吐，低延迟的场景等。&lt;/p>
&lt;p>&lt;code>azblob&lt;/code> 中的 &lt;code>blob&lt;/code> 有三种类型，在创建的时候决定，创建后不能修改：&lt;/p>
&lt;ul>
&lt;li>&lt;code>block blobs&lt;/code>： 由一组 blocks 组成，单个 block 最大 100MB，最多 5W 个，也就是说单个 &lt;code>block blobs&lt;/code> 最大 4.75 TB。&lt;/li>
&lt;li>&lt;code>page blobs&lt;/code>： 则是由一组 512B 的 pages 组成，针对随机读写的场景优化，写操作需要对齐 512B（以 page 为单位），单次写操作最大 4MB，单个 &lt;code>page blobs&lt;/code> 最大 8 TB。&lt;/li>
&lt;li>&lt;code>append blobs&lt;/code>： 同样由 blocks 组成，针对 append 场景优化。单个 Block 最大 4MB，最多 5W 个，也就是说单个 &lt;code>append blobs&lt;/code> 最大 195GB。&lt;/li>
&lt;/ul>
&lt;p>底层架构决定上层设计。架构复杂的情况下，API 自然也精简不起来，用户需要搞明白上述的全部内容才能在 &lt;code>PutBlob&lt;/code>，&lt;code>PutPage&lt;/code>，&lt;code>AppendBlock&lt;/code> 和 &lt;code>PutBlock&lt;/code> 这几个 API 中做出正确的选择。&lt;/p>
&lt;p>&lt;code>azblob&lt;/code> 提供了 &lt;code>container&lt;/code> 级别的删除锁，&lt;code>blob&lt;/code> 级别的写/删除锁和 snapshot，支持自定义 metadata，存储级别，批量操作，复制。支持配置 ACL，但是不支持 Blob 级别的 Policy。支持软删除，保留时间通过 &lt;code>DeleteRetentionPolicy&lt;/code> 来定义，能够通过 &lt;code>UndeleteBlob&lt;/code> 恢复。&lt;/p>
&lt;p>&lt;code>azblob&lt;/code> SDK 用来的一个突出感受是智商不太够用，一方面 SDK 对外暴露的方案跟 API 文档中给的不太对应，另一方面是 SDK 额外提供了很多抽象。比如说 &lt;code>put-blob&lt;/code> 对外暴露的方法是 &lt;code>Upload&lt;/code>，&lt;code>put-block&lt;/code> 暴露的是 &lt;code>StageBlock&lt;/code>，而 &lt;code>put-block-list&lt;/code>则是 &lt;code>CommitBlockList&lt;/code>。调用一次 &lt;code>Upload&lt;/code> 需要初始化很多空的结构体，包括 &lt;code>azblob.BlobHTTPHeaders&lt;/code>，&lt;code>azblob.Metadata&lt;/code> 和 &lt;code>azblob.BlobAccessConditions&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">func&lt;/span> (s &lt;span style="color:#666">*&lt;/span>Storage) &lt;span style="color:#06287e">Write&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>, r io.Reader, pairs &lt;span style="color:#666">...*&lt;/span>types.Pair) (err &lt;span style="color:#902000">error&lt;/span>) {
&lt;span style="color:#666">...&lt;/span>
rp &lt;span style="color:#666">:=&lt;/span> s.&lt;span style="color:#06287e">getAbsPath&lt;/span>(path)
&lt;span style="color:#666">...&lt;/span>
_, err = s.bucket.&lt;span style="color:#06287e">NewBlockBlobURL&lt;/span>(rp).&lt;span style="color:#06287e">Upload&lt;/span>(opt.Context, iowrap.&lt;span style="color:#06287e">ReadSeekCloser&lt;/span>(r),
azblob.BlobHTTPHeaders{}, azblob.Metadata{}, azblob.BlobAccessConditions{})
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> err
}
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>返回的 Error 都统一封装为 &lt;code>azblob.StorageError&lt;/code> 接口，但是不知道是不是我搞错了什么，有个蛋疼点是&lt;code>azblob.StorageError&lt;/code> 暴露的 &lt;code>ServiceCode()&lt;/code> 方法返回的是 &lt;code>ServiceCodeType&lt;/code> ，然而 &lt;code>azblob&lt;/code> 导出的是一堆 &lt;code>StorageErrorCodeType&lt;/code>。所以在检查错误的时候还需要强行转换一下：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">formatAzblobError&lt;/span>(err azblob.StorageError) &lt;span style="color:#902000">error&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">switch&lt;/span> azblob.&lt;span style="color:#06287e">StorageErrorCodeType&lt;/span>(err.&lt;span style="color:#06287e">ServiceCode&lt;/span>()) {
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> azblob.StorageErrorCodeBlobNotFound:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%w: %v&amp;#34;&lt;/span>, services.ErrObjectNotExist, err)
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> azblob.StorageErrorCodeInsufficientAccountPermissions:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%w: %v&amp;#34;&lt;/span>, services.ErrPermissionDenied, err)
&lt;span style="color:#007020;font-weight:bold">default&lt;/span>:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> err
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="cos">cos&lt;/h2>
&lt;p>&lt;code>cos&lt;/code> 是腾讯云推出的对象存储服务，提供了 S3 兼容。&lt;/p>
&lt;p>&lt;code>cos&lt;/code> 有种很强的接地气的感觉，我举个例子：&lt;code>清单 inventory&lt;/code> API，包括 &lt;code>PUT Bucket inventory&lt;/code>，&lt;code>GET Bucket inventory&lt;/code>，&lt;code>List Bucket Inventory Configurations&lt;/code> 和 &lt;code>DELETE Bucket inventory&lt;/code>，用来增删改查 Bucket 配置的清单，其用途是每天或者每周定时扫描用户存储桶内指定的对象或拥有相同对象前缀的对象，并输出一份清单报告，以 CSV 格式的文件存储到用户指定的存储桶中。这功能就很有意思，官方给出的基本用途也很有中国特色：&lt;code>审核并报告对象的复制和加密状态&lt;/code>，&lt;code>简化并加快业务工作流和大数据作业&lt;/code>。&lt;/p>
&lt;p>&lt;code>cos&lt;/code> 的 SDK 用起来中规中举，不过 &lt;code>ObjectPutOptions&lt;/code> 下面嵌套了两个结构体 &lt;code>ObjectPutHeaderOptions&lt;/code> 和 &lt;code>ACLHeaderOptions&lt;/code>，稍微有那么点不太舒服，想必是 &lt;code>cos&lt;/code> SDK 开发者为了能够复用 &lt;code>ACLHeaderOptions&lt;/code>，不想在 API 中重复展开 &lt;code>ACL&lt;/code> 相关的 Header 才如此设计的。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#60a0b0;font-style:italic">// Write implements Storager.Write
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> (s &lt;span style="color:#666">*&lt;/span>Storage) &lt;span style="color:#06287e">Write&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>, r io.Reader, pairs &lt;span style="color:#666">...*&lt;/span>types.Pair) (err &lt;span style="color:#902000">error&lt;/span>) {
&lt;span style="color:#666">...&lt;/span>
rp &lt;span style="color:#666">:=&lt;/span> s.&lt;span style="color:#06287e">getAbsPath&lt;/span>(path)
putOptions &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#666">&amp;amp;&lt;/span>cos.ObjectPutOptions{
ObjectPutHeaderOptions: &lt;span style="color:#666">&amp;amp;&lt;/span>cos.ObjectPutHeaderOptions{
ContentLength: &lt;span style="color:#007020">int&lt;/span>(opt.Size),
},
}
&lt;span style="color:#666">...&lt;/span>
_, err = s.object.&lt;span style="color:#06287e">Put&lt;/span>(opt.Context, rp, r, putOptions)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> err
}
&lt;span style="color:#007020;font-weight:bold">return&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>cos&lt;/code> 同样返回了自定义的错误类型：&lt;code>*cos.ErrorResponse&lt;/code>，不过并没有导出所有的 error code，需要从文档中查询对应的错误码：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">formatCosError&lt;/span>(err &lt;span style="color:#666">*&lt;/span>cos.ErrorResponse) &lt;span style="color:#902000">error&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">switch&lt;/span> err.Code {
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> &lt;span style="color:#4070a0">&amp;#34;NoSuchKey&amp;#34;&lt;/span>:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%w: %v&amp;#34;&lt;/span>, services.ErrObjectNotExist, err)
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> &lt;span style="color:#4070a0">&amp;#34;AccessDenied&amp;#34;&lt;/span>:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%w: %v&amp;#34;&lt;/span>, services.ErrPermissionDenied, err)
&lt;span style="color:#007020;font-weight:bold">default&lt;/span>:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> err
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="gcs">gcs&lt;/h2>
&lt;p>GCP 充满了一股子技术精英范儿，&lt;code>gcs&lt;/code> 也不例外。&lt;/p>
&lt;p>他们官方文档列出来的核心功能头一条就是 &lt;code>Storage classes for any workload&lt;/code>，提供了标准，近线，冷和归档四种存储级别，而且不管是哪个存储级别都能做到毫秒级的 TTFB(time to first byte)，他们归档存储文档的原话是：&lt;/p>
&lt;blockquote>
&lt;p>Unlike the &amp;ldquo;coldest&amp;rdquo; storage services offered by other Cloud providers, your data is available within milliseconds, not hours or days.&lt;/p>
&lt;/blockquote>
&lt;p>这就很强势。&lt;/p>
&lt;p>&lt;code>gcs&lt;/code> 同时提供了 JSON 和 XML 的 RESTful API，提供了 S3 兼容，返回的都是标准的 HTTP Status Code。API 里面都是骚东西，比如说：&lt;/p>
&lt;p>&lt;code>compose&lt;/code>：把一组 Object 合并为一个新 Object&lt;/p>
&lt;p>&lt;code>rewrite&lt;/code>：将一个 Object 重写到新位置，支持超大 Object，&lt;code>copy&lt;/code> 的内部实现就是调用了一次 &lt;code>rewrite&lt;/code>&lt;/p>
&lt;p>&lt;code>gcs&lt;/code> 的 SDK 是我见过的最酷的，抽象程度最高，也是用起来最爽的。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">func&lt;/span> (s &lt;span style="color:#666">*&lt;/span>Storage) &lt;span style="color:#06287e">Write&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>, r io.Reader, pairs &lt;span style="color:#666">...*&lt;/span>types.Pair) (err &lt;span style="color:#902000">error&lt;/span>) {
&lt;span style="color:#666">...&lt;/span>
rp &lt;span style="color:#666">:=&lt;/span> s.&lt;span style="color:#06287e">getAbsPath&lt;/span>(path)
object &lt;span style="color:#666">:=&lt;/span> s.bucket.&lt;span style="color:#06287e">Object&lt;/span>(rp)
w &lt;span style="color:#666">:=&lt;/span> object.&lt;span style="color:#06287e">NewWriter&lt;/span>(opt.Context)
&lt;span style="color:#007020;font-weight:bold">defer&lt;/span> w.&lt;span style="color:#06287e">Close&lt;/span>()
&lt;span style="color:#666">...&lt;/span>
_, err = io.&lt;span style="color:#06287e">Copy&lt;/span>(w, r)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> err
}
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>额外贴一组 &lt;code>gcs&lt;/code> 和 &lt;code>qingstor&lt;/code> 调用 &lt;code>List&lt;/code> 方法的对比：&lt;/p>
&lt;p>&lt;code>gcs&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">for&lt;/span> {
it &lt;span style="color:#666">:=&lt;/span> s.bucket.&lt;span style="color:#06287e">Objects&lt;/span>(opt.Context, &lt;span style="color:#666">&amp;amp;&lt;/span>gs.Query{
Prefix: rp,
Delimiter: delimiter,
})
object, err &lt;span style="color:#666">:=&lt;/span> it.&lt;span style="color:#06287e">Next&lt;/span>()
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> &lt;span style="color:#666">&amp;amp;&amp;amp;&lt;/span> err &lt;span style="color:#666">==&lt;/span> iterator.Done {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span>
}
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> err
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>qingstor&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">var&lt;/span> output &lt;span style="color:#666">*&lt;/span>service.ListObjectsOutput
&lt;span style="color:#007020;font-weight:bold">for&lt;/span> {
output, err = s.bucket.&lt;span style="color:#06287e">ListObjects&lt;/span>(&lt;span style="color:#666">&amp;amp;&lt;/span>service.ListObjectsInput{
Limit: &lt;span style="color:#666">&amp;amp;&lt;/span>limit,
Marker: &lt;span style="color:#666">&amp;amp;&lt;/span>marker,
Prefix: &lt;span style="color:#666">&amp;amp;&lt;/span>rp,
Delimiter: &lt;span style="color:#666">&amp;amp;&lt;/span>delimiter,
})
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span>
}
marker = convert.&lt;span style="color:#06287e">StringValue&lt;/span>(output.NextMarker)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> marker &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#34;&amp;#34;&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">break&lt;/span>
}
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> output.HasMore &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> &lt;span style="color:#666">&amp;amp;&amp;amp;&lt;/span> !&lt;span style="color:#666">*&lt;/span>output.HasMore {
&lt;span style="color:#007020;font-weight:bold">break&lt;/span>
}
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020">len&lt;/span>(output.Keys) &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">break&lt;/span>
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>要是有机会搞 qingstor go sdk v4，我一定抄作业。&lt;/p>
&lt;p>&lt;code>gcs&lt;/code> 返回的错误是统一的 &lt;code>*googleapi.Error&lt;/code> 类型，但是诡异的是代码中会额外处理 &lt;code>ObjectNotExist&lt;/code> 的逻辑，导致在检查的时候需要额外判断：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">formatGcsError&lt;/span>(err &lt;span style="color:#902000">error&lt;/span>) &lt;span style="color:#902000">error&lt;/span> {
&lt;span style="color:#60a0b0;font-style:italic">// gcs sdk could return explicit error, we should handle them.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> errors.&lt;span style="color:#06287e">Is&lt;/span>(err, gs.ErrObjectNotExist) {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%w: %v&amp;#34;&lt;/span>, services.ErrObjectNotExist, err)
}
e, ok &lt;span style="color:#666">:=&lt;/span> err.(&lt;span style="color:#666">*&lt;/span>googleapi.Error)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> !ok {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> err
}
&lt;span style="color:#007020;font-weight:bold">switch&lt;/span> e.Code {
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> http.StatusNotFound:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%w: %v&amp;#34;&lt;/span>, services.ErrObjectNotExist, err)
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> http.StatusForbidden:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%w: %v&amp;#34;&lt;/span>, services.ErrPermissionDenied, err)
&lt;span style="color:#007020;font-weight:bold">default&lt;/span>:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> err
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="kodo">kodo&lt;/h2>
&lt;p>&lt;code>kodo&lt;/code> 是七牛的云海量存储系统，提供了 S3 兼容。&lt;/p>
&lt;p>&lt;code>kodo&lt;/code> 的 API 设计充满了实用主义色彩，缺乏一些顶层设计，以实用为上。以同样是 Bucket 级别的几个操作为例：&lt;/p>
&lt;p>设置空间标签：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-http" data-lang="http">&lt;span style="color:#06287e">PUT&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">/bucketTagging?bucket=&amp;lt;BucketName&amp;gt;&lt;/span> &lt;span style="color:#007020;font-weight:bold">HTTP&lt;/span>&lt;span style="color:#666">/&lt;/span>&lt;span style="color:#40a070">1.1&lt;/span>
Host&lt;span style="color:#666">:&lt;/span> uc.qbox.me
Content-Type&lt;span style="color:#666">:&lt;/span> application/json
Authorization&lt;span style="color:#666">:&lt;/span> Qiniu &amp;lt;AccessToken&amp;gt;
{
&lt;span style="color:#062873;font-weight:bold">&amp;#34;Tags&amp;#34;&lt;/span>:[
{&lt;span style="color:#062873;font-weight:bold">&amp;#34;Key&amp;#34;&lt;/span>:&lt;span style="">xx&lt;/span>, &lt;span style="color:#062873;font-weight:bold">&amp;#34;Value&amp;#34;&lt;/span>: &lt;span style="">xx&lt;/span>},
{&lt;span style="color:#062873;font-weight:bold">&amp;#34;Key&amp;#34;&lt;/span>:&lt;span style="">xx&lt;/span>, &lt;span style="color:#062873;font-weight:bold">&amp;#34;Value&amp;#34;&lt;/span>: &lt;span style="">xx&lt;/span>},
&lt;span style="">...&lt;/span>
]
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>设置 Bucket 镜像源：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-http" data-lang="http">&lt;span style="color:#06287e">POST&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">/image/&amp;lt;BucketName&amp;gt;/from/&amp;lt;EncodedSrcSiteUrl&amp;gt;/host/&amp;lt;EncodedHost&amp;gt;&lt;/span> &lt;span style="color:#007020;font-weight:bold">HTTP&lt;/span>&lt;span style="color:#666">/&lt;/span>&lt;span style="color:#40a070">1.1&lt;/span>
Host&lt;span style="color:#666">:&lt;/span> uc.qbox.me
Content-Type&lt;span style="color:#666">:&lt;/span> application/x-www-form-urlencoded
Authorization&lt;span style="color:#666">:&lt;/span> QBox &amp;lt;AccessToken&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>设置 Bucket 访问权限：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-http" data-lang="http">&lt;span style="color:#06287e">POST&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">/private&lt;/span> &lt;span style="color:#007020;font-weight:bold">HTTP&lt;/span>&lt;span style="color:#666">/&lt;/span>&lt;span style="color:#40a070">1.1&lt;/span>
Host&lt;span style="color:#666">:&lt;/span> uc.qbox.me
Content-Type&lt;span style="color:#666">:&lt;/span> application/x-www-form-urlencoded
Authorization&lt;span style="color:#666">:&lt;/span> QBox &amp;lt;AccessToken&amp;gt;
bucket=&amp;lt;BucketName&amp;gt;&amp;amp;private=&amp;lt;Private&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>三个 API，三种设计风格。我个人不太喜欢，但是能用。说到底，用户也不关心你的 API 设计是否优雅，能满足业务需求才是第一位的。&lt;/p>
&lt;p>&lt;code>kodo&lt;/code> 的 SDK 用起来感觉就很罗嗦，上传之前还需要先构造 &lt;code>FormUploader&lt;/code>，然后获取 &lt;code>UploadToken&lt;/code> ，&lt;code>Upload&lt;/code> 方法还有一堆参数。SDK 写成这样，跟他们的 API 设计是相关的，这也是他们为了实现各种上传方式付出的代价。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">func&lt;/span> (s &lt;span style="color:#666">*&lt;/span>Storage) &lt;span style="color:#06287e">Write&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>, r io.Reader, pairs &lt;span style="color:#666">...*&lt;/span>types.Pair) (err &lt;span style="color:#902000">error&lt;/span>) {
&lt;span style="color:#666">...&lt;/span>
rp &lt;span style="color:#666">:=&lt;/span> s.&lt;span style="color:#06287e">getAbsPath&lt;/span>(path)
uploader &lt;span style="color:#666">:=&lt;/span> qs.&lt;span style="color:#06287e">NewFormUploader&lt;/span>(s.bucket.Cfg)
ret &lt;span style="color:#666">:=&lt;/span> qs.PutRet{}
err = uploader.&lt;span style="color:#06287e">Put&lt;/span>(opt.Context,
&lt;span style="color:#666">&amp;amp;&lt;/span>ret, s.putPolicy.&lt;span style="color:#06287e">UploadToken&lt;/span>(s.bucket.Mac), rp, r, opt.Size, &lt;span style="color:#007020;font-weight:bold">nil&lt;/span>)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> err
}
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>kodo&lt;/code> 返回的错误类型是 &lt;code>*qs.ErrorInfo&lt;/code>，判断错误的方式也是错误码，前面的画风很正常，404 表示 not found，403 表示没权限，但是后面的一堆 6xx 和 7xx 就有点飘了，错误检查的时候也需要额外注释一下：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">formatError&lt;/span>(err &lt;span style="color:#902000">error&lt;/span>) &lt;span style="color:#902000">error&lt;/span> {
e, ok &lt;span style="color:#666">:=&lt;/span> err.(&lt;span style="color:#666">*&lt;/span>qs.ErrorInfo)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> !ok {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> err
}
&lt;span style="color:#60a0b0;font-style:italic">// error code returned by kodo looks like http status code, but it&amp;#39;s not.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#60a0b0;font-style:italic">// kodo could return 6xx or 7xx for their costumed errors, so we use untyped int directly.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#007020;font-weight:bold">switch&lt;/span> e.Code {
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> &lt;span style="color:#40a070">404&lt;/span>:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%w: %v&amp;#34;&lt;/span>, services.ErrObjectNotExist, err)
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> &lt;span style="color:#40a070">403&lt;/span>:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%w: %v&amp;#34;&lt;/span>, services.ErrPermissionDenied, err)
&lt;span style="color:#007020;font-weight:bold">default&lt;/span>:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> err
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="oss">oss&lt;/h2>
&lt;p>&lt;code>oss&lt;/code> 是阿里云的对象存储服务，提供了 s3 兼容，几乎是国内的事实标准。我个人有一个不太准确的小观察是，用 &lt;code>s3&lt;/code> 代称对象存储服务的客户通常都是搞国际业务的，技术范儿重一些，用 &lt;code>oss&lt;/code> 代称的客户则国内用户多一些，商务范儿也重一些。&lt;/p>
&lt;p>&lt;code>oss&lt;/code> 的 API 中有两个特别的一点的：一个是 &lt;code>Put/Get Symlink&lt;/code>，能为目标对象创建软链接。我能想到的应用场景是 &lt;code>GET /latest-build.tar.gz&lt;/code> ，Key 不变，但是背后指向的 Object 一直在更新。另一个是 &lt;code>SelectObject&lt;/code>，对目标文件（csv，json）执行 SQL 语句并返回结果。这个 API 是为了支持将计算下推，在存储层去做一些基本的过滤，只返回有用的数据。这样客户端这边就能减少网络流量，也能降低计算开销，对大数据平台很有利。这个还是挺酷的，目前还没有看到有厂商提供类似的功能。&lt;/p>
&lt;p>&lt;code>oss&lt;/code> 的 SDK 所有的 API 都接受 &lt;code>options ...Option&lt;/code> 这样的参数，用户需要构造 &lt;code>[]oss.Option&lt;/code> 并传进去。这样的设计保证了强类型，但是无法在编译期决定 API 是否支持这个参数，依赖于用户在开发的时候好好读文档。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">func&lt;/span> (s &lt;span style="color:#666">*&lt;/span>Storage) &lt;span style="color:#06287e">Write&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>, r io.Reader, pairs &lt;span style="color:#666">...*&lt;/span>types.Pair) (err &lt;span style="color:#902000">error&lt;/span>) {
&lt;span style="color:#666">...&lt;/span>
options &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#007020">make&lt;/span>([]oss.Option, &lt;span style="color:#40a070">0&lt;/span>)
&lt;span style="color:#666">...&lt;/span>
rp &lt;span style="color:#666">:=&lt;/span> s.&lt;span style="color:#06287e">getAbsPath&lt;/span>(path)
err = s.bucket.&lt;span style="color:#06287e">PutObject&lt;/span>(rp, r, options&lt;span style="color:#666">...&lt;/span>)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> err
}
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>oss&lt;/code> 返回了两类错误：&lt;code>oss.ServiceError&lt;/code> 与 &lt;code>oss.UnexpectedStatusCodeError&lt;/code>，分别对应的是有 Response Body 和没有 &lt;code>Body&lt;/code> 的请求。同样没有导出错误码，需要手写：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">formatError&lt;/span>(err &lt;span style="color:#902000">error&lt;/span>) &lt;span style="color:#902000">error&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">switch&lt;/span> e &lt;span style="color:#666">:=&lt;/span> err.(&lt;span style="color:#007020;font-weight:bold">type&lt;/span>) {
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> oss.ServiceError:
&lt;span style="color:#007020;font-weight:bold">switch&lt;/span> e.Code {
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> &lt;span style="color:#4070a0">&amp;#34;NoSuchKey&amp;#34;&lt;/span>:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%w: %v&amp;#34;&lt;/span>, services.ErrObjectNotExist, err)
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> &lt;span style="color:#4070a0">&amp;#34;AccessDenied&amp;#34;&lt;/span>:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%w: %v&amp;#34;&lt;/span>, services.ErrPermissionDenied, err)
}
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> oss.UnexpectedStatusCodeError:
&lt;span style="color:#007020;font-weight:bold">switch&lt;/span> e.&lt;span style="color:#06287e">Got&lt;/span>() {
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> &lt;span style="color:#40a070">404&lt;/span>:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%w: %v&amp;#34;&lt;/span>, services.ErrObjectNotExist, err)
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> &lt;span style="color:#40a070">403&lt;/span>:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%w: %v&amp;#34;&lt;/span>, services.ErrPermissionDenied, err)
}
}
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> err
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="qingstor">qingstor&lt;/h2>
&lt;blockquote>
&lt;p>利益相关: 截止到本文发布时，我就职于青云QingCloud QingStor Team&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>qingstor&lt;/code> 是青云QingCloud 推出的对象存储服务，提供 &lt;code>s3&lt;/code> 兼容。跟其他的公有云大厂不同的是，&lt;code>qingstor&lt;/code> 还有很多私有云客户。&lt;/p>
&lt;p>功能上基本对标 &lt;code>s3&lt;/code>，多了 &lt;code>AppendObject&lt;/code>， &lt;code>MoveObject&lt;/code> 和 &lt;code>FetchObject&lt;/code>。受累于青云QingCloud 本身至今没有对标 &lt;code>AWS Lambda&lt;/code> 的产品，&lt;code>qingstor&lt;/code> 被迫自己实现了图片转码和音视频转码等功能。按照我的看法，这些功能本应该从对象存储这一层剥离出去的。&lt;/p>
&lt;p>&lt;code>qingstor&lt;/code> 的 SDK 开发很大程度上参考了 &lt;code>s3&lt;/code> 的 go SDK，同样采用了代码生成的方式来保证每个 API 的 Input 和 Output 结构都是确定的。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">func&lt;/span> (s &lt;span style="color:#666">*&lt;/span>Storage) &lt;span style="color:#06287e">Write&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>, r io.Reader, pairs &lt;span style="color:#666">...*&lt;/span>types.Pair) (err &lt;span style="color:#902000">error&lt;/span>) {
&lt;span style="color:#666">...&lt;/span>
input &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#666">&amp;amp;&lt;/span>service.PutObjectInput{
ContentLength: &lt;span style="color:#666">&amp;amp;&lt;/span>opt.Size,
Body: r,
}
&lt;span style="color:#666">...&lt;/span>
rp &lt;span style="color:#666">:=&lt;/span> s.&lt;span style="color:#06287e">getAbsPath&lt;/span>(path)
_, err = s.bucket.&lt;span style="color:#06287e">PutObject&lt;/span>(rp, input)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span>
}
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>qingstor&lt;/code> SDK 返回了专门的 &lt;code>QingStorError&lt;/code> 类型，同样没有导出 error code：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">formatQingStorError&lt;/span>(e &lt;span style="color:#666">*&lt;/span>qserror.QingStorError) &lt;span style="color:#902000">error&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> e.Code &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#34;&amp;#34;&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">switch&lt;/span> e.StatusCode {
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> &lt;span style="color:#40a070">404&lt;/span>:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%w: %v&amp;#34;&lt;/span>, services.ErrObjectNotExist, e)
&lt;span style="color:#007020;font-weight:bold">default&lt;/span>:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> e
}
}
&lt;span style="color:#007020;font-weight:bold">switch&lt;/span> e.Code {
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> &lt;span style="color:#4070a0">&amp;#34;permission_denied&amp;#34;&lt;/span>:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%w: %v&amp;#34;&lt;/span>, services.ErrPermissionDenied, e)
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> &lt;span style="color:#4070a0">&amp;#34;object_not_exists&amp;#34;&lt;/span>:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%w: %v&amp;#34;&lt;/span>, services.ErrObjectNotExist, e)
&lt;span style="color:#007020;font-weight:bold">default&lt;/span>:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> e
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="s3">s3&lt;/h2>
&lt;p>&lt;code>s3&lt;/code> 想必是不用多说了，对象存储领域的事实标准。除了 &lt;code>s3&lt;/code> 本身以外，本文聊到了 7 家公有云对象存储服务供应商，只有 &lt;code>azblob&lt;/code> 没有直接兼容 &lt;code>s3&lt;/code> 接口。私有云领域的 &lt;code>ceph&lt;/code> 和 &lt;code>minio&lt;/code> 则更是早早的就提供了 &lt;code>s3&lt;/code> 接口的兼容，并将其作为自己的重要卖点。&lt;/p>
&lt;p>在我看来 &lt;code>s3&lt;/code> 的最大优势在于它与 &lt;code>AWS&lt;/code> 平台的深度协作，能够作为诸多 &lt;code>AWS&lt;/code> 产品的备份/恢复解决方案，能集成于各种大数据解决方案，能够与 &lt;code>Lambda&lt;/code> 协同实现各种各样的功能。产品生态恐怖如斯，后来者只能努力兼容 API 来稍微喝点汤。&lt;/p>
&lt;p>&lt;code>s3&lt;/code> SDK 有着很明显的代码生成痕迹，所有参数都放在一个 Input 中。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">func&lt;/span> (s &lt;span style="color:#666">*&lt;/span>Storage) &lt;span style="color:#06287e">Write&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>, r io.Reader, pairs &lt;span style="color:#666">...*&lt;/span>types.Pair) (err &lt;span style="color:#902000">error&lt;/span>) {
&lt;span style="color:#666">...&lt;/span>
rp &lt;span style="color:#666">:=&lt;/span> s.&lt;span style="color:#06287e">getAbsPath&lt;/span>(path)
input &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#666">&amp;amp;&lt;/span>s3.PutObjectInput{
Key: aws.&lt;span style="color:#06287e">String&lt;/span>(rp),
ContentLength: &lt;span style="color:#666">&amp;amp;&lt;/span>opt.Size,
Body: aws.&lt;span style="color:#06287e">ReadSeekCloser&lt;/span>(r),
}
&lt;span style="color:#666">...&lt;/span>
_, err = s.service.&lt;span style="color:#06287e">PutObject&lt;/span>(input)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> err
}
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>s3&lt;/code> SDK 返回了 &lt;code>awserr.Error&lt;/code> 类型，同样是没有导出的错误码：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">formatError&lt;/span>(err &lt;span style="color:#902000">error&lt;/span>) &lt;span style="color:#902000">error&lt;/span> {
e, ok &lt;span style="color:#666">:=&lt;/span> err.(awserr.Error)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> !ok {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> err
}
&lt;span style="color:#007020;font-weight:bold">switch&lt;/span> e.&lt;span style="color:#06287e">Code&lt;/span>() {
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> &lt;span style="color:#4070a0">&amp;#34;NoSuchKey&amp;#34;&lt;/span>:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%w: %v&amp;#34;&lt;/span>, services.ErrObjectNotExist, err)
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> &lt;span style="color:#4070a0">&amp;#34;AccessDenied&amp;#34;&lt;/span>:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%w: %v&amp;#34;&lt;/span>, services.ErrPermissionDenied, err)
}
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> err
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="uss">uss&lt;/h2>
&lt;p>&lt;code>uss&lt;/code> 是又拍云提供的对象存储服务，是我遇到的头一个不能通过 API 创建 Bucket，有真正的目录层级的对象存储服务。与其说是一个对象存储服务，倒更像是一个通过 HTTP 接口访问的文件存储。&lt;/p>
&lt;p>&lt;code>uss&lt;/code> 提供的 API 相对弱一点，只有文件和目录的操作，没有提供类似于 &lt;code>ACL&lt;/code>，&lt;code>Policy&lt;/code> 这样的特性。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">func&lt;/span> (s &lt;span style="color:#666">*&lt;/span>Storage) &lt;span style="color:#06287e">Write&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>, r io.Reader, pairs &lt;span style="color:#666">...*&lt;/span>types.Pair) (err &lt;span style="color:#902000">error&lt;/span>) {
&lt;span style="color:#666">...&lt;/span>
rp &lt;span style="color:#666">:=&lt;/span> s.&lt;span style="color:#06287e">getAbsPath&lt;/span>(path)
cfg &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#666">&amp;amp;&lt;/span>upyun.PutObjectConfig{
Path: rp,
Reader: r,
}
err = s.bucket.&lt;span style="color:#06287e">Put&lt;/span>(cfg)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> err
}
&lt;span style="color:#007020;font-weight:bold">return&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>uss&lt;/code> 的错误处理就很难搞了，在展示 &lt;a href="https://github.com/Xuanwo/storage">storage&lt;/a> 怎么处理 &lt;code>uss&lt;/code> 的错误之前，可以先看看它的源码是怎么写的：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">resp, err &lt;span style="color:#666">:=&lt;/span> up.&lt;span style="color:#06287e">doHTTPRequest&lt;/span>(config.method, url, headers, config.httpBody)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
&lt;span style="color:#60a0b0;font-style:italic">// Don&amp;#39;t modify net error
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span>, err
}
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> resp.StatusCode&lt;span style="color:#666">/&lt;/span>&lt;span style="color:#40a070">100&lt;/span> &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#40a070">2&lt;/span> {
body, _ &lt;span style="color:#666">:=&lt;/span> ioutil.&lt;span style="color:#06287e">ReadAll&lt;/span>(resp.Body)
resp.Body.&lt;span style="color:#06287e">Close&lt;/span>()
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> resp, fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%s %d %s&amp;#34;&lt;/span>, config.method, resp.StatusCode, &lt;span style="color:#007020">string&lt;/span>(body))
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我现在真的是有很多问号，API 都已经返回确定结构的 JSON 了，为啥 SDK 还要偷这个懒？Unmarshal 一下不吃亏的吧？最气的是，SDK 里面直接把 Body 读完了，外面想处理都没有机会了，食我 error string 啦！&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">formatError&lt;/span>(err &lt;span style="color:#902000">error&lt;/span>) &lt;span style="color:#902000">error&lt;/span> {
fn &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#007020;font-weight:bold">func&lt;/span>(s &lt;span style="color:#902000">string&lt;/span>) &lt;span style="color:#902000">bool&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> strings.&lt;span style="color:#06287e">Contains&lt;/span>(err.&lt;span style="color:#06287e">Error&lt;/span>(), &lt;span style="color:#4070a0">`&amp;#34;code&amp;#34;: `&lt;/span>&lt;span style="color:#666">+&lt;/span>s)
}
&lt;span style="color:#007020;font-weight:bold">switch&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> &lt;span style="color:#06287e">fn&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;40400001&amp;#34;&lt;/span>):
&lt;span style="color:#60a0b0;font-style:italic">// 40400001: file or directory not found
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%w: %v&amp;#34;&lt;/span>, services.ErrObjectNotExist, err)
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> &lt;span style="color:#06287e">fn&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;40100017&amp;#34;&lt;/span>), &lt;span style="color:#06287e">fn&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;40100019&amp;#34;&lt;/span>), &lt;span style="color:#06287e">fn&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;40300011&amp;#34;&lt;/span>):
&lt;span style="color:#60a0b0;font-style:italic">// 40100017: user need permission
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#60a0b0;font-style:italic">// 40100019: account forbidden
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#60a0b0;font-style:italic">// 40300011: has no permission to delete
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%w: %v&amp;#34;&lt;/span>, services.ErrPermissionDenied, err)
&lt;span style="color:#007020;font-weight:bold">default&lt;/span>:
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> err
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本文吐嘈了八家公有云对象存储供应商，其中 5 家国内的，3 家国外的。还是能比较明显的看出国外的三个大厂搞的对象存储各有特色，SDK 也写的非常扎实。国内的对象存储供应商里面 &lt;code>oss&lt;/code> 独一挡，不仅能追赶上御三家的节奏，还能拿出点自己的干货，&lt;code>uss&lt;/code> 吊车尾，功能不完整，SDK 一托屎。其他的厂商都差不多，都有些自己的问题。&lt;/p>
&lt;p>这个八个供应商里头，5 个巨头，3 个创业公司。不难发现这个 5 个巨头设计的 API 一致性都很强，SDK 也都写的不错。创业公司受限于人手和生存压力，往往没有办法顾及那么多，不管是 API 的设计还是 SDK 的开发优先级都不是最高的，尽力满足用户需求，生存下去才是第一位的。&lt;/p>
&lt;p>&lt;em>我们 QingStor 搞存储真的算挺认真的了（&lt;/em>&lt;/p>
&lt;p>&lt;strong>PS&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>本文单纯是 &lt;a href="https://github.com/Xuanwo/storage">storage&lt;/a> 开发过程中的体验吐嘈，文中提到的问题都是开发过程中的真实体验&lt;/li>
&lt;li>没有提及的厂商都是由于我个人尚不了解导致的，并非刻意排除&lt;/li>
&lt;li>如有错漏都是我个人对文档的理解有误，欢迎指正&lt;/li>
&lt;/ul>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blobs-overview">azblob 官方文档&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://cloud.tencent.com/product/cos/document">cos 官方文档&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://cloud.google.com/storage/docs">gcs 官方文档&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://developer.qiniu.com/kodo">kodo 官方文档&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://help.aliyun.com/product/31815.html">oss 官方文档&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://docs.qingcloud.com/qingstor/">qingstor 官方文档&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://docs.aws.amazon.com/s3/index.html">s3 官方文档&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://help.upyun.com/docs/storage/">uss 官方文档&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>小 Piu 本纪</title><link>https://xuanwo.io/2020/02/26/apiu/</link><pubDate>Wed, 26 Feb 2020 01:00:00 +0000</pubDate><guid>https://xuanwo.io/2020/02/26/apiu/</guid><description>&lt;p>小撇，又唤作小 Piu，因为我近来常看《甄嬛传》，又称做 Piu 贵人，Piu 妃。性别母，生于 19 年 9 月，尚未成年，时常被唤作小母狗，不以为意，甚至更加亲近，我总会说因为她是狗。&lt;/p>
&lt;hr>
&lt;p>女朋友思狗成疾，总是想养一只小边牧，在换房子后便去燕郊狗市抱了一只，两人空手去程两小时，返程带着她和一车子物件。在路上定名为小撇，姓随女友，乳名 Piu。很安静，一路上没有拉屎撒尿，没有发出一点声音，进京时已经在小箱子中睡着。到家后怯懦不敢行，满地板乱嗅，养在狗笼中，经常屎尿齐飞。后来换了开放式的狗栅栏，给它置办了狗窝，狗厕所，但是它总是想跳出来。有一天惹火了两人，将它关在狗栅栏中，谁知它在挣扎数次后，从上方跳了出来，两人喜不自胜。后来逐步撤走狗栅栏，让小 Piu 自由活动，满屋子都是它小脚爪敲击地面的声音。&lt;/p>
&lt;p>小 Piu 兴奋时会在房间内转圈奔跑，双耳直立，尾巴高翘及背，唤作“旋风狗”，冲过来踹我们一脚并反弹开，如是反复。小 Piu 害怕的时候会一个 Piu 缩到角落，双耳紧贴头皮，尾巴下垂，常发出“嘤嘤嘤”的声音。小 Piu 睡觉时会依偎在床侧，双手前伸，双脚后探，呈伸长状。大了之后能自行跳上床，并喜欢睡在我的头顶，整个 Piu 趴在枕头上侧，温热柔软的肚子贴着我的头皮，双手双脚抱住我的头，并常在熟睡时猛踹多次，纠正无效。小 Piu 安静时会认真看着我们，轻轻歪头，女友说这是因为小 Piu 的鼻子会挡住它的视线。&lt;/p>
&lt;p>我们工作的时候小 Piu 会依偎在我们脚边啃我们的拖鞋，女友的拖鞋被它啃出了一个大大的缺口，女友说她感到她的脚现在非常自由。我们看剧的时候小 Piu 会缩在沙发地下睡觉，听到我们唤她的时候会先伸出一个鼻子，然后头再缓缓深处。我们做饭的时候小 Piu 努力扒拉着灶台，一副“让我康康”的神态。我们上厕所的时候小 Piu 会忧心的等在门外，害怕我们被可怕的马桶怪吞噬，深夜睡着的时候听到我们的动静也会缓缓起身，护送我们上厕所。我们出门的时候小 Piu 会咬我们的裤脚不让出门，回来的时候会坐在家门口等着。我们一起出门的时候，它会一直朝前拽着绳子，埋怨我们人类不给力，跑的太慢。我们一起过马路的时候会跑起来，它迈开双腿，跑的飞快，在风中追逐自我。我们不管走到那里小 Piu 都会跟着，我们不管在做什么小 Piu 都会看着，认真的，歪歪头。&lt;/p>
&lt;p>小 Piu 喜欢吃药，补血的药，补钙的药，抗生素，美毛膏，甚至止咳糖浆。小 Piu 喜欢跟我们玩扔东西的游戏，我们把玩具扔到远处，小 Piu 冲过去叼回来。小 Piu 喜欢跟我们玩拔河，我们用力扯着它，它先是左右甩动，然后就整个身子匍匐在地上不肯起来，我们可以这样拖着它在地板上滑行，戏称为“拖地狗”。小 Piu 喜欢我们“辛巴”他，将它像举“辛巴”一样高高举起来，然后轻轻的扔在床上，它会一扭就弹起来扑向我们。小 Piu 喜欢我们吹它的鼻头，每次我们吹它的时候，它都会冲过来舔我们的脸。小 Piu 喜欢我们。&lt;/p>
&lt;p>小 Piu 害怕女友带着面膜，特别是女友还阴森森的学着鬼叫的时候，它总是夹着尾巴就跑。小 Piu 害怕巨大的声音，每次什么风吹草动都会吓得要死。小 Piu 害怕巨大的东西，我们的行李箱常常可以把它吓的到处逃窜。小 Piu 害怕我们生气，每次我们斥责它的时候它都会想逃到远处。小 Piu 曾经害怕从高处跳下来，但是她现在已经可以在床上和沙发上自由跳跃，可以上好几十个台阶了。小 Piu 怕疼。&lt;/p>
&lt;hr>
&lt;p>小 Piu 抱回家之后做体验，检查出体内有寄生虫，于是喂她吃驱虫药。在家呆了一段时候之后，患上了犬窝咳。带到医院做 CT，做雾化，吃抗生素，往返折腾近一个月才好。在犬窝咳好了一周后，我们带她打了最后一阵疫苗，观察数天后无异常，我们终于可以溜 Piu 了。&lt;/p>
&lt;p>2020/02/19，小 Piu 第一次出门。害怕的要死，外面什么味道都是陌生的，出了门就趴在地上一动不动，只想往家里跑。再三鼓励之后才终于开始朝前走，不敢上下楼梯，不敢过减速带，一路上都在查看别的狗留下的今日新闻，只读不回。&lt;/p>
&lt;p>2020/02/20，小 Piu 第二次出门，稍微勇敢了一些，出了门就开始拼命撺，嗅嗅这里，嗅嗅那里。&lt;/p>
&lt;p>2020/02/21，小 Piu 第一次在外面尿尿。当时我笑着说这下整个小区都知道这里来了一条超可爱的小母狗，我们要保护好她，不能被别的小公狗欺负了。小 Piu 会爬楼梯了，小 Piu 会超帅的跳过减速带了。&lt;/p>
&lt;p>2020/02/22，小 Piu 第一次在外面奔跑。我和女友骑着自行车，女友骑在右前方，我骑在后面牵着她，她一个劲儿的奔跑，跑了足足有三公里才开始缓缓减速。到家之后累的跟狗一样趴在地上疯狂喘气，没过多久就睡着了。&lt;/p>
&lt;p>2020/02/26，今天早晨六点带着小 Piu 去买早饭，回来的路上便不肯走路了。再三催促之后它在地上拉一托稀稀的屎，我们还感慨这是小 Piu 第一次在外面拉屎。&lt;/p>
&lt;p>回家之后小 Piu 仍然一副有气无力的样子，我们说好吃完早饭，九点等医院上班了带她去看看。但是情况急转直下，就在我洗碗的时候女友非常担心的找过来，说感觉小 Piu 状况不太好。我们找了一家还开着急诊的宠物医院，打车带她过去，在路上小 Piu 一直咳嗽，还发出了从来没有过的痛苦叫声。&lt;/p>
&lt;p>等到了医院的时候她已经开始咔血。医生看了就开始给吸氧，还跟我们说状况不太好，做好心理准备。我们给小 Piu 吸氧，我们给小 Piu 拍 CT，我们给小 Piu 打针，我们给小 Piu 加油。小 Piu 一直努力扭过头来看着我，认真的看着我，我摸摸她的头说小 Piu 乖，努力一下，我们马上就回家了。等小 Piu 把头转回去的时候她已经闭上了眼睛，医生连忙把她抱起来高喊手术室，将她带了进去。&lt;/p>
&lt;p>十几分钟之后，医生扭着头出来说不行了，在补宠物信息表的女朋友一脸茫然的问他，那我这个还要填么？医生摆了摆手，说不用了。我们跟着医生进了手术室，小 Piu 被蓝色的纸盖着，很安静，没有发出一点声音。医生在认真的给我们解释说死因是肺水肿，肺水肿分为心因性和非心因性等等，谁想知道这个啊，我们的小 Piu 怎么不看着我了？医生最后说尸体的处理方式有两种，一种是你们带回家，一种是医院这边直接联系火化，女朋友低声的说我们要带回家。打包好之后女朋友一直抱着，医生在整理账单，过了好一会儿还没好，女朋友问我，什么时候可以走啊，小 Piu 要回家了。&lt;/p>
&lt;p>到家之后我们打开了袋子，把小 Piu 擦的干干净净，把眼睛合上，把小舌头塞进嘴巴，把她最爱的玩具都放在了袋子里面。重新打包好之后送回了医院，让他们联系做集体火化，没有告别仪式，没有遗像，没有骨灰，只有房间散落的她换下来的狗牙。&lt;/p>
&lt;hr>
&lt;p>小 Piu 是一个快乐的 Piu，到了天堂可千万别被欺负了，我们在门前放了你最喜欢的地毯，有空的时候常回家看看吧，我保证再也不打你了。&lt;/p></description></item><item><title>2019 年度总结</title><link>https://xuanwo.io/2020/01/02/2019-review/</link><pubDate>Thu, 02 Jan 2020 01:00:00 +0000</pubDate><guid>https://xuanwo.io/2020/01/02/2019-review/</guid><description>&lt;p>虽然年度总结每年都在我的 Todo List 上面，但是我从来没有真正的写过年度总结。去年写过好多草稿，最后都删掉了，原因是写的过于具体会像流水帐，写的过于抽象又容易矫情。今年好不容易鼓起勇气再次尝试，希望能对得起过去的 2019。&lt;/p>
&lt;h2 id="living">Living&lt;/h2>
&lt;p>今年最大的变化就是有了女朋友，运气太好以至于难以相信灵魂伴侣能如此轻易的找到。努力的追了大半年，终于在年底的时候在一起了。我们官宣的文案是：“从横版过关变成塔防了。”跟她在一起的这段时间很累，但是非常开心非常充实。一起看了好多电影，一起看了好多美剧，一起深夜加班，一起凌晨漫步。饥荒玩的最久的世界已经满365 天了，过上了穿熊皮背心，拿步行手杖，提触手尖刺，喝肉汤吃大肉的幸福生活。晚上会打开 Just Dance 一起手舞足蹈，为每一次 Perfect 欢呼。最近一起养了一条狗子，名字叫阿Piu。&lt;/p>
&lt;p>&lt;img src="apiu.jpg" alt="">&lt;/p>
&lt;p>虽然她每天都叼着我的拖鞋到处跑，拉屎奇丑无比，还会尿在新买的地毯上，但是我们很爱她。&lt;/p>
&lt;p>有了女朋友对我来说意味着崭新人生阶段的开始，要接受另外一个人进入自己的生活，个人的独处和社交时间减少，双方的情绪也不可避免的互相影响，做任何决定都是双人份的压力和负担，要学会感知和体会他人的情感，肩上的责任也变得更重。这些对我来说都是全新的领域，我努力的在适应和调整，也感谢我的女朋友一贯以来的容忍和包容。但愿新的一年我们还是能够开开心心的在一起。&lt;/p>
&lt;p>其次就是朋友 P 离职。我在青云做的第一个正经项目就是他带我做的 QingStor SDK，之后是跟他一起做 Anybox 网盘项目。如果没有他言传身教的话，想必我至今还是一个市场部的乱搞脚本 Boy。他的离去使我感到孤独，少了一个想养猫而不得每天只能云吸猫，爱讲冷笑话，每天鼓吹微软大法好，在群里接我的各种冷门 Geek 梗的他让我倍感孤独。但是天下没有不散的宴席，再怎么志同道合也不可能一直在一起工作，希望他在 Serverless 的道路上越搞越好。&lt;/p>
&lt;h2 id="coding">Coding&lt;/h2>
&lt;p>今年明确了自己的职业方向：效率研发工程师，具体到工作上能分为团队，工程和用户几个方向。&lt;/p>
&lt;h3 id="团队">团队&lt;/h3>
&lt;p>团队的效率问题更多的是沟通问题，而沟通问题能划分为内部沟通和外部沟通，其中内部沟通最突出的问题是信息冗余，而外部沟通则恰好相反——信息不足。&lt;/p>
&lt;p>为了解决信息冗余的问题，我提出并构建了 QingStor Infrastructure 项目，将团队内部的所有服务和工具重新整理并通过容器化的方式来部署。设计并构建了 Info Center，通过 RESTful API 的方式对外暴露了团队内可公开的信息，包括每个人的联系方式，各个环境的信息，每个人归属的项目等。设计并指导团队成员 C 实现了 QingStor Robot，支持在 Skype 内获取每个人的信息，并实现每日的工单值班提醒功能。期间还提出过统一各个环境的命名方式和域名，进行版本化管理等，但是由于种种原因夭折了，此处不展开了。&lt;/p>
&lt;p>而外部沟通的信息不足则涉及到跟其他部门的沟通问题，具体到我需要解决的问题是工单值班的问题。青云的工单值班主要分为 L2 和 L3，L2 是服务团队 24 小时轮流值班的人员，他们会负责处理一些简单的常见问题，而复杂的技术问题则会交给每日值班的研发团队的同事。对于 QingStor 对象存储来说，问题的复杂性在于流程很长，从用户浏览器到网络到对象存储服务，每个流程都有可能出错。L2 工单的同事越来越倾向于将问题转发给研发同事，而不是自己解决。一方面是很多问题确实解决不了，另一方面是过去解决过的工单没有积累起来，不像 IaaS 有一个很大的数据库。为此，我跟 L2 服务团队的负责人沟通，推动建立起了全公司的工单库，将 QingStor 对象存储的工单也放在里面，期望能够开始积累起工单，减轻工单值班的压力。&lt;/p>
&lt;p>团队这个方向的工作不好做，尤其对于我来说，要跟很多陌生的人沟通， 需要耗费额外的精力，很多时候都会觉得麻烦不如自己直接搞一个。今年有努力克制这种欲望，包括工单库也是选择直接使用公司现有的 Confluence 而不是自建一个。有进步，没明显成效，虎头蛇尾，大概只能评个 6 分。&lt;/p>
&lt;h3 id="工程">工程&lt;/h3>
&lt;p>上半年的大多数时间都在琢磨如何提高工程效率。经过一段时间体验，我认为我们团队的工程效率短腿集中在两个地方：其一是依赖管理，其二是测试管理。&lt;/p>
&lt;p>我们团队用 Go 比较早，当时还没有完善的版本管理方案，我们的做法是自己写了个 Python 的脚本，直接 &lt;code>go get&lt;/code> 到本地，放在 &lt;code>GOPATH&lt;/code> 中。大家，尤其是新入职的同学要话很多时间来处理依赖问题。为了解决这个问题，我在 Go 1.11 发布后便开始推动大家使用 Go Modules，还进行过 &lt;a href="https://xuanwo.io/2019/05/27/go-modules/">Go Modules 内部分享&lt;/a>。为了解决大清国情的问题，我使用 &lt;a href="https://github.com/gomods/athens">athens&lt;/a> 搭建了团队内部的 Go Proxy，还开发了 &lt;a href="https://github.com/Xuanwo/go-mod-redirect">go-mod-redirect&lt;/a> 用来重定向我们的项目名。到目前为止，几乎还活着的 Golang 项目都已经切换到了 Go Modules 来管理依赖，为后续的 CI/CD 和可重现构建算是打了一个比较好的基础。&lt;/p>
&lt;p>为了能够更好的组织测试，避免一个环境一个 Jenkins 的现状，我在 QingStor Infrastructure 中搭建了一个 Jenkins 并推动大家使用 Pipeline 而不是脚本的方式来定义 CI 逻辑。理想很丰满，现实很骨感。这个计划在初次执行的时候就遇到了很大的问题：由于历史原因，项目缺乏真正的单元测试，想测试的话需要一整套的环境和各种组件才可以。如果想做到我期望的那种即创建即销毁的动态测试，我还需要一个服务编排系统，为此，我们期望可以上 K8S。当时 K8S 上没有一个优秀的测试平台，再加上我的兴趣点转移，所以这个也被暂缓了。&lt;/p>
&lt;p>工程效率第一次做，还算是有点成果，测试的事情推动到了一半，没有执行完，评个 7.5 分。&lt;/p>
&lt;h3 id="用户">用户&lt;/h3>
&lt;p>用户的效率提升也是我工作的重要组成部份，这也是我为什么一直在负责 QingStor 对象存储用户工具生态的原因：如果我们的服务不能提升用户的效率，那它毫无价值。&lt;/p>
&lt;p>到下半年的时候我被要求支持一下 qsctl 2 的开发工作，最开始只是希望我搭个框架，但是后来我的野心越来越大，除了想做 QingStor 迄今为止最好的命令行应用之外，还希望将 qsctl 2 的底层抽象为一套数据操作框架，这套框架将用于后续我们青云自己的 Data Sync 服务。所以我花了很多时间去设计这个抽象的数据操作框架，直到年底的时候才算基本完成，并从 qsctl 中剥离出来，命名为 &lt;a href="https://github.com/qingstor/noah">Noah&lt;/a>。2020 年 Q1 末的时候希望能够正式的向大家介绍它。&lt;/p>
&lt;p>在 11/07 时候 qsctl 2 发布了首个 Beta 版本，一个月后发布了第二个 Beta。整个开发持续了半年，期间另外一个小伙伴还需要负责公司的另外一个项目，感谢他的投入和支持。同样是 2020 年 Q1 末，我期望能向大家介绍 qsctl 2 的第一个稳定版。&lt;/p>
&lt;p>qscamel 支持了腾讯云对象存储这种小事就不展开了，期间还对接了一波 Ceph 的 S3，不支持 v4 的签名，不支持 v2 List Objects 带来了不少麻烦，好在都在用户的配合下解决了。明年 Noah 稳定后，可能会重构 qscamel 的底层，并优化 qscamel 的使用体验，期望能提升大家迁移数据时的效率。&lt;/p>
&lt;p>用户侧的效率提升从我进入 QingStor 团队的第一天开始就在做，今年感觉得到了足够的资源和支持，使得我能够大胆的实现我的想法，因此也给我自己大胆的评个 9 分，希望 19 年孕育的种子到 20 年能结果。&lt;/p>
&lt;h2 id="writing">Writing&lt;/h2>
&lt;p>今年博客写了 28 篇文章，其中 Code 分类 16 篇，Daily 分类 5 篇，Travel 分类 7 篇。上半年的时候集中写了一波旅游日志，下半年的时候技术相关的东西比较多。&lt;/p>
&lt;p>2019 年全年有 40732 名用户访问了我的博客，其中有 40584 名新用户，为我带来了 70026 次页面浏览。跟往年相比大概少了 10%， 每次访问停留时间减少了 17%，跳出率提高了 2%。这大概就是怠惰和写水文的惩罚吧（&lt;/p>
&lt;p>&lt;img src="pageview.png" alt="">&lt;/p>
&lt;p>2019 年，大家看的最多的还是我 2014 年到 2015 年写的几篇文章，这让我有些沮丧，并鞭策自己产出更好的内容。&lt;/p>
&lt;p>&lt;img src="page.png" alt="">&lt;/p>
&lt;p>此外还有一些有趣的数据，比如访问我博客的浏览器比例&lt;/p>
&lt;p>&lt;img src="browser.png" alt="">&lt;/p>
&lt;p>Chrome 不出意外的以 80%+ 的比例高居榜首，但是第三名的 UC 浏览器是为啥？Opera 跟 IE 打了个平手，看来确实凉了。&lt;/p>
&lt;p>&lt;em>以上数据均来自 Google 分析&lt;/em>&lt;/p>
&lt;hr>
&lt;p>明年继续加油，提前祝大家新年快乐～&lt;/p></description></item><item><title>面向应用的 Golang 抽象存储层介绍</title><link>https://xuanwo.io/2019/12/30/storage-intro/</link><pubDate>Mon, 30 Dec 2019 01:00:00 +0000</pubDate><guid>https://xuanwo.io/2019/12/30/storage-intro/</guid><description>&lt;p>&lt;a href="https://github.com/Xuanwo/storage">storage&lt;/a> 是一个面向应用的 Golang 统一存储层，其目标是生产级别就绪，高性能，无供应商锁定。目前支持 &lt;a href="https://docs.microsoft.com/en-us/azure/storage/blobs/">Azure Blob storage&lt;/a>，本地文件系统，&lt;a href="https://cloud.google.com/storage/">Google Cloud Storage&lt;/a>，&lt;a href="https://www.aliyun.com/product/oss">阿里云对象存储&lt;/a>，&lt;a href="https://www.qingcloud.com/products/qingstor/">QingStor 对象存储&lt;/a>，&lt;a href="https://aws.amazon.com/s3/">Amazon S3&lt;/a> 等多种存储后端。这个项目从 09/30 开始至今，做了刚刚好三个月，选在今天发布 &lt;a href="https://github.com/Xuanwo/storage/releases/tag/v0.5.0">v0.5.0&lt;/a>，一方面是想总结一下过去三个月的开发经历，展望一下黯淡残酷的未来，另一方面是实在按捺不住想跟大家分享一下的心情。本文首先会介绍 storage 这个项目的诞生，然后介绍项目与社区林林总总各种存储项目的不同，之后再介绍未来的开发计划，最后谈谈自己的一些小体会。&lt;/p>
&lt;h2 id="showtime">Showtime&lt;/h2>
&lt;p>在介绍 storage 的历史和设计之前，先看看 storage 用起来是什么样子吧。&lt;/p>
&lt;p>首先初始化一个服务：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">srv, store, err &lt;span style="color:#666">:=&lt;/span> coreutils.&lt;span style="color:#06287e">Open&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;qingstor://hmac:test_access_key:test_secret_key@https:qingstor.com:443/test_bucket_name&amp;#34;&lt;/span>)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
log.&lt;span style="color:#06287e">Fatalf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;service init failed: %v&amp;#34;&lt;/span>, err)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>srv&lt;/code> 是这个存储服务的 &lt;code>Servicer&lt;/code>，负责管理 &lt;code>Namespace&lt;/code>；&lt;code>store&lt;/code> 是这个存储服务的 &lt;code>Storager&lt;/code>，负责实际的存储交互。&lt;code>coreutils&lt;/code> 是 &lt;code>storage&lt;/code> 库提供的工具包，支持通过统一的配置字符串来创建存储服务。&lt;/p>
&lt;p>然后使用这个服务来列取一个目录并发送到通道：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">ch &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#007020">make&lt;/span>(&lt;span style="color:#007020;font-weight:bold">chan&lt;/span> &lt;span style="color:#666">*&lt;/span>types.Object, &lt;span style="color:#40a070">1&lt;/span>)
&lt;span style="color:#007020;font-weight:bold">defer&lt;/span> &lt;span style="color:#007020">close&lt;/span>(ch)
err &lt;span style="color:#666">:=&lt;/span> store.&lt;span style="color:#06287e">ListDir&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;prefix&amp;#34;&lt;/span>, pairs.&lt;span style="color:#06287e">WithFileFunc&lt;/span>(&lt;span style="color:#007020;font-weight:bold">func&lt;/span>(&lt;span style="color:#666">*&lt;/span>types.Object){
ch &lt;span style="color:#666">&amp;lt;-&lt;/span> o
}))
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
log.&lt;span style="color:#06287e">Fatalf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;listdir: %v&amp;#34;&lt;/span>, err)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>pairs&lt;/code> 是 &lt;code>storage&lt;/code> 库提供的参数包，提供了能用在各个 API 接口的强类型参数，风格统一为 &lt;code>pairs.WithXXX&lt;/code>。&lt;/p>
&lt;p>从本地读取文件并上传到 QingStor 对象存储可以这样：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">_, src, _ &lt;span style="color:#666">:=&lt;/span> coreutils.&lt;span style="color:#06287e">Open&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;fs:///path&amp;#34;&lt;/span>)
_, dst, _ &lt;span style="color:#666">:=&lt;/span> coreutils.&lt;span style="color:#06287e">Open&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;qingstor://hmac:test_access_key:test_secret_key@https:qingstor.com:443/test_bucket_name&amp;#34;&lt;/span>)
r, err &lt;span style="color:#666">:=&lt;/span> src.&lt;span style="color:#06287e">Read&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;test_file&amp;#34;&lt;/span>)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
log.&lt;span style="color:#06287e">Fatalf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;read from src: %v&amp;#34;&lt;/span>, err)
}
&lt;span style="color:#007020;font-weight:bold">defer&lt;/span> r.&lt;span style="color:#06287e">Close&lt;/span>()
err = dst.&lt;span style="color:#06287e">Write&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;test_key&amp;#34;&lt;/span>, r, pairs.&lt;span style="color:#06287e">WithSize&lt;/span>(&lt;span style="color:#40a070">1024&lt;/span>))
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
log.&lt;span style="color:#06287e">Fatalf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;read from src: %v&amp;#34;&lt;/span>, err)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 Storager 初始化完毕后，就不再需要关心业务无关的底层存储细节，可以轻松的开发出需要持久化数据的无供应商锁定应用。&lt;/p>
&lt;h2 id="诞生">诞生&lt;/h2>
&lt;p>接下来聊一聊 &lt;code>storage&lt;/code> 库的由来。&lt;/p>
&lt;p>时间倒转到 2018 年初，我们对象存储的周边工具遇到了挑战：有个私有云用户需要迁移数十 TB 的数据到对象存储。当时可用的工具只有 python 写成的 qsctl，所有状态都存储在内存中，一旦出现任务中断就需要从头开始，用户意见很大。为此，我在一次内部会议上提出我们需要一个全新的工具，这个工具会专注于长时间的数据迁移操作，支持断点续传，支持持久化任务状态。由于原本的 qscamel 1.0 设计目标与之接近，所以沿用 qscamel 项目名，开发出了 &lt;a href="https://xuanwo.io/2018/09/05/qscamel-intro/">qscamel 2.0&lt;/a>。&lt;/p>
&lt;p>在 qscamel 2.0 中，我设计出了这样一套接口：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#60a0b0;font-style:italic">// Base is the interface that both Source and Destination should implement.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">type&lt;/span> Base &lt;span style="color:#007020;font-weight:bold">interface&lt;/span> {
&lt;span style="color:#60a0b0;font-style:italic">// Name will return the endpoint&amp;#39;s name.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">Name&lt;/span>(ctx context.Context) (name &lt;span style="color:#902000">string&lt;/span>)
&lt;span style="color:#60a0b0;font-style:italic">// Stat will get the metadata.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">Stat&lt;/span>(ctx context.Context, p &lt;span style="color:#902000">string&lt;/span>) (o &lt;span style="color:#666">*&lt;/span>model.SingleObject, err &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#60a0b0;font-style:italic">// Read will return a reader.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">Read&lt;/span>(ctx context.Context, p &lt;span style="color:#902000">string&lt;/span>) (r io.Reader, err &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#60a0b0;font-style:italic">// ReadRange will read content with range [offset, offset+size)
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">ReadRange&lt;/span>(ctx context.Context, p &lt;span style="color:#902000">string&lt;/span>, offset, size &lt;span style="color:#902000">int64&lt;/span>) (r io.Reader, err &lt;span style="color:#902000">error&lt;/span>)
}
&lt;span style="color:#60a0b0;font-style:italic">// Destination is the interface for destination endpoint.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">type&lt;/span> Destination &lt;span style="color:#007020;font-weight:bold">interface&lt;/span> {
Base
&lt;span style="color:#60a0b0;font-style:italic">// Delete will use endpoint to delete the path.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">Delete&lt;/span>(ctx context.Context, p &lt;span style="color:#902000">string&lt;/span>) (err &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#60a0b0;font-style:italic">// Deletable will return whether current endpoint supports delete.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">Deletable&lt;/span>() &lt;span style="color:#902000">bool&lt;/span>
&lt;span style="color:#60a0b0;font-style:italic">// Fetch will use endpoint to fetch the url.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">Fetch&lt;/span>(ctx context.Context, path, url &lt;span style="color:#902000">string&lt;/span>) (err &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#60a0b0;font-style:italic">// Fetchable will return whether current endpoint supports fetch.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">Fetchable&lt;/span>() &lt;span style="color:#902000">bool&lt;/span>
&lt;span style="color:#60a0b0;font-style:italic">// InitPart will inti a multipart upload.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">InitPart&lt;/span>(ctx context.Context, p &lt;span style="color:#902000">string&lt;/span>, size &lt;span style="color:#902000">int64&lt;/span>) (uploadID &lt;span style="color:#902000">string&lt;/span>, partSize &lt;span style="color:#902000">int64&lt;/span>, partNumbers &lt;span style="color:#902000">int&lt;/span>, err &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#60a0b0;font-style:italic">// UploadPart will upload a part.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">UploadPart&lt;/span>(ctx context.Context, o &lt;span style="color:#666">*&lt;/span>model.PartialObject, r io.Reader) (err &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#60a0b0;font-style:italic">// Partable will return whether current endpoint supports multipart upload.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">Partable&lt;/span>() &lt;span style="color:#902000">bool&lt;/span>
&lt;span style="color:#60a0b0;font-style:italic">// Write will read data from the reader and write to endpoint.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">Write&lt;/span>(ctx context.Context, path &lt;span style="color:#902000">string&lt;/span>, size &lt;span style="color:#902000">int64&lt;/span>, r io.Reader) (err &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#60a0b0;font-style:italic">// Writable will return whether current endpoint supports write.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">Writable&lt;/span>() &lt;span style="color:#902000">bool&lt;/span>
}
&lt;span style="color:#60a0b0;font-style:italic">// Source is the interface for source endpoint.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">type&lt;/span> Source &lt;span style="color:#007020;font-weight:bold">interface&lt;/span> {
Base
&lt;span style="color:#60a0b0;font-style:italic">// List will list from the job.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">List&lt;/span>(ctx context.Context, j &lt;span style="color:#666">*&lt;/span>model.DirectoryObject, fn &lt;span style="color:#007020;font-weight:bold">func&lt;/span>(model.Object)) (err &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#60a0b0;font-style:italic">// Reach will return an accessible url.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">Reach&lt;/span>(ctx context.Context, p &lt;span style="color:#902000">string&lt;/span>) (url &lt;span style="color:#902000">string&lt;/span>, err &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#60a0b0;font-style:italic">// Reachable will return whether current endpoint supports reach.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">Reachable&lt;/span>() &lt;span style="color:#902000">bool&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这套接口是面向迁移任务设计的，虽然不是非常优雅，但是工作的很好，一直沿用至今。qscamel 基于这套接口提供了本地文件系统，QingStor 对象存储，阿里云 OSS，Google Cloud Storage，七牛对象存储，S3，又拍云，腾讯云对象存储等多家主流存储服务的支持。&lt;/p>
&lt;p>qscamel 2.0 中是我第一次尝试统一存储层的接口，受限于个人的能力和时间的要求，选择的方案是只实现任务要求操作的部分 API。这套接口完全没有复用的价值，它离开特定业务场景就失去了生命力。在之后的很长一段时间里面，我常常会想到这套接口——有没有可能提供一个抽象的统一的现代的存储层呢？&lt;/p>
&lt;p>在 &lt;a href="https://xuanwo.io/2019/11/10/go-template-meta-coding-in-qsctl2/">Go 模板元编程及其在 qsctl 中的实践&lt;/a> 中我介绍了一部分 qsctl 2 中所做的工作，当时刻意忽略了存储层的部分。实际上，如果没有一个统一的存储层，我们是无法抽象出一个好的任务框架的，以初始化分段为例：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#062873;font-weight:bold">&amp;#34;SegmentInit&amp;#34;&lt;/span>: {
&lt;span style="color:#062873;font-weight:bold">&amp;#34;description&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;init a segment upload&amp;#34;&lt;/span>,
&lt;span style="color:#062873;font-weight:bold">&amp;#34;input&amp;#34;&lt;/span>: [
&lt;span style="color:#4070a0">&amp;#34;PartSize&amp;#34;&lt;/span>,
&lt;span style="color:#4070a0">&amp;#34;Path&amp;#34;&lt;/span>,
&lt;span style="color:#4070a0">&amp;#34;Storage&amp;#34;&lt;/span>
],
&lt;span style="color:#062873;font-weight:bold">&amp;#34;output&amp;#34;&lt;/span>: [
&lt;span style="color:#4070a0">&amp;#34;SegmentID&amp;#34;&lt;/span>
]
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的 &lt;code>Storage&lt;/code> 实际上就是由 storage 库提供的抽象，上层任务不需要关心这个 &lt;code>Storage&lt;/code> 底层到底是文件存储还是 QingStor 对象存储，抑或是 S3。这层抽象将 &lt;code>fs-&amp;gt;qingstor&lt;/code>，&lt;code>qingstor-&amp;gt;fs&lt;/code> 简化为了 &lt;code>src-&amp;gt;dst&lt;/code>，减少了大量的重复任务。&lt;/p>
&lt;p>在 qsctl 2 开发的初期其实并没有考虑要做一个通用的存储层，当时是直接写死的本地存储和对象存储。但是开发进入到后期，我们遇到了两个问题。一是单元测试不好做，大量的单测都依赖于本地存储和对象存储的行为；二是有大量重复的任务，比如从本地复制到对象存储，从对象存储复制到本地，里面大部分逻辑都是相似但无法直接复用代码的。为此，我重新审视了统一存储层接口的想法，距离我上次尝试已经过去了一年多，我变强了，头发也变得更少了，是时候再试试了。&lt;/p>
&lt;h2 id="区别">区别&lt;/h2>
&lt;blockquote>
&lt;p>漩涡啊，你怎么又造轮子了？&lt;/p>
&lt;p>我认为造轮子分两种：一种是学东西，另一种是拿来用。在市场上已经有类似库的情况下造轮子，要么就是想出名，要么就是别的轮子不太圆，两种想法我都有。&lt;/p>
&lt;/blockquote>
&lt;p>Golang 社区中类似的库有如下几个：&lt;a href="https://github.com/spf13/afero">Afero&lt;/a>，&lt;a href="https://github.com/viant/afs">afs&lt;/a>，&lt;a href="https://github.com/C2FO/vfs">vfs&lt;/a>，此外再加上与 POSIX file API 做对比。&lt;/p>
&lt;h3 id="afero">Afero&lt;/h3>
&lt;p>Afero 目标更接近于成为 &lt;code>os&lt;/code> 和 &lt;code>ioutil&lt;/code> 包的补充，尽可能的提供类似体验，并支持更多便利的函数。&lt;/p>
&lt;p>为各个底层的文件系统提供相似的函数：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#06287e">Chmod&lt;/span>(name &lt;span style="color:#902000">string&lt;/span>, mode os.FileMode) : &lt;span style="color:#902000">error&lt;/span>
&lt;span style="color:#06287e">Chtimes&lt;/span>(name &lt;span style="color:#902000">string&lt;/span>, atime time.Time, mtime time.Time) : &lt;span style="color:#902000">error&lt;/span>
&lt;span style="color:#06287e">Create&lt;/span>(name &lt;span style="color:#902000">string&lt;/span>) : File, &lt;span style="color:#902000">error&lt;/span>
&lt;span style="color:#06287e">Mkdir&lt;/span>(name &lt;span style="color:#902000">string&lt;/span>, perm os.FileMode) : &lt;span style="color:#902000">error&lt;/span>
&lt;span style="color:#06287e">MkdirAll&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>, perm os.FileMode) : &lt;span style="color:#902000">error&lt;/span>
&lt;span style="color:#06287e">Name&lt;/span>() : &lt;span style="color:#902000">string&lt;/span>
&lt;span style="color:#06287e">Open&lt;/span>(name &lt;span style="color:#902000">string&lt;/span>) : File, &lt;span style="color:#902000">error&lt;/span>
&lt;span style="color:#06287e">OpenFile&lt;/span>(name &lt;span style="color:#902000">string&lt;/span>, flag &lt;span style="color:#902000">int&lt;/span>, perm os.FileMode) : File, &lt;span style="color:#902000">error&lt;/span>
&lt;span style="color:#06287e">Remove&lt;/span>(name &lt;span style="color:#902000">string&lt;/span>) : &lt;span style="color:#902000">error&lt;/span>
&lt;span style="color:#06287e">RemoveAll&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>) : &lt;span style="color:#902000">error&lt;/span>
&lt;span style="color:#06287e">Rename&lt;/span>(oldname, newname &lt;span style="color:#902000">string&lt;/span>) : &lt;span style="color:#902000">error&lt;/span>
&lt;span style="color:#06287e">Stat&lt;/span>(name &lt;span style="color:#902000">string&lt;/span>) : os.FileInfo, &lt;span style="color:#902000">error&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>暴露出与原生库相似的接口：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">io.Closer
io.Reader
io.ReaderAt
io.Seeker
io.Writer
io.WriterAt
&lt;span style="color:#06287e">Name&lt;/span>() : &lt;span style="color:#902000">string&lt;/span>
&lt;span style="color:#06287e">Readdir&lt;/span>(count &lt;span style="color:#902000">int&lt;/span>) : []os.FileInfo, &lt;span style="color:#902000">error&lt;/span>
&lt;span style="color:#06287e">Readdirnames&lt;/span>(n &lt;span style="color:#902000">int&lt;/span>) : []&lt;span style="color:#902000">string&lt;/span>, &lt;span style="color:#902000">error&lt;/span>
&lt;span style="color:#06287e">Stat&lt;/span>() : os.FileInfo, &lt;span style="color:#902000">error&lt;/span>
&lt;span style="color:#06287e">Sync&lt;/span>() : &lt;span style="color:#902000">error&lt;/span>
&lt;span style="color:#06287e">Truncate&lt;/span>(size &lt;span style="color:#902000">int64&lt;/span>) : &lt;span style="color:#902000">error&lt;/span>
&lt;span style="color:#06287e">WriteString&lt;/span>(s &lt;span style="color:#902000">string&lt;/span>) : ret &lt;span style="color:#902000">int&lt;/span>, err &lt;span style="color:#902000">error&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>提供更多的帮助函数：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#06287e">DirExists&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>) (&lt;span style="color:#902000">bool&lt;/span>, &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#06287e">Exists&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>) (&lt;span style="color:#902000">bool&lt;/span>, &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#06287e">FileContainsBytes&lt;/span>(filename &lt;span style="color:#902000">string&lt;/span>, subslice []&lt;span style="color:#902000">byte&lt;/span>) (&lt;span style="color:#902000">bool&lt;/span>, &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#06287e">GetTempDir&lt;/span>(subPath &lt;span style="color:#902000">string&lt;/span>) &lt;span style="color:#902000">string&lt;/span>
&lt;span style="color:#06287e">IsDir&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>) (&lt;span style="color:#902000">bool&lt;/span>, &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#06287e">IsEmpty&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>) (&lt;span style="color:#902000">bool&lt;/span>, &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#06287e">ReadDir&lt;/span>(dirname &lt;span style="color:#902000">string&lt;/span>) ([]os.FileInfo, &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#06287e">ReadFile&lt;/span>(filename &lt;span style="color:#902000">string&lt;/span>) ([]&lt;span style="color:#902000">byte&lt;/span>, &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#06287e">SafeWriteReader&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>, r io.Reader) (err &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#06287e">TempDir&lt;/span>(dir, prefix &lt;span style="color:#902000">string&lt;/span>) (name &lt;span style="color:#902000">string&lt;/span>, err &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#06287e">TempFile&lt;/span>(dir, prefix &lt;span style="color:#902000">string&lt;/span>) (f File, err &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#06287e">Walk&lt;/span>(root &lt;span style="color:#902000">string&lt;/span>, walkFn filepath.WalkFunc) &lt;span style="color:#902000">error&lt;/span>
&lt;span style="color:#06287e">WriteFile&lt;/span>(filename &lt;span style="color:#902000">string&lt;/span>, data []&lt;span style="color:#902000">byte&lt;/span>, perm os.FileMode) &lt;span style="color:#902000">error&lt;/span>
&lt;span style="color:#06287e">WriteReader&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>, r io.Reader) (err &lt;span style="color:#902000">error&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我认为 Afero 的目标不是一个统一的存储层，而是一个统一的文件系统操作集。同时，受限于它的接口设计，它很难对接好 S3 这样的对象存储服务。&lt;/p>
&lt;h2 id="afs">afs&lt;/h2>
&lt;p>AFS 的目标跟我非常接近了：abstract file storage，从提供的 API 可见一斑：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#06287e">List&lt;/span>(ctx context.Context, URL &lt;span style="color:#902000">string&lt;/span>, options &lt;span style="color:#666">...&lt;/span>Option) ([]Object, &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#06287e">Walk&lt;/span>(ctx context.Context, URL &lt;span style="color:#902000">string&lt;/span>, handler OnVisit, options &lt;span style="color:#666">...&lt;/span>Option) &lt;span style="color:#902000">error&lt;/span>
&lt;span style="color:#06287e">Download&lt;/span>(ctx context.Context, object Object, options &lt;span style="color:#666">...&lt;/span>Option) (io.ReadCloser, &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#06287e">DownloadWithURL&lt;/span>(ctx context.Context, URL &lt;span style="color:#902000">string&lt;/span>, options &lt;span style="color:#666">...&lt;/span>Option) (io.ReadCloser, &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#06287e">Upload&lt;/span>(ctx context.Context, URL &lt;span style="color:#902000">string&lt;/span>, mode os.FileMode, reader io.Reader, options &lt;span style="color:#666">...&lt;/span>Option) &lt;span style="color:#902000">error&lt;/span>
&lt;span style="color:#06287e">Create&lt;/span>(ctx context.Context, URL &lt;span style="color:#902000">string&lt;/span>, mode os.FileMode, isContainer &lt;span style="color:#902000">bool&lt;/span>, options &lt;span style="color:#666">...&lt;/span>Option) &lt;span style="color:#902000">error&lt;/span>
&lt;span style="color:#06287e">Delete&lt;/span>(ctx context.Context, URL &lt;span style="color:#902000">string&lt;/span>, options &lt;span style="color:#666">...&lt;/span>Option) &lt;span style="color:#902000">error&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是在具体的实现上，我跟他的想法有很多不一致的地方：&lt;/p>
&lt;ul>
&lt;li>统一的存储层应该支持 Bucket/Namespace/Container 的操作&lt;/li>
&lt;li>统一的存储层不应该加入太多的高级功能，比如 Modifier，Matcher 和 Batch&lt;/li>
&lt;li>统一的存储层应该抛弃本地优先的思想，将 FileMode 作为本地存储的 metadata 之一而不是规范之一&lt;/li>
&lt;/ul>
&lt;p>所以 afs 很好，但仍然不是我想要的。&lt;/p>
&lt;h2 id="vfs">vfs&lt;/h2>
&lt;p>vfs 与 afs 的思路是相似的：&lt;em>vfs provides a pluggable, extensible, and opinionated set of file system functionality for Go across a number of file system types such as os, S3, and GCS&lt;/em>&lt;/p>
&lt;p>但是不要 vfs 的原因与 afs 是相似的，他们提供了这样的接口：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#60a0b0;font-style:italic">// CopyToLocation will copy the current file to the provided location.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#06287e">CopyToLocation&lt;/span>(location Location) (File, &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#60a0b0;font-style:italic">// CopyToFile will copy the current file to the provided file instance.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#06287e">CopyToFile&lt;/span>(file File) &lt;span style="color:#902000">error&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>想必这样的设计有他们内部业务的考量，但是作为一个通用的存储层，我们不需要实现跨存储服务的 Copy 和 Move，它们应当构建在存储层之上。&lt;/p>
&lt;h3 id="posix-file-api">POSIX File API&lt;/h3>
&lt;p>设计存储层当然绕不过 &lt;code>POSIX File API&lt;/code>，下面是 storage 库对 &lt;code>POSIX File API&lt;/code> 的对比情况：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>介绍&lt;/th>
&lt;th>storage&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>getcwd&lt;/td>
&lt;td>get current working directory&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>mkdir&lt;/td>
&lt;td>create a directory&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>rmdir&lt;/td>
&lt;td>delete a directory&lt;/td>
&lt;td>Y: Delete&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>chdir&lt;/td>
&lt;td>change working directory&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>link&lt;/td>
&lt;td>make a new name for a file&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>unlink&lt;/td>
&lt;td>delete a name and possibly the file it refers to&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>rename&lt;/td>
&lt;td>change the name or location of a file&lt;/td>
&lt;td>Y: Move&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>stat&lt;/td>
&lt;td>get file status&lt;/td>
&lt;td>Y: Stat&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>chmod&lt;/td>
&lt;td>change permissions of a file&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>chown&lt;/td>
&lt;td>change ownership of a file&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>utime&lt;/td>
&lt;td>change access and/or modification times of an inode&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>opendir&lt;/td>
&lt;td>open a directory&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>readdir&lt;/td>
&lt;td>read directory entry&lt;/td>
&lt;td>Y: ListDir&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>closedir&lt;/td>
&lt;td>close a directory&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>rewinddir&lt;/td>
&lt;td>reset directory stream&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>access&lt;/td>
&lt;td>check user&amp;rsquo;s permissions for a file&lt;/td>
&lt;td>Y: Stat&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>open&lt;/td>
&lt;td>open and possibly create a file or device&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>creat&lt;/td>
&lt;td>open and possibly create a file or device&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>close&lt;/td>
&lt;td>close a file descriptor&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>read&lt;/td>
&lt;td>read from a file descriptor&lt;/td>
&lt;td>Y: Read&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>write&lt;/td>
&lt;td>write to a file descriptor&lt;/td>
&lt;td>Y: Write&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>fcntl&lt;/td>
&lt;td>manipulate file descriptor&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>fstat&lt;/td>
&lt;td>get file status&lt;/td>
&lt;td>Y: Stat&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>lseek&lt;/td>
&lt;td>reposition read/write file offset&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>dup&lt;/td>
&lt;td>duplicate a file descriptor&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>dup2&lt;/td>
&lt;td>duplicate a file descriptor&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>pipe&lt;/td>
&lt;td>create pipe&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>mkfifo&lt;/td>
&lt;td>make a FIFO special file (a named pipe)&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>umask&lt;/td>
&lt;td>set file creation mask&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>fdopen&lt;/td>
&lt;td>associate a stream with an existing file descriptor&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>fileno&lt;/td>
&lt;td>return file descriptor of stream&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>storage 不支持切换工作路径，Storager 的 WorkDir 参数需要在初始化的时候指定，因此不需要 &lt;code>getcwd&lt;/code> 和 &lt;code>chdir&lt;/code>&lt;/li>
&lt;li>storage 中文件夹的概念得到了相对的弱化，大多数存储服务中不提供对文件夹的操作，本地文件系统则会在 &lt;code>Write&lt;/code> 调用是自动创建，因此去掉了 &lt;code>mkdir&lt;/code>&lt;/li>
&lt;li>storage 没有链接文件的概念，因此没有 &lt;code>link&lt;/code> 和 &lt;code>unlink&lt;/code>&lt;/li>
&lt;li>在 storage 中，权限，所有权，创建/修改时间等属性都被视作元数据，因此会放到统一的元数据操作 API 中，不再需要 &lt;code>chmod&lt;/code>，&lt;code>chown&lt;/code>，&lt;code>utime&lt;/code> 等 API&lt;/li>
&lt;li>storage 对外屏蔽了内部的读写细节，不再暴露文件描述符，因此外部程序不再需要显式的打开和关闭文件，它们只需要处理数据，不再需要 &lt;code>opendir&lt;/code>，&lt;code>closedir&lt;/code>，&lt;code>rewinddir&lt;/code>，&lt;code>open&lt;/code>，&lt;code>close&lt;/code>，&lt;code>fcntl&lt;/code>，&lt;code>dup&lt;/code>，&lt;code>dup2&lt;/code>，&lt;code>fdopen&lt;/code>，&lt;code>fileno&lt;/code> 等一系列 API&lt;/li>
&lt;li>在 storage 中，&lt;code>create&lt;/code> 等价于 &lt;code>Write&lt;/code> 一个 0 字节的文件，因此不再需要独立的 &lt;code>create&lt;/code> 接口&lt;/li>
&lt;li>storage 支持在 &lt;code>Read&lt;/code> 和 &lt;code>Write&lt;/code> 的时候传递 Offset，因此不再需要 &lt;code>lseek&lt;/code> 接口&lt;/li>
&lt;li>一些操作系统相关的操作 storage 均不予支持，包括 &lt;code>pipe&lt;/code>，&lt;code>mkfifo&lt;/code>，&lt;code>umask&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="设计">设计&lt;/h2>
&lt;p>前面聊过了历史， 也聊过了竞品，下面该讲讲我心目中的存储层了。&lt;/p>
&lt;p>一个好的面向应用的抽象存储层该是什么样子呢？&lt;/p>
&lt;ul>
&lt;li>忽略无关细节：应用不需要关注打开关闭文件描述符这些底层细节&lt;/li>
&lt;li>去除历史包袱：不需要提供管道这种现代应用很少用到的功能&lt;/li>
&lt;li>众存储平等：避免本地存储优先思想，API 接口不依赖已有的 File 和 FileMode 等结构&lt;/li>
&lt;li>少即是多：提供机制而不是策略，给用户写高级功能的能力，而不是直接提供类似 Matcher 这样的功能&lt;/li>
&lt;li>专注于单一存储层：跨存储层的操作交给上层应用实现&lt;/li>
&lt;/ul>
&lt;p>在开始写 storage 的时候，我拍脑袋定了三个目标：&lt;/p>
&lt;ul>
&lt;li>Production ready：这个库需要靠谱，要稳定，要有单元测试，不能随意的引入破坏性变更，不能随意的修改函数及其参数的语意，要开发者友好&lt;/li>
&lt;li>High performance：（尽可能的）高性能，一方面是运行效率高，另一方面是开发效率。接口不要太慢，关键路径上不要有过多的封装；接口设计要友好，避免引入过多的新概念，让开发者能快速上手，快速使用&lt;/li>
&lt;li>Vendor lock free：要做一个真正的统一存储层，要尽可能屏蔽各个存储服务业务无关的细节，减少用户迁移存储时的阻力&lt;/li>
&lt;/ul>
&lt;p>除了 High performance 目前还没有实际的 Benchmark 外，其他两个目标都算是完成了一大半，下面简单介绍一下。&lt;/p>
&lt;h3 id="初始化">初始化&lt;/h3>
&lt;p>初始化是使用任何服务的第一步，作为一个通用存储层当然也需要相关的设计，在提案 &lt;a href="https://github.com/Xuanwo/storage/blob/master/docs/design/3-support-service-init-via-config-string.md">3. Support service init via config string&lt;/a> 中我提出了一套基于字符串的配置方式：&lt;/p>
&lt;pre>&lt;code>&amp;lt;type&amp;gt;://&amp;lt;config&amp;gt;
+
|
v
&amp;lt;credential&amp;gt;@&amp;lt;endpoint&amp;gt;/&amp;lt;namespace&amp;gt;?&amp;lt;options&amp;gt;
+ + +
| +---------+ +----------------------+
v v v
&amp;lt;protocol&amp;gt;:&amp;lt;data&amp;gt; &amp;lt;protocol&amp;gt;:&amp;lt;data&amp;gt; &amp;lt;key&amp;gt;:&amp;lt;value&amp;gt;[&amp;amp;&amp;lt;key&amp;gt;:&amp;lt;value&amp;gt;]
&lt;/code>&lt;/pre>&lt;p>比如 QingStor 是：&lt;/p>
&lt;pre>&lt;code>qingstor://hmac:&amp;lt;access_key_id&amp;gt;:&amp;lt;secret_access_key&amp;gt;@https:qingstor.com:443/&amp;lt;bucket_name&amp;gt;/&amp;lt;prefix&amp;gt;?zone=pek3b
&lt;/code>&lt;/pre>&lt;p>而初始化本地文件系统是：&lt;/p>
&lt;pre>&lt;code>fs:///&amp;lt;work_dir&amp;gt;
&lt;/code>&lt;/pre>&lt;p>不同服务的配置串会在文档中制定。&lt;/p>
&lt;p>实际的初始化体验形如：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">srv, store, err &lt;span style="color:#666">:=&lt;/span> coreutils.&lt;span style="color:#06287e">Open&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;qingstor://hmac:test_access_key:test_secret_key@https:qingstor.com:443/test_bucket_name&amp;#34;&lt;/span>)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
log.&lt;span style="color:#06287e">Fatalf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;service init failed: %v&amp;#34;&lt;/span>, err)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="接口设计">接口设计&lt;/h3>
&lt;p>大多数存储服务都会有两级甚至更多层次，我将他们分为两层，一层负责实际的存储操作，叫做 Storager，另一层负责处理 Namespace 管理。对大多数对象存储服务来说，就是 Bucket 的管理，特别的，本地文件系统没有实现 Servier 接口。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">type&lt;/span> Servicer &lt;span style="color:#007020;font-weight:bold">interface&lt;/span> {
&lt;span style="color:#60a0b0;font-style:italic">// String will implement Stringer.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">String&lt;/span>() &lt;span style="color:#902000">string&lt;/span>
&lt;span style="color:#60a0b0;font-style:italic">// List will list all storager instances under this service.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">List&lt;/span>(pairs &lt;span style="color:#666">...*&lt;/span>types.Pair) (err &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#60a0b0;font-style:italic">// Get will get a valid storager instance for service.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">Get&lt;/span>(name &lt;span style="color:#902000">string&lt;/span>, pairs &lt;span style="color:#666">...*&lt;/span>types.Pair) (Storager, &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#60a0b0;font-style:italic">// Create will create a new storager instance.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">Create&lt;/span>(name &lt;span style="color:#902000">string&lt;/span>, pairs &lt;span style="color:#666">...*&lt;/span>types.Pair) (Storager, &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#60a0b0;font-style:italic">// Delete will delete a storager instance.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#06287e">Delete&lt;/span>(name &lt;span style="color:#902000">string&lt;/span>, pairs &lt;span style="color:#666">...*&lt;/span>types.Pair) (err &lt;span style="color:#902000">error&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Storager 负责所有实际的存储操作，经过各个版本的演化，现在相对稳定的接口形态是这样的：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">type&lt;/span> Storager &lt;span style="color:#007020;font-weight:bold">interface&lt;/span> {
&lt;span style="color:#06287e">String&lt;/span>() &lt;span style="color:#902000">string&lt;/span>
&lt;span style="color:#06287e">Init&lt;/span>(pairs &lt;span style="color:#666">...*&lt;/span>types.Pair) (err &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#06287e">Metadata&lt;/span>() (m metadata.Storage, err &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#06287e">ListDir&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>, pairs &lt;span style="color:#666">...*&lt;/span>types.Pair) (err &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#06287e">Read&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>, pairs &lt;span style="color:#666">...*&lt;/span>types.Pair) (r io.ReadCloser, err &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#06287e">Write&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>, r io.Reader, pairs &lt;span style="color:#666">...*&lt;/span>types.Pair) (err &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#06287e">Stat&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>, pairs &lt;span style="color:#666">...*&lt;/span>types.Pair) (o &lt;span style="color:#666">*&lt;/span>types.Object, err &lt;span style="color:#902000">error&lt;/span>)
&lt;span style="color:#06287e">Delete&lt;/span>(path &lt;span style="color:#902000">string&lt;/span>, pairs &lt;span style="color:#666">...*&lt;/span>types.Pair) (err &lt;span style="color:#902000">error&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此外，在提案 &lt;a href="https://github.com/Xuanwo/storage/blob/master/docs/design/1-unify-storager-behavior.md">1. Unify storager behavior&lt;/a> 中，我给出了支持更多高级操作的方案：将这些操作拆分为其他的 interface，并在实际使用的时候进行转换。相关的技术考量在提案中都已经描述过，这里就不赘述了。在 Storager 之外，存储服务还能够支持复制（Copier），移动（Mover），获取公开访问链接（Reacher），获取数据统计（Statistician），分段上传（Segmenter）等功能。&lt;/p>
&lt;p>一个经常出现分歧的点在于 ListDir 这样的操作中如何返回 item，之前的方案是传递一个递归参数，但是在提案 &lt;a href="https://github.com/Xuanwo/storage/blob/master/docs/design/2-use-callback-in-list-operations.md">2. Use callback in List operations&lt;/a> 中，我决定使用 callback 的方式：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">dirFunc &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#007020;font-weight:bold">func&lt;/span>(object &lt;span style="color:#666">*&lt;/span>types.Object) {
&lt;span style="color:#06287e">printf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;dir %s&amp;#34;&lt;/span>, object.Name)
}
fileFunc &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#007020;font-weight:bold">func&lt;/span>(object &lt;span style="color:#666">*&lt;/span>types.Object) {
&lt;span style="color:#06287e">printf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;file %s&amp;#34;&lt;/span>, object.Name)
}
err &lt;span style="color:#666">:=&lt;/span> store.&lt;span style="color:#06287e">ListDir&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;prefix&amp;#34;&lt;/span>, types.&lt;span style="color:#06287e">WithDirFunc&lt;/span>(dirFunc), types.&lt;span style="color:#06287e">WithFileFunc&lt;/span>(fileFunc))
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> err
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>有一个没有被文档化的设计是接口中几乎每个函数都有的 &lt;code>types.Pair&lt;/code>，这个设计的比较早，在 v0.1.0 中就已经引入，至今变化不大。&lt;code>Pair&lt;/code> 是一个简单的 K-V 结构体：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">type&lt;/span> Pair &lt;span style="color:#007020;font-weight:bold">struct&lt;/span> {
Key &lt;span style="color:#902000">string&lt;/span>
Value &lt;span style="color:#007020;font-weight:bold">interface&lt;/span>{}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 &lt;code>types/pairs&lt;/code> 包中，通过 &lt;code>pairs.json&lt;/code> 来规定所有可用的 Pair：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#062873;font-weight:bold">&amp;#34;file_func&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;types.ObjectFunc&amp;#34;&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>并通过代码生成的方式将对应的构造器生成出来：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#60a0b0;font-style:italic">// WithFileFunc will apply file_func value to Options
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">WithFileFunc&lt;/span>(v types.ObjectFunc) &lt;span style="color:#666">*&lt;/span>types.Pair {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#666">&amp;amp;&lt;/span>types.Pair{
Key: FileFunc,
Value: v,
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后在每个服务下，都会有 &lt;code>meta.json&lt;/code>，比如 &lt;a href="https://github.com/Xuanwo/storage/blob/master/services/qingstor/meta.json">qingstor meta&lt;/a> 来描述每个方法都支持哪些参数，以及哪些参数是必须的，并生成对应的解析函数和结构体。&lt;/p>
&lt;p>以 ListDir 为例：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">ch &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#007020">make&lt;/span>(&lt;span style="color:#007020;font-weight:bold">chan&lt;/span> &lt;span style="color:#666">*&lt;/span>types.Object, &lt;span style="color:#40a070">1&lt;/span>)
&lt;span style="color:#007020;font-weight:bold">defer&lt;/span> &lt;span style="color:#007020">close&lt;/span>(ch)
err &lt;span style="color:#666">:=&lt;/span> store.&lt;span style="color:#06287e">ListDir&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;prefix&amp;#34;&lt;/span>, pairs.&lt;span style="color:#06287e">WithFileFunc&lt;/span>(&lt;span style="color:#007020;font-weight:bold">func&lt;/span>(&lt;span style="color:#666">*&lt;/span>types.Object){
ch &lt;span style="color:#666">&amp;lt;-&lt;/span> o
}))
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
log.&lt;span style="color:#06287e">Printf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;storager listdir failed: %v&amp;#34;&lt;/span>, err)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="开发计划">开发计划&lt;/h2>
&lt;p>作为一个通用的存储层，如果只支持个别几个服务是很可笑的。因此接下来的一个重要是对接尽可能多的存储服务，这样才能提供这个存储抽象层的自身价值，另一方面也能够通过不同存储服务的不同设计，不同接入方式来验证我的设计合理性和扩展性 。在 v0.4.0 到 v0.5.0 中间，storage 初步支持了 &lt;a href="https://docs.microsoft.com/en-us/azure/storage/blobs/">Azure Blob storage&lt;/a>，&lt;a href="https://cloud.google.com/storage/">Google Cloud Storage&lt;/a>，&lt;a href="https://www.aliyun.com/product/oss">Aliyun Object Storage&lt;/a>，&lt;a href="https://aws.amazon.com/s3/">Amazon S3&lt;/a>。接下来的版本中，storage 会支持 &lt;a href="https://cloud.tencent.com/product/cos">Tencent Cloud Object Storage&lt;/a>，&lt;a href="https://www.qiniu.com/products/kodo">qiniu kodo&lt;/a> 和 &lt;a href="https://www.upyun.com/products/file-storage">UPYUN Storage Service&lt;/a>，并为所有的服务都加上单元测试并补充完整功能。&lt;/p>
&lt;p>此外，storage 还要统一存储层返回的错误，使得上层调用者能够轻松的处理来自存储层的错误。在实现 qingstor 支持的时候做过一些尝试，但是并不完整，接下来会在目前的已经实现的存储服务中去验证这个思路。&lt;/p>
&lt;p>作为一个服务的重要组成部份，storage 将在 Public API 中加入 context 并支持 OpenTracing。&lt;/p>
&lt;p>文档非常重要，目前 storage 只有实现相关的文档，接下来会逐步加入更多的样例和使用说明文档，帮助开发者更快的上手。&lt;/p>
&lt;p>其他的代码重构不再展开，欢迎大家来 &lt;a href="https://github.com/Xuanwo/storage/issues">Issues 区&lt;/a> 反馈意见。&lt;/p>
&lt;h2 id="体会">体会&lt;/h2>
&lt;ul>
&lt;li>在开发 storage 库的过程中，我尝试着把一些重大的架构决策都以 Proposal 的方式记录下来，算是某种形式的架构决策记录（ADR）。除了写的时候经常能发现自己拍脑袋遗漏掉的点之外，更大的作用是在事后能知道自己当初为什么要做这样的决策，帮助后来者更好的理解设计意图，这样才能够做出更好的决策。&lt;/li>
&lt;li>想知道自己的接口好不好用，最好的方式还是用到真实的项目中去，小 Demo 很难反映出这个接口的扩展性和可复用性。&lt;/li>
&lt;li>项目未成形之前不要跟别人讨论，贯彻自己的思路。想不明白的事情可以先实现最简化的路径，然后写个小项目验证一下。&lt;/li>
&lt;li>在 CI 中引入单元测试，代码覆盖率和质量控制能够提高重构的自信心，对于 Golang 项目来说，可以用 Travis CI + Codecov + GolangCI。&lt;/li>
&lt;li>知易行难，开始做的时候才会知道看起来简单的东西想做好真的很难。&lt;/li>
&lt;/ul></description></item><item><title>go-locale 介绍</title><link>https://xuanwo.io/2019/12/13/go-locale/</link><pubDate>Fri, 13 Dec 2019 01:00:00 +0000</pubDate><guid>https://xuanwo.io/2019/12/13/go-locale/</guid><description>&lt;p>在上一篇文章 &lt;a href="https://xuanwo.io/2019/12/11/golang-i18n/">在 Golang 中如何做国际化？&lt;/a> 中我提到了 “Go 目前没有一个好的检测运行环境语言的库”，&lt;code>go-locale&lt;/code> 就是为了解决这个问题而诞生的。&lt;/p>
&lt;h2 id="一些事实">一些事实&lt;/h2>
&lt;p>现实的情况是，我们没有一个标准的方法可以获取到当前代码运行环境的语言情况。&lt;/p>
&lt;p>对于大部分 Linux 发行版而言，我们可以检查 &lt;code>LANG&lt;/code> 或者 &lt;code>LANGUAGE&lt;/code> 环境变量，但是不同发行版有不同的习惯，而每个人还有自己的配置，比如我在 Archlinux 上就只有 &lt;code>LANG=en_US.UTF-8&lt;/code> ，其他的语言相关环境变量都没有。macOS 上更加复杂，传统上我们将它看作类 Unix 操作系统，沿用环境变量或者直接调用 &lt;code>locale&lt;/code> 来检查，但是这也是不一定的。Windows 更不必说了，环境变量这一套不好使，需要检查注册表或者调用 Win32 API。&lt;/p>
&lt;p>所以想要解决这些问题，我们需要为不同的平台实现不同的语言检测逻辑，但是现在这些任务可以交给 &lt;code>go-locale&lt;/code> 来做了。&lt;/p>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>&lt;code>go-locale&lt;/code> 的目标是跨平台的语言检测库，它会使用各个平台的不同方式来尽力探测出当前使用的语言，目前已经支持了 &lt;code>Linux&lt;/code>，&lt;code>macOS&lt;/code> 和 &lt;code>Windows&lt;/code> 三大主流平台。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">import&lt;/span> (
&lt;span style="color:#4070a0">&amp;#34;github.com/Xuanwo/go-locale&amp;#34;&lt;/span>
)
&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">main&lt;/span>() {
tag, err &lt;span style="color:#666">:=&lt;/span> locale.&lt;span style="color:#06287e">Detect&lt;/span>()
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
log.&lt;span style="color:#06287e">Fatal&lt;/span>(err)
}
&lt;span style="color:#60a0b0;font-style:italic">// Have fun with language.Tag!
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="内部实现">内部实现&lt;/h2>
&lt;p>&lt;code>go-locale&lt;/code> 使用条件编译机制，对外暴露一个统一的 &lt;code>Detect&lt;/code> ，内部按照平台不同实现不一样的 &lt;code>detect&lt;/code> 方法，在 &lt;code>detect&lt;/code> 内会尝试该平台下已知可用的多种不同方式，所有方式都检测不到的情况下才会返回 &lt;code>ErrNotDetected&lt;/code>。&lt;/p>
&lt;h3 id="linux">Linux&lt;/h3>
&lt;p>在 Linux 平台下首先会检查环境变量，检查顺序如下：&lt;/p>
&lt;ul>
&lt;li>&lt;code>LANGUAGE&lt;/code> 兼容 &lt;code>gettext&lt;/code> 的行为&lt;/li>
&lt;li>&lt;code>LC_ALL&lt;/code> 总是会覆盖其他的所有 &lt;code>LC_*&lt;/code> 配置&lt;/li>
&lt;li>&lt;code>LC_MESSAGES&lt;/code> 是所有消息的 locale 配置&lt;/li>
&lt;li>&lt;code>LANG&lt;/code> 是所有 &lt;code>LC_*&lt;/code> 配置的 fallback 值&lt;/li>
&lt;/ul>
&lt;p>如果环境变量全部检查失败，会尝试调用 &lt;code>locale&lt;/code> 命令来获取语言。&lt;/p>
&lt;h3 id="macos">macOS&lt;/h3>
&lt;p>在 macOS 下首先会进行全部的 Linux 系统兼容的检查，如果没有获取到，则会使用系统提供的 &lt;code>User Defaults System&lt;/code> ，通过 &lt;code>defaults read NSGlobalDomain AppleLanguages&lt;/code> 来获取语言。&lt;/p>
&lt;h3 id="windows">Windows&lt;/h3>
&lt;p>Windows 下则会使用 Win32 OLE API 来获取。&lt;/p>
&lt;h2 id="已知问题">已知问题&lt;/h2>
&lt;h3 id="虚高的-code-coverage">虚高的 Code Coverage&lt;/h3>
&lt;p>目前项目显示的代码测试覆盖率为 100%，但是这只是在 Linux 平台下测试的结果。目前 Codecov 不支持汇总多个平台下的整体结果，所以选择了只提交最好看的一个平台。&lt;/p>
&lt;p>此外，在 Linux 的单元测试中大量的进行了 mock 和 monkey patch 来模拟行为，但是由于我本人 Windows 和 macOS 使用经验较少，并不确定他们的行为是否真的是这样，所以也没有写类似的单元测试。&lt;/p>
&lt;p>根据在 Travis CI 上测试的结果，Windows 和 macOS 上的实现是 work 的，但是我不排除在特定版本和配置下会出问题的可能，如果遇到的话欢迎提交 Issue 反馈。&lt;/p>
&lt;h3 id="只返回一个语言">只返回一个语言&lt;/h3>
&lt;p>设计时的目标是返回最有可能的那个语言，但是很多人会设置多种可选语言，比如 &lt;code>zh_CN:zh_TW:en_US&lt;/code>，如果软件不支持中文的话使用英文也可以。所以这个计划在之后会返回成按照 fallback 顺序来排列的语言数组。&lt;/p></description></item><item><title>在 Golang 中如何做国际化？</title><link>https://xuanwo.io/2019/12/11/golang-i18n/</link><pubDate>Wed, 11 Dec 2019 01:00:00 +0000</pubDate><guid>https://xuanwo.io/2019/12/11/golang-i18n/</guid><description>&lt;p>国际化是一个大问题，具体到我现在从事的开发工作而言，大体上会分为以下几个步骤：&lt;/p>
&lt;ul>
&lt;li>获取待翻译字符串&lt;/li>
&lt;li>翻译字符串&lt;/li>
&lt;li>应用已翻译字符串&lt;/li>
&lt;li>使用已翻译字符串&lt;/li>
&lt;/ul>
&lt;p>目前并不存在 Golang 的国际化最佳实践，大家都需要自己去摸索，而本文将会结合我在 &lt;a href="https://github.com/yunify/qsctl">qsctl&lt;/a> 中的实践介绍 Golang 中如何做国际化，希望对读者们有所助益，少走一些弯路。首先我会介绍每个步骤需要完成的事情，然后介绍常见的 i18n 框架是如何做的，最后介绍我在 qsctl 中的做法。&lt;/p>
&lt;hr>
&lt;h2 id="步骤介绍">步骤介绍&lt;/h2>
&lt;h3 id="获取待翻译字符串">获取待翻译字符串&lt;/h3>
&lt;p>翻译的第一步是获取待翻译字符串，社区比较常见的有两种做法。&lt;/p>
&lt;p>第一种是事先定义好需要翻译的字符串，通过配置文件或者 DB 等方式存储；第二种是通过某种方式从源码中获取。&lt;/p>
&lt;p>这种方式的弊端很明显：开发流程不顺畅——想要加入一个字符串，需要先修改配置文件，更好一点的方法是通过某种方式从源码中获取，将翻译和开发解耦。&lt;/p>
&lt;h3 id="翻译字符串">翻译字符串&lt;/h3>
&lt;p>第二步是翻译字符串。这个部分在开发上需要做的工作并不多，只需要保证以一个确定的格式存储并读取正确即可，比如 YAML，JSON 或者 PO 文件等。&lt;/p>
&lt;p>通常可以使用一些 SaaS 化的服务来辅助这一工作：&lt;a href="https://crowdin.com/">crowdin&lt;/a>，&lt;a href="https://www.oneskyapp.com/">onesky&lt;/a>，&lt;a href="https://localizejs.com/">localizejs&lt;/a>，&lt;a href="https://phrase.com/">phrase&lt;/a>，&lt;a href="https://www.transifex.com/">transifex&lt;/a>，&lt;a href="https://www.smartling.com/">smartling&lt;/a> 等都是可选择的项，作为开发者，尤其需要注意的是这个服务是否支持与 Github 或者 Gitlab 集成，并支持 CI 自动构建等。&lt;/p>
&lt;h3 id="应用已翻译字符串">应用已翻译字符串&lt;/h3>
&lt;p>翻译完毕之后需要应用到程序中，根据之前的技术决策不同，翻译后的字符串可能是以配置文件的形式被读取，或者是编译成二进制（比如 gettext），或者直接生成为代码等。&lt;/p>
&lt;h3 id="使用已翻译字符串">使用已翻译字符串&lt;/h3>
&lt;p>最后一步但总是被忽略的一步是使用已翻译字符串：用户究竟是什么语言？Web 应用可以根据用户传递的 &lt;code>Accept-Language&lt;/code> 来确定，但是命令行应用就需要根据不同的系统来做判断了。很多框架并不关心这一问题，他们只提供了接口来使用指定的语言，&lt;a href="https://github.com/gosexy/gettext">gosexy/gettext&lt;/a> 稍微好一些，会通过 &lt;code>LANGUAGE&lt;/code> 来获取语言。&lt;/p>
&lt;h2 id="现有的实现">现有的实现&lt;/h2>
&lt;p>接下来我们简单的看看目前的各个 i18n 库都是怎么做的。&lt;/p>
&lt;h3 id="qori18nhttpsgithubcomqori18n">&lt;a href="https://github.com/qor/i18n">qor/i18n&lt;/a>&lt;/h3>
&lt;p>在第一步上，它使用的是预定义方式，支持通过数据库或者本地存储来获取。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">db, _ &lt;span style="color:#666">:=&lt;/span> gorm.&lt;span style="color:#06287e">Open&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;mysql&amp;#34;&lt;/span>, &lt;span style="color:#4070a0">&amp;#34;user:password@/dbname?charset=utf8&amp;amp;parseTime=True&amp;amp;loc=Local&amp;#34;&lt;/span>)
I18n &lt;span style="color:#666">:=&lt;/span> i18n.&lt;span style="color:#06287e">New&lt;/span>(
database.&lt;span style="color:#06287e">New&lt;/span>(&lt;span style="color:#666">&amp;amp;&lt;/span>db), &lt;span style="color:#60a0b0;font-style:italic">// load translations from the database
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> yaml.&lt;span style="color:#06287e">New&lt;/span>(filepath.&lt;span style="color:#06287e">Join&lt;/span>(config.Root, &lt;span style="color:#4070a0">&amp;#34;config/locales&amp;#34;&lt;/span>)), &lt;span style="color:#60a0b0;font-style:italic">// load translations from the YAML files in directory `config/locales`
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>YAML 文件形如：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#007020;font-weight:bold">en-US&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#007020;font-weight:bold">demo&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#007020;font-weight:bold">hello&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#4070a0">&amp;#34;Hello, world&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过一个简短的 key 来标识不同的待翻译字符串，用起来是这种感觉：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">I18n.&lt;span style="color:#06287e">T&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;en-US&amp;#34;&lt;/span>, &lt;span style="color:#4070a0">&amp;#34;demo.greeting&amp;#34;&lt;/span>) &lt;span style="color:#60a0b0;font-style:italic">// Not exist at first
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>I18n.&lt;span style="color:#06287e">T&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;en-US&amp;#34;&lt;/span>, &lt;span style="color:#4070a0">&amp;#34;demo.hello&amp;#34;&lt;/span>) &lt;span style="color:#60a0b0;font-style:italic">// Exists in the yml file
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="loctoolsgo-l10nhttpsgithubcomloctoolsgo-l10n">&lt;a href="https://github.com/loctools/go-l10n">loctools/go-l10n&lt;/a>&lt;/h3>
&lt;p>go-l10n 的做法与 &lt;a href="https://github.com/qor/i18n">qor/i18n&lt;/a> 类似，只不过它的待翻译字符串是在源码中声明的：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">locpool.Resources[&lt;span style="color:#4070a0">&amp;#34;en&amp;#34;&lt;/span>] = &lt;span style="color:#007020;font-weight:bold">map&lt;/span>[&lt;span style="color:#902000">string&lt;/span>]&lt;span style="color:#902000">string&lt;/span>{
&lt;span style="color:#60a0b0;font-style:italic">// Page title
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#4070a0">&amp;#34;Hello&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;Hello!&amp;#34;&lt;/span>,
&lt;span style="color:#60a0b0;font-style:italic">// {N} is the number of messages
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#4070a0">&amp;#34;YouHaveNMessages&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;You have {N} {N_PLURAL:message|messages}&amp;#34;&lt;/span>,
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>它还设计一套特定的语法来支持复数等场景，用起来形如：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">package&lt;/span> main
&lt;span style="color:#007020;font-weight:bold">import&lt;/span> (
&lt;span style="color:#4070a0">&amp;#34;github.com/iafan/Plurr/go/plurr&amp;#34;&lt;/span>
&lt;span style="color:#4070a0">&amp;#34;github.com/iafan/go-l10n/loc&amp;#34;&lt;/span>
)
&lt;span style="color:#60a0b0;font-style:italic">// Create a global localization pool which will be populated
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">// by resource files; use English as a default (fallback) language
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">var&lt;/span> locpool = loc.&lt;span style="color:#06287e">NewPool&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;en&amp;#34;&lt;/span>)
&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">main&lt;/span>() {
&lt;span style="color:#60a0b0;font-style:italic">// Get Russian localization context
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> lc &lt;span style="color:#666">:=&lt;/span> locpool.&lt;span style="color:#06287e">GetContext&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;ru&amp;#34;&lt;/span>)
&lt;span style="color:#60a0b0;font-style:italic">// Get translation by key name:
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> name &lt;span style="color:#666">:=&lt;/span> lc.&lt;span style="color:#06287e">Tr&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Hello&amp;#34;&lt;/span>)
&lt;span style="color:#60a0b0;font-style:italic">// get translation by key name, then format it using Plurr:
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> hello &lt;span style="color:#666">:=&lt;/span> lc.&lt;span style="color:#06287e">Format&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;YouHaveNMessages&amp;#34;&lt;/span>, plurr.Params{&lt;span style="color:#4070a0">&amp;#34;N&amp;#34;&lt;/span>: &lt;span style="color:#40a070">5&lt;/span>})
&lt;span style="color:#666">...&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="gosexygettexthttpsgithubcomgosexygettext">&lt;a href="https://github.com/gosexy/gettext">gosexy/gettext&lt;/a>&lt;/h3>
&lt;p>gosexy/gettext 的做法有些不太一样，它选择了提取所有的 &lt;code>gettext&lt;/code> 函数调用中的字符串并生成 PO 文件：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">fmt.&lt;span style="color:#06287e">Println&lt;/span>(gettext.&lt;span style="color:#06287e">Gettext&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Hello, world!&amp;#34;&lt;/span>))
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的 &lt;code>Hello, world&lt;/code> 就会被作为 PO 文件中的 &lt;code>msgid&lt;/code> 存储下来。&lt;/p>
&lt;p>由于是 gettext 的 binding，它也继承了 gettext text domain 的概念，用起来稍微有些复杂：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">package&lt;/span> main
&lt;span style="color:#007020;font-weight:bold">import&lt;/span> (
&lt;span style="color:#4070a0">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span style="color:#4070a0">&amp;#34;github.com/gosexy/gettext&amp;#34;&lt;/span>
)
&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">main&lt;/span>() {
textDomain &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;default&amp;#34;&lt;/span>
gettext.&lt;span style="color:#06287e">BindTextdomain&lt;/span>(textDomain, &lt;span style="color:#4070a0">&amp;#34;path/to/domains&amp;#34;&lt;/span>)
gettext.&lt;span style="color:#06287e">Textdomain&lt;/span>(textDomain)
gettext.&lt;span style="color:#06287e">SetLocale&lt;/span>(gettext.LcAll, &lt;span style="color:#4070a0">&amp;#34;es_MX.utf8&amp;#34;&lt;/span>)
fmt.&lt;span style="color:#06287e">Println&lt;/span>(gettext.&lt;span style="color:#06287e">Gettext&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Hello, world!&amp;#34;&lt;/span>))
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>好处是它能使用已有一套基于 gettext 的完整生态链，包括 POEditor 之类的都能使用，各大 SaaS 平台也都有支持。&lt;/p>
&lt;p>K8s 做国际化的时候就是使用了这套方案，参见：&lt;a href="https://github.com/kubernetes/kubernetes/tree/master/translations">https://github.com/kubernetes/kubernetes/tree/master/translations&lt;/a> 。&lt;/p>
&lt;h3 id="nicksnydergo-i18nhttpsgithubcomnicksnydergo-i18n">&lt;a href="https://github.com/nicksnyder/go-i18n">nicksnyder/go-i18n&lt;/a>&lt;/h3>
&lt;p>这个库目前看来是 Star 数量最多的，也是运用最广泛的。它的设计同样是会提取所有特定类型的调用来生成待翻译字符串：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">i18n.Message{
ID: &lt;span style="color:#4070a0">&amp;#34;PersonCats&amp;#34;&lt;/span>,
One: &lt;span style="color:#4070a0">&amp;#34;{{.Name}} has {{.Count}} cat.&amp;#34;&lt;/span>,
Other: &lt;span style="color:#4070a0">&amp;#34;{{.Name}} has {{.Count}} cats.&amp;#34;&lt;/span>,
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>会被提取成：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-toml" data-lang="toml">&lt;span style="color:#60a0b0;font-style:italic"># active.en.toml&lt;/span>
[PersonCats]
description = &lt;span style="color:#4070a0">&amp;#34;The number of cats a person has&amp;#34;&lt;/span>
one = &lt;span style="color:#4070a0">&amp;#34;{{.Name}} has {{.Count}} cat.&amp;#34;&lt;/span>
other = &lt;span style="color:#4070a0">&amp;#34;{{.Name}} has {{.Count}} cats.&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>除此之外，它提供了一系列的工具来提取和合并，翻译一个新的语言需要做如下的事情：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>创建一个空的语言配置，比如 &lt;code>translate.es.toml&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将待翻译的字符串填充进去：&lt;code>goi18n merge active.en.toml translate.es.toml&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-toml" data-lang="toml">&lt;span style="color:#60a0b0;font-style:italic"># translate.es.toml&lt;/span>
[HelloPerson]
hash = &lt;span style="color:#4070a0">&amp;#34;sha1-5b49bfdad81fedaeefb224b0ffc2acc58b09cff5&amp;#34;&lt;/span>
other = &lt;span style="color:#4070a0">&amp;#34;Hello {{.Name}}&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>翻译完毕后重命名为 &lt;code>active.es.toml&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-toml" data-lang="toml">&lt;span style="color:#60a0b0;font-style:italic"># active.es.toml&lt;/span>
[HelloPerson]
hash = &lt;span style="color:#4070a0">&amp;#34;sha1-5b49bfdad81fedaeefb224b0ffc2acc58b09cff5&amp;#34;&lt;/span>
other = &lt;span style="color:#4070a0">&amp;#34;Hola {{.Name}}&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>在代码中载入&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">bundle.&lt;span style="color:#06287e">RegisterUnmarshalFunc&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;toml&amp;#34;&lt;/span>, toml.Unmarshal)
bundle.&lt;span style="color:#06287e">LoadMessageFile&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;active.es.toml&amp;#34;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>实际用起来的感觉是这样的：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="">（&lt;/span>
&lt;span style="color:#4070a0">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span style="color:#4070a0">&amp;#34;github.com/nicksnyder/go-i18n/v2/i18n&amp;#34;&lt;/span>
&lt;span style="">）&lt;/span>
&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">main&lt;/span>() {
bundle &lt;span style="color:#666">:=&lt;/span> i18n.&lt;span style="color:#06287e">NewBundle&lt;/span>(language.English)
bundle.&lt;span style="color:#06287e">RegisterUnmarshalFunc&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;toml&amp;#34;&lt;/span>, toml.Unmarshal)
bundle.&lt;span style="color:#06287e">LoadMessageFile&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;es.toml&amp;#34;&lt;/span>)
localizer &lt;span style="color:#666">:=&lt;/span> i18n.&lt;span style="color:#06287e">NewLocalizer&lt;/span>(bundle, lang, accept)
helloPersonMessage &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#666">&amp;amp;&lt;/span>i18n.Message{
ID: &lt;span style="color:#4070a0">&amp;#34;HelloPerson&amp;#34;&lt;/span>,
Other: &lt;span style="color:#4070a0">&amp;#34;Hello {{.Name}}!&amp;#34;&lt;/span>,
}
fmt.&lt;span style="color:#06287e">Println&lt;/span>(localizer.&lt;span style="color:#06287e">MustLocalize&lt;/span>(&lt;span style="color:#666">&amp;amp;&lt;/span>i18n.LocalizeConfig{
DefaultMessage: helloPersonMessage,
TemplateData: &lt;span style="color:#007020;font-weight:bold">map&lt;/span>[&lt;span style="color:#902000">string&lt;/span>]&lt;span style="color:#902000">string&lt;/span>{&lt;span style="color:#4070a0">&amp;#34;Name&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;Nick&amp;#34;&lt;/span>},
}))
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>抽象最多，功能最强，应该算是目前最好的 go-i18n 库了。&lt;/p>
&lt;h2 id="更好的方案">更好的方案&lt;/h2>
&lt;h3 id="理想很丰满">理想很丰满&lt;/h3>
&lt;p>刚才分析了 i18n 需要的各个步骤，也看了社区的一些实现，是时候想想理想中的 i18n 流程的模样了。我认为一个好的 i18n 流程应当将翻译工作和代码开发解耦，业务人员在实现逻辑的时候不需要考虑当前的语言环境，也不需要考虑这个字符串是否被翻译过，调用习惯最好与标准库接近（比如 &lt;code>fmt&lt;/code>），而翻译人员在进行翻译的时候，则需要屏蔽所有的代码细节，不需要考虑这个字符串会被如何调用，不需要有任何的开发背景。那么问题来了，有没有这样&lt;del>一个游戏&lt;/del>一个库呢？&lt;/p>
&lt;h3 id="现实很骨感">现实很骨感&lt;/h3>
&lt;p>没有，但是我们有一个很接近的，&lt;a href="https://golang.org/x/text">https://golang.org/x/text&lt;/a> : &lt;em>a repository of text-related packages related to internationalization (i18n) and localization (l10n)&lt;/em>&lt;/p>
&lt;p>text 包中提供的 message 库主要专注于我们上文提到的步骤三，以接近于 &lt;code>fmt&lt;/code> 的接口来输出已翻译的字符串，比如：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">message.&lt;span style="color:#06287e">SetString&lt;/span>(language.Dutch, &lt;span style="color:#4070a0">&amp;#34;You have chosen to play %m.&amp;#34;&lt;/span>, &lt;span style="color:#4070a0">&amp;#34;U heeft ervoor gekozen om %m te spelen.&amp;#34;&lt;/span>)
message.&lt;span style="color:#06287e">SetString&lt;/span>(language.Dutch, &lt;span style="color:#4070a0">&amp;#34;basketball&amp;#34;&lt;/span>, &lt;span style="color:#4070a0">&amp;#34;basketbal&amp;#34;&lt;/span>)
message.&lt;span style="color:#06287e">SetString&lt;/span>(language.Dutch, &lt;span style="color:#4070a0">&amp;#34;hockey&amp;#34;&lt;/span>, &lt;span style="color:#4070a0">&amp;#34;ijshockey&amp;#34;&lt;/span>)
message.&lt;span style="color:#06287e">SetString&lt;/span>(language.Dutch, &lt;span style="color:#4070a0">&amp;#34;soccer&amp;#34;&lt;/span>, &lt;span style="color:#4070a0">&amp;#34;voetbal&amp;#34;&lt;/span>)
message.&lt;span style="color:#06287e">SetString&lt;/span>(language.BritishEnglish, &lt;span style="color:#4070a0">&amp;#34;soccer&amp;#34;&lt;/span>, &lt;span style="color:#4070a0">&amp;#34;football&amp;#34;&lt;/span>)
&lt;span style="color:#007020;font-weight:bold">for&lt;/span> _, sport &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#007020;font-weight:bold">range&lt;/span> []&lt;span style="color:#902000">string&lt;/span>{&lt;span style="color:#4070a0">&amp;#34;soccer&amp;#34;&lt;/span>, &lt;span style="color:#4070a0">&amp;#34;basketball&amp;#34;&lt;/span>, &lt;span style="color:#4070a0">&amp;#34;hockey&amp;#34;&lt;/span>} {
&lt;span style="color:#007020;font-weight:bold">for&lt;/span> _, lang &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#007020;font-weight:bold">range&lt;/span> []&lt;span style="color:#902000">string&lt;/span>{&lt;span style="color:#4070a0">&amp;#34;en&amp;#34;&lt;/span>, &lt;span style="color:#4070a0">&amp;#34;en-GB&amp;#34;&lt;/span>, &lt;span style="color:#4070a0">&amp;#34;nl&amp;#34;&lt;/span>} {
p &lt;span style="color:#666">:=&lt;/span> message.&lt;span style="color:#06287e">NewPrinter&lt;/span>(language.&lt;span style="color:#06287e">Make&lt;/span>(lang))
fmt.&lt;span style="color:#06287e">Printf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%-6s %s\n&amp;#34;&lt;/span>, lang, p.&lt;span style="color:#06287e">Sprintf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;You have chosen to play %m.&amp;#34;&lt;/span>, sport))
}
fmt.&lt;span style="color:#06287e">Println&lt;/span>()
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以我们只需要想办法处理其他步骤即可。&lt;/p>
&lt;h3 id="实现总有坑">实现总有坑&lt;/h3>
&lt;p>首先，提取待翻译字符串。&lt;/p>
&lt;blockquote>
&lt;p>当初在实现的时候我忽略了 message 包提供的 &lt;code>gotext&lt;/code> 工具，它支持从源码中提取所有使用 &lt;code>message.Printer&lt;/code> 输出的字符串，没必要再自己重新造轮子了。&lt;/p>
&lt;/blockquote>
&lt;p>我当时的做法是创建了一个新的包叫做 &lt;code>i18n&lt;/code>，在内部创建并初始化一个全局的 &lt;code>message.Printer&lt;/code> ，并把 &lt;code>message.Printer&lt;/code> 的方法导出为包的方法，然后在 AST 中提取所有的调用。一个比较粗糙的实现是这样的，之后应该会改成直接用 &lt;code>gotext&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">ast.&lt;span style="color:#06287e">Inspect&lt;/span>(f, &lt;span style="color:#007020;font-weight:bold">func&lt;/span>(n ast.Node) &lt;span style="color:#902000">bool&lt;/span> {
call, ok &lt;span style="color:#666">:=&lt;/span> n.(&lt;span style="color:#666">*&lt;/span>ast.CallExpr)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> !ok {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">true&lt;/span>
}
fn, ok &lt;span style="color:#666">:=&lt;/span> call.Fun.(&lt;span style="color:#666">*&lt;/span>ast.SelectorExpr)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> !ok {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">true&lt;/span>
}
pack, ok &lt;span style="color:#666">:=&lt;/span> fn.X.(&lt;span style="color:#666">*&lt;/span>ast.Ident)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> !ok {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">true&lt;/span>
}
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> pack.Name &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;i18n&amp;#34;&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">true&lt;/span>
}
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020">len&lt;/span>(call.Args) &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">true&lt;/span>
}
str, ok &lt;span style="color:#666">:=&lt;/span> call.Args[&lt;span style="color:#40a070">0&lt;/span>].(&lt;span style="color:#666">*&lt;/span>ast.BasicLit)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> !ok {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">true&lt;/span>
}
&lt;span style="color:#60a0b0;font-style:italic">// Keep this for later debug usage.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#60a0b0;font-style:italic">// log.Printf(&amp;#34;%v&amp;#34;, str.Value)
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> data[str.Value] = str.Value
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">true&lt;/span>
})
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后翻译服务使用了 &lt;a href="https://crowdin.com/">crowdin&lt;/a>，它支持与 Github 的集成，同时还为开源项目提供了慷慨的支持。&lt;/p>
&lt;p>最后在应用的时候我遇到了不少的问题。&lt;/p>
&lt;p>第一个问题是，Go 目前没有一个好的检测运行环境语言的库，以 Linux 为例，根据用户的发行版不同，设置语言的方式也千差万别，只是检查 &lt;code>LANG&lt;/code> 或者 &lt;code>LANGUAGE&lt;/code> 是不够的 ，为此我开发了 &lt;a href="https://github.com/Xuanwo/go-locale">go-locale&lt;/a>：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">import&lt;/span> (
&lt;span style="color:#4070a0">&amp;#34;github.com/Xuanwo/go-locale&amp;#34;&lt;/span>
)
&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">main&lt;/span>() {
tag, err &lt;span style="color:#666">:=&lt;/span> locale.&lt;span style="color:#06287e">Detect&lt;/span>()
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
log.&lt;span style="color:#06287e">Fatal&lt;/span>(err)
}
&lt;span style="color:#60a0b0;font-style:italic">// Have fun with language.Tag!
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>只需要一个简单的调用就能获得当前系统环境的对应 Language Tag。目前只支持 Linux，内部采用检查所有的 &lt;code>LC_*&lt;/code> ，&lt;code>LANG&lt;/code>，&lt;code>LANGUAGE&lt;/code> 环境变量，调用 &lt;code>locale&lt;/code> 等多种方式来判断，后续还会支持 Windows 和 Mac 等常用操作系统。&lt;/p>
&lt;p>第二个问题是 &lt;a href="https://godoc.org/golang.org/x/text/language">language&lt;/a> 库的提供的 Language Match 实现很是坑爹：按照 BCP 47 的规范，&lt;code>zh_CN&lt;/code> 应当被 &lt;code>zh_Hans&lt;/code> 代替，但是现实是 &lt;code>zh_CN&lt;/code> 已经被广泛应用于各种地方，比如 Linux 下的 locale 就是 &lt;code>zh_CN.UTF-8&lt;/code>，然而使用 &lt;code>zh_CN&lt;/code> 创建的 &lt;code>language.Tag&lt;/code> 是既匹配不到 &lt;code>zh_Hans&lt;/code> 也匹配不到 &lt;code>zh&lt;/code> 的。&lt;/p>
&lt;p>我也没有太好的方案，目前的做法是从 &lt;code>language&lt;/code> 库的内部实现中 copy 了一个 Matcher 的实现：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">newMatcher&lt;/span>(t []language.Tag) &lt;span style="color:#666">*&lt;/span>matcher {
tags &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#666">&amp;amp;&lt;/span>matcher{&lt;span style="color:#007020">make&lt;/span>(&lt;span style="color:#007020;font-weight:bold">map&lt;/span>[language.Tag]&lt;span style="color:#902000">int&lt;/span>)}
&lt;span style="color:#007020;font-weight:bold">for&lt;/span> i, tag &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#007020;font-weight:bold">range&lt;/span> t {
ct, err &lt;span style="color:#666">:=&lt;/span> language.All.&lt;span style="color:#06287e">Canonicalize&lt;/span>(tag)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
ct = tag
}
tags.index[ct] = i
}
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> tags
}
&lt;span style="color:#007020;font-weight:bold">type&lt;/span> matcher &lt;span style="color:#007020;font-weight:bold">struct&lt;/span> {
index &lt;span style="color:#007020;font-weight:bold">map&lt;/span>[language.Tag]&lt;span style="color:#902000">int&lt;/span>
}
&lt;span style="color:#007020;font-weight:bold">func&lt;/span> (m matcher) &lt;span style="color:#06287e">Match&lt;/span>(want &lt;span style="color:#666">...&lt;/span>language.Tag) (language.Tag, &lt;span style="color:#902000">int&lt;/span>, language.Confidence) {
&lt;span style="color:#007020;font-weight:bold">for&lt;/span> _, t &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#007020;font-weight:bold">range&lt;/span> want {
ct, err &lt;span style="color:#666">:=&lt;/span> language.All.&lt;span style="color:#06287e">Canonicalize&lt;/span>(t)
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
ct = t
}
conf &lt;span style="color:#666">:=&lt;/span> language.Exact
&lt;span style="color:#007020;font-weight:bold">for&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> index, ok &lt;span style="color:#666">:=&lt;/span> m.index[ct]; ok {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> ct, index, conf
}
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> ct &lt;span style="color:#666">==&lt;/span> language.Und {
&lt;span style="color:#007020;font-weight:bold">break&lt;/span>
}
ct = ct.&lt;span style="color:#06287e">Parent&lt;/span>()
conf = language.High
}
}
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> language.Und, &lt;span style="color:#40a070">0&lt;/span>, language.No
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>保证这个 Matcher 内使用的 Tag 都进行了规范化，而且总是返回我们支持的语言之一或者直接返回不支持，而不是 Tag Compose 之后的结果。&lt;/p>
&lt;p>这样我们就能够按照语言来进行初始化了：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#60a0b0;font-style:italic">// Init will init i18n support via input language.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">Init&lt;/span>(lang language.Tag) {
tag, _, _ &lt;span style="color:#666">:=&lt;/span> supported.&lt;span style="color:#06287e">Match&lt;/span>(lang)
&lt;span style="color:#007020;font-weight:bold">switch&lt;/span> tag {
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> language.AmericanEnglish, language.English:
&lt;span style="color:#06287e">initEnUS&lt;/span>(lang)
&lt;span style="color:#007020;font-weight:bold">case&lt;/span> language.SimplifiedChinese, language.Chinese:
&lt;span style="color:#06287e">initZhCN&lt;/span>(lang)
&lt;span style="color:#007020;font-weight:bold">default&lt;/span>:
&lt;span style="color:#06287e">initEnUS&lt;/span>(lang)
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="总算搞定了">总算搞定了&lt;/h3>
&lt;p>上述工作做完之后，在 qsctl 想输出一个国际化字符串非常容易，只需要像使用 &lt;code>fmt&lt;/code> 一样使用 &lt;code>i18n&lt;/code> 库即可：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">i18n.&lt;span style="color:#06287e">Printf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;File &amp;lt;%s&amp;gt; copied to &amp;lt;%s&amp;gt;.\n&amp;#34;&lt;/span>, t.&lt;span style="color:#06287e">GetSourcePath&lt;/span>(), t.&lt;span style="color:#06287e">GetDestinationPath&lt;/span>())
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>不需要手动载入，因为所有的字符串都已经事先生成好并在 &lt;code>i18n&lt;/code> 库初始化的时候导入了&lt;/li>
&lt;li>不需要关心这个字符串是否被翻译以及会不会翻译，只要专注于自己的逻辑即可&lt;/li>
&lt;/ul>
&lt;p>在 qsctl 中 i18n 流程如下：&lt;/p>
&lt;ul>
&lt;li>使用 &lt;code>i18n&lt;/code> 库提供的 &lt;code>Sprintf&lt;/code> 和 &lt;code>Printf&lt;/code> 等函数来输出需要国际化的字符串&lt;/li>
&lt;li>&lt;code>make generate&lt;/code> 会将这些字符串都提取到 &lt;code>translations/en_US&lt;/code> 目录下，以 JSON 文件的形式存储&lt;/li>
&lt;li>翻译人员通过 &lt;a href="https://crowdin.com/project/qsctl">crowdin&lt;/a> 进行翻译，&lt;a href="https://crowdin.com/">crowdin&lt;/a> 会自动创建翻译后的目录 (形如 &lt;code>translations/zh_CN&lt;/code>) ，并提交 PR&lt;/li>
&lt;li>PR Merge 之后再次运行 &lt;code>make generate&lt;/code> 会将 &lt;code>translations&lt;/code> 目录下的不同语言的 JSON 文件生成为对应的语言初始化函数，在 &lt;code>i18n&lt;/code> 的 &lt;code>init&lt;/code> 函数中会根据检测到的语言类型进行初始化&lt;/li>
&lt;/ul>
&lt;p>最后的成果：&lt;/p>
&lt;p>&lt;img src="qsctl.png" alt="">&lt;/p>
&lt;p>QingStor 旗下第一款支持国际化的命令行工具诞生啦！&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>所以在 Golang 中该如何做国际化呢？我有以下几点小小的建议：&lt;/p>
&lt;ul>
&lt;li>多看看 &lt;a href="https://godoc.org/golang.org/x/text/message">message&lt;/a> 库，避免重复造轮子&lt;/li>
&lt;li>全流程自动化，不要手工维护翻译文件&lt;/li>
&lt;li>挑选一个合适的翻译服务&lt;/li>
&lt;/ul>
&lt;p>当然国际化不仅仅是将字符串本地化，其中还有货币，时间，数字本地化等内容，由于没有实践经验，我就不赘述了。&lt;/p>
&lt;p>欢迎大家在评论区交流～&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/qor/i18n">qor/i18n&lt;/a>: &lt;em>I18n is a golang implementation, provides internationalization support for your application, with different backends support&lt;/em>&lt;/li>
&lt;li>&lt;a href="https://github.com/loctools/go-l10n">loctools/go-l10n&lt;/a>: &lt;em>Lightweight yet powerful continuous localization solution for Go, based on Serge and Plurr.&lt;/em>&lt;/li>
&lt;li>&lt;a href="https://github.com/gosexy/gettext">gosexy/gettext&lt;/a>: &lt;em>Go bindings for &lt;a href="http://www.gnu.org/software/gettext/">GNU gettext&lt;/a>, an internationalization and localization library for writing multilingual systems.&lt;/em>&lt;/li>
&lt;li>&lt;a href="https://github.com/nicksnyder/go-i18n">nicksnyder/go-i18n&lt;/a>: &lt;em>go-i18n is a Go &lt;a href="https://github.com/nicksnyder/go-i18n#package-i18n">package&lt;/a> and a &lt;a href="https://github.com/nicksnyder/go-i18n#command-goi18n">command&lt;/a> that helps you translate Go programs into multiple languages.&lt;/em>&lt;/li>
&lt;li>&lt;a href="https://godoc.org/golang.org/x/text/message">message&lt;/a>: &lt;em>Package message implements formatted I/O for localized strings with functions analogous to the fmt&amp;rsquo;s print functions. It is a drop-in replacement for fmt.&lt;/em>&lt;/li>
&lt;/ul></description></item><item><title>更好用的 IANA Language Subtag Registry 数据</title><link>https://xuanwo.io/2019/11/27/iana-language-subtag-registry-for-human/</link><pubDate>Wed, 27 Nov 2019 01:00:00 +0000</pubDate><guid>https://xuanwo.io/2019/11/27/iana-language-subtag-registry-for-human/</guid><description>&lt;p>研究 Language Tag 的时候发现 IANA 发布的 Language Subtag Registry 是用 &lt;a href="https://tools.ietf.org/html/draft-phillips-record-jar-01">Record Jar&lt;/a> 格式发布的，虽然读起来比较容易，但是用于代码中执行自动化操作很麻烦，所以我做了一些工作将 &lt;code>Record Jar&lt;/code> 转换为 JSON 格式。&lt;/p>
&lt;h2 id="背景介绍">背景介绍&lt;/h2>
&lt;h3 id="language-subtag-registry">Language Subtag Registry&lt;/h3>
&lt;p>&lt;a href="https://tools.ietf.org/html/bcp47">BCP 47&lt;/a> 是用于区分语言的当前最佳实践，包含的 RFC 有 &lt;a href="https://tools.ietf.org/html/rfc5646">RFC 5646&lt;/a> 和 &lt;a href="https://tools.ietf.org/html/rfc4647">RFC 4647&lt;/a>，几乎所有语言和操作系统都遵循了这一规范。BCP 47 除了规范 Language Tag 的定义，格式及其使用之外，还规定了所有有效的 Subtag 如何存储和检索，即&lt;code>IANA Language Subtag Registry&lt;/code>。&lt;/p>
&lt;h2 id="record-jar">Record Jar&lt;/h2>
&lt;p>Record Jar 最早由 &lt;a href="https://en.wikipedia.org/wiki/Eric_S._Raymond">Eric S. Raymond&lt;/a> 在他的著作 &lt;a href="http://www.catb.org/~esr/writings/taoup/html/">The Art of Unix Programming&lt;/a> 中描述，之后被规范化并提出了草案 &lt;a href="https://tools.ietf.org/html/draft-phillips-record-jar-02">draft-phillips-record-jar-02&lt;/a>。BCP 47 就是使用了这个格式来存储 Language Subtag。&lt;/p>
&lt;h2 id="iana-language-subtag-registry-for-human">IANA Language Subtag Registry For Human&lt;/h2>
&lt;p>Record Jar 看起来大概是这样：&lt;/p>
&lt;pre>&lt;code>Type: language
Subtag: ia
Description: Interlingua (International Auxiliary Language
Association)
Added: 2005-10-16
%%
Type: language
Subtag: cu
Description: Church Slavic
Description: Church Slavonic
Description: Old Bulgarian
Description: Old Church Slavonic
Description: Old Slavonic
Added: 2005-10-16
&lt;/code>&lt;/pre>&lt;p>&lt;code>%%&lt;/code> 作为前缀表示注释，Key 和 Value 通过 &lt;code>:&lt;/code> 来分割，任意的 Key 都有可能出现多次。为了维护可读性，还会支持 Folding，即通过一些特定的格式来展示多行文本。&lt;/p>
&lt;p>这是一个非常简单的文本格式，很好读，但是不好用。如果想提取这些 Subtag 来做一些事情的话，就需要先解析 Record Jar，然后再映射到对应的数据结构中。我在另外一个项目写完了这部分的代码之后认为这些工作其实没有必要重复进行，首先我可以按照 RFC 5646 的描述设计出一个数据结构，然后可以解析 Record Jar 并映射到这个数据结构上，最后再生成一些更加结构化的数据描述，比如 JSON。&lt;/p>
&lt;p>说干就干，首先实现了 &lt;a href="https://github.com/Xuanwo/go-record-jar">go-record-jar&lt;/a>。它的作用是支持解析 Record Jar，并将其存储为 &lt;code>[]map[string][]string&lt;/code>。目前它已经可以完整的解析整个 &lt;code>Registry&lt;/code> 文件，支持多行 Value，支持重复的 Key。&lt;a href="https://goreportcard.com/report/github.com/Xuanwo/go-record-jar">go report A+&lt;/a>，测试覆盖率 &lt;a href="https://codecov.io/gh/Xuanwo/go-record-jar">91%&lt;/a>，已经基本可用。&lt;/p>
&lt;p>然后是 &lt;a href="https://github.com/Xuanwo/go-language">go-language&lt;/a>，这个项目实际上还没有完工，只是给出了 Language Tag 的结构体声明，未来会读取 &lt;code>Registry&lt;/code> 来生成对应的 Tag。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">type&lt;/span> Tag &lt;span style="color:#007020;font-weight:bold">struct&lt;/span> {
&lt;span style="color:#60a0b0;font-style:italic">// MUST contain at least one each
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> Type &lt;span style="color:#902000">string&lt;/span>
Description []&lt;span style="color:#902000">string&lt;/span>
Added &lt;span style="color:#902000">string&lt;/span>
&lt;span style="color:#60a0b0;font-style:italic">// MUST contain one of them.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> Tag &lt;span style="color:#902000">string&lt;/span>
Subtag &lt;span style="color:#902000">string&lt;/span>
&lt;span style="color:#60a0b0;font-style:italic">// MAY also contain the following fields
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> Deprecated &lt;span style="color:#902000">string&lt;/span>
PreferredValue &lt;span style="color:#902000">string&lt;/span> &lt;span style="color:#4070a0">`json:&amp;#34;Preferred-Value&amp;#34;`&lt;/span>
Prefix []&lt;span style="color:#902000">string&lt;/span>
SuppressScript &lt;span style="color:#902000">string&lt;/span> &lt;span style="color:#4070a0">`json:&amp;#34;Suppress-Script&amp;#34;`&lt;/span>
Macrolanguage &lt;span style="color:#902000">string&lt;/span>
Scope &lt;span style="color:#902000">string&lt;/span>
Comments &lt;span style="color:#902000">string&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后我开发了 &lt;a href="https://github.com/Xuanwo/iana-language-subtag-registry">iana-language-subtag-registry&lt;/a>，并上线了网站 &lt;a href="https://iana-language-subtag-registry.xuanwo.io/">https://iana-language-subtag-registry.xuanwo.io/&lt;/a> （当然，很丑，欢迎贡献前端- -） 。这个很简单，用 &lt;a href="https://github.com/Xuanwo/go-record-jar">go-record-jar&lt;/a> 解析内容，然后生成 JSON 文件。后续还会去做一些自动化更新的事情，会自动的去更新这些内容。生成其他的格式也相当容易，不过目前暂时还没有看到类似的需求。&lt;/p>
&lt;p>欢迎大家使用，有需求或者反馈的话可以提交到 &lt;a href="https://github.com/Xuanwo/iana-language-subtag-registry/issues">Issues&lt;/a>。&lt;/p>
&lt;h2 id="灵魂发问">灵魂发问&lt;/h2>
&lt;p>为什么要重复造轮子呢？&lt;/p>
&lt;h3 id="golang-不是已经有-languagehttpsgodocorggolangorgxtextlanguage-包了吗">Golang 不是已经有 &lt;a href="https://godoc.org/golang.org/x/text/language">language&lt;/a> 包了吗？&lt;/h3>
&lt;p>language 完整的实现了 BCP 47 支持，但是它对外只暴露出了完整的 Language Tag：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">var&lt;/span> userPrefs = []language.Tag{
language.&lt;span style="color:#06287e">Make&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;gsw&amp;#34;&lt;/span>), &lt;span style="color:#60a0b0;font-style:italic">// Swiss German
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> language.&lt;span style="color:#06287e">Make&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;fr&amp;#34;&lt;/span>), &lt;span style="color:#60a0b0;font-style:italic">// French
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>}
&lt;span style="color:#007020;font-weight:bold">var&lt;/span> serverLangs = []language.Tag{
language.AmericanEnglish, &lt;span style="color:#60a0b0;font-style:italic">// en-US fallback
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> language.German, &lt;span style="color:#60a0b0;font-style:italic">// de
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>而构造 Language Tag 需要通过形如 &lt;code>language.Make(&amp;quot;gsw&amp;quot;)&lt;/code> 的方式，这对于写一个解析 &lt;code>Accept-Language&lt;/code> 的服务器端应用可能很好，但是对上层库的实现者就不太友好了：缺少可用的 Subtag 全集。所以我的计划是在 &lt;a href="https://github.com/Xuanwo/go-language">go-language&lt;/a> 中加入 Subtag 的全集，并实现与 &lt;a href="https://godoc.org/golang.org/x/text/language">language&lt;/a> 包的互操作，这样我基于这些工作来完成我的其他项目了。&lt;/p>
&lt;h3 id="将-registry-转换为-json-的工作已经有人做过了">将 Registry 转换为 JSON 的工作已经有人做过了！&lt;/h3>
&lt;p>是的，&lt;a href="https://github.com/mattcg/language-subtag-registry">language-subtag-registry&lt;/a> 项目已经实现了类似的工作，还对 Subtag 进行了分组，提高了易用性。&lt;/p>
&lt;p>但是这个项目主要目标是作为一个 npm 包在 Javascript 的生态中提供服务，这与我语言无关的主旨相违背。其次，&lt;a href="https://github.com/Xuanwo/iana-language-subtag-registry">iana-language-subtag-registry&lt;/a> 期望作为一个可靠的数据源为所有语言提供支持，所以它不会在上游的数据上做额外的封装，也不会生成出一个 ID 可能变动的 Index 出来。&lt;/p>
&lt;p>&lt;em>当然也能傲娇的说一句：&amp;ldquo;Because I can.&amp;quot;&lt;/em>&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;p>推荐阅读&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://leohacker.github.io/textprocessing/CLDR-Locale/">CLDR - Locale&lt;/a> 是 &lt;a href="https://leohacker.github.io/">@Leo Jiang&lt;/a> 写的一篇介绍 CLDR(Unicode Common Locale Data Repository) 和语言环境的文章，推荐阅读&lt;/li>
&lt;li>&lt;a href="https://www.w3.org/International/articles/language-tags/">Language tags in HTML and XML&lt;/a> 介绍了 HTML &lt;code>lang&lt;/code> 和 XML &lt;code>xml:lang&lt;/code> 中使用的 Language Tag&lt;/li>
&lt;li>&lt;a href="https://www.w3.org/International/questions/qa-choosing-language-tags">Choosing a Language Tag&lt;/a> 介绍了如何选择 Language Tag&lt;/li>
&lt;/ul>
&lt;p>用于参考&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry">IANA Language Subtag Registry&lt;/a> 是 IANA 发布的所有可用 Language Subtag 列表&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/html/bcp47">BCP 47 Tags for Identifying Languages&lt;/a> 是用于区分语言的 Best Current Practice&lt;/li>
&lt;li>&lt;a href="https://docs.microsoft.com/zh-cn/cpp/c-runtime-library/locale-names-languages-and-country-region-strings?view=vs-2019">UCRT 区域设置名称、语言和国家/地区字符串&lt;/a> 是 Windows NLS API 支持的 locale 参数&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/matchlang">Language and Locale Matching in Go&lt;/a> Golang Blog 中关于 language 包使用的介绍&lt;/li>
&lt;li>&lt;a href="https://r12a.github.io/app-subtags/">BCP47 language subtag lookup&lt;/a> 被 W3C 引用的 Subtag 检索工具，非常好用，甚至想自己搞一个&lt;/li>
&lt;/ul></description></item><item><title>Go 模板元编程及其在 qsctl 中的实践</title><link>https://xuanwo.io/2019/11/10/go-template-meta-coding-in-qsctl2/</link><pubDate>Sun, 10 Nov 2019 01:00:00 +0000</pubDate><guid>https://xuanwo.io/2019/11/10/go-template-meta-coding-in-qsctl2/</guid><description>&lt;p>有一段时间没有写博客了，最近主要在做的是事情是重新设计并跟小伙伴 &lt;a href="https://github.com/Prnyself">Lance&lt;/a> 一起了实现 QingStor 对象存储的命令行工具 &lt;a href="https://github.com/yunify/qsctl">qsctl&lt;/a>。经过一段时间的开发，qsctl 终于发布了首个 beta 版本，我也终于有时间能够跟大家聊一聊~~（吹嘘）~~一下这个产品。在这周五我们公司的 Think Friday 分享中，我分享了《数据驱动编程及其在 qsctl 中的实践》，本文是这次分享修改了标题并补充了部分内容后的事后总结。&lt;/p>
&lt;hr>
&lt;p>大家好，我是漩涡，我是 QingStor 存储研发部的研发工程师（aka QingStor 首席 Go Template 研发工程师，逃）。我对自己的定位是效率研发工程师，我的工作职责是提升我们团队，我们的研发同事，还有调用我们服务的开发者和使用我们服务的用户的工作效率。今天的分享主要就是介绍影响我们用户工作效率的关键工具——qsctl 的重构实践。&lt;/p>
&lt;p>本次分享主要分为下面六个部分：首先为不熟悉 QingStor 对象存储周边产品生态的同学介绍 qsctl 是什么，然后介绍 qsctl 在实际的运用和维护中面临的困境。接下来介绍 qsctl 2 研发初期定下的目标，然后分享 qsctl 2 是如何运用 Go 模板元编程的。在最后会介绍实践中的一些经验和最后的实际应用。&lt;/p>
&lt;h2 id="qsctl-是什么">qsctl 是什么&lt;/h2>
&lt;p>在介绍 qsctl 是什么之前，我们需要先了解 QingStor 对象存储是什么。按照官方口径，QingStor™ 对象存储为用户提供可无限扩展的通用数据存储服务，具有安全可靠、简单易用、高性能、低成本等特点。抛开这些宣传话术，从开发者的角度来看，对象存储实际上可以视作一个通过 HTTP 接口对外提供服务的超大 Key-Value 数据库，每个文件的元数据都与它自身的内容存储在一起，只能通过一个全局唯一的 Key 来访问。&lt;/p>
&lt;p>显然的，对象存储提供的接口与传统的 POSIX 接口是完全不同的，所以为了方便用户使用对象存储，除了开发各个语言的 SDK 之外，我们还需要提供各种工具：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/yunify/qsftpd">qsftpd&lt;/a>: 将 QingStor 对象存储作为后端存储的 FTP 服务&lt;/li>
&lt;li>&lt;a href="https://github.com/yunify/qscamel">qscamel&lt;/a>: 用于在不同的端点 (Endpoint) 中高效迁移数据的工具&lt;/li>
&lt;li>&lt;a href="https://github.com/yunify/qsfs-fuse">qsfs&lt;/a> &amp;amp;&amp;amp; &lt;a href="https://docs.qingcloud.com/qingstor/developer_tools/local_fs_tools/elastic_drive/index.html">ElasticDrive&lt;/a>: Linux &amp;amp;&amp;amp; Windows 端将对象存储挂载到本地的工具&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>在这些所有的工具之中，qsctl 是用户最多，也是功能最全面的，它提供了 Bucket 和 Object 创建，查看，删除的管理功能，提供了批量上传和下载 &amp;amp;&amp;amp; 增量上传和下载的功能，还有类似于生成一次性访问链接这样的便利小功能。&lt;/p>
&lt;p>它的使用是如此广泛，以至于它成为了 QingStor 私有云部署验收环节中的一部分：使用 qsctl 创建，查看，删除 Object 以测试服务是否正常。大量的 QingStor 对象存储用户将 qsctl 工具纳入了他们的工作流程之中：他们在各种各样的脚本中调用 qsctl 命令行来访问对象存储。&lt;/p>
&lt;h2 id="qsctl-的困境">qsctl 的困境&lt;/h2>
&lt;p>使用如此广泛的 qsctl 从 2018 年 12 月起就再也没有任何更新了，没有新增功能，没有 BUG 修复，更别提代码重构和性能优化。Why？因为我们遇到了很多问题，人手不足固然是一方面，但是 qsctl 本身的问题才是更致命的。&lt;/p>
&lt;p>首先我们遇到的是开发语言特性与日渐增长的用户需求不匹配的矛盾。&lt;/p>
&lt;p>qsctl 开发始于 2016 年，对标的产品是 &lt;a href="https://github.com/s3tools/s3cmd">s3cmd&lt;/a>，当时我们着重需要解决的问题是人有我无的问题，因此我们选择使用 Python 快速开发出一个可用的命令行工具。要知道，那时候我们甚至连一个好用的 Python SDK 都没有。我们当时对 qsctl 的期待是它能够满足用户的轻度使用需求，更加重载和生产级别的需求会引导用户基于我们的 API 来进行开发。&lt;/p>
&lt;p>我们的期望是错误的。用户从来都不会以我们期望的方式来使用工具，用户从来都不会主动调用我们的 API 来进行开发。只要你提供了工具，用户就会在生产环境中使用，并将其视作服务可用性的一部分。于是大家逐渐的发现，qsctl 太慢了。单线程的上传和下载在大量小文件的场景下完全不可用，删除一个百万 Key 的 Bucket 需要好几天，为此还有用户愤怒的提交工单要求将这几天的收费全部免除。&lt;/p>
&lt;p>不仅如此，Python 带来的另一个问题是静态部署很难。第一用户不一定有 Python，经常有用户提工单询问 Python 怎么安装，pip 是什么东西；第二用户不一定有我们需要的版本，有一次我修复过一个 Python 2.6 下 os.Walk 的 BUG；第三用户不一定有网络，曾经以为的 pip install 一把梭变成了支配我们很久的梦魇，逼迫我们提供一个所谓的 qsctl-offline。&lt;/p>
&lt;p>除此之外，还有 Python 2 始终阴魂不散。Python 2 会在 2020 年退役，但是我怀疑一直到 2030 年，用户的 CentOS 5.x 都不会退役，我们需要一直提供 Python 2 的技术支持。&lt;/p>
&lt;p>其次，我们还遇到了项目的陈旧架构不能满足复杂功能需求的矛盾。&lt;/p>
&lt;p>以 Copy 为例：&lt;/p>
&lt;p>&lt;img src="qsctl-trouble.png" alt="">&lt;/p>
&lt;p>这些复杂的判断都是在一个文件中完成的，没有单元测试，没有代码覆盖率的检查，只有一个简单的脚本来测试 copy 之后文件数量是否正确。&lt;/p>
&lt;p>在过去了几个月之后，我已经完全不敢去动这些代码了，更别提没有维护过 qsctl 的其他同事了。&lt;/p>
&lt;h2 id="qsctl-2-的目标">qsctl 2 的目标&lt;/h2>
&lt;p>光提问题不说方案不是 QingStor 的风格，在我们团队来了一位新同事之后，我们终于下定决定重写 qsctl，彻底解决所有的历史遗留问题。现在我得到了一次机会来重新设计和实现 qsctl，我要怎么做呢？&lt;/p>
&lt;p>我要做 &lt;strong>QingStor 有史以来最棒的命令行工具&lt;/strong>。&lt;/p>
&lt;p>最棒的含义是正确性，可维护性和性能兼备。在我看来，正确性是所有服务的根基，尤其是存储领域的服务。应用挂了能恢复，数据写错就是事故了。正确性决定了程序能不能用。而可维护性决定了这个程序能活多久，像旧版的 qsctl 已经在事实上死去了。在兼具了正确性和可维护性之后，我们会努力的去提升这个应用的性能。&lt;/p>
&lt;p>为了保障 qsctl 2 的正确性和可维护性，我们决定采用全新的方式来开发它，也就是标题中提到的 Go 模板元编程。这次分享不会过多的涉及元编程的理论和实现，主要介绍我们的实际应用。&lt;/p>
&lt;h2 id="qsctl-2-的模板">qsctl 2 的模板&lt;/h2>
&lt;p>一个最简单而朴素的想法是将所有的调用抽象为一个任务，这样我们在设计的时候就只需要考虑任务与任务之间的抽象关系，不需要考虑任务的具体实现。以初始化分段上传为例：&lt;/p>
&lt;p>&lt;img src="./init-segment.png" alt="">&lt;/p>
&lt;p>&lt;code>InitSegment &lt;/code>任务需要的 &lt;code>Input&lt;/code> 有 &lt;code>PartSize&lt;/code>，&lt;code>Storager&lt;/code> 和 &lt;code>Path&lt;/code>，&lt;code>Output&lt;/code> 有初始化分段后得到的 &lt;code>SegmentID&lt;/code>。我们首先确定有哪些任务，然后确定任务与任务之间的依赖，划分出不同的任务，之后再确定每个任务有哪些 &lt;code>Input&lt;/code> 和 &lt;code>Output&lt;/code>。但是我们并不把这些任务的关系通过函数调用的方式显式暴露出来，我们只提供一个任务互相调用的机制，即 《Unix 编程艺术》中所说的 &lt;code>提供机制，而不是策略&lt;/code>。在这些 Value 都确定之后，我们就能够以一种统一的抽象来描述每个任务：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#062873;font-weight:bold">&amp;#34;SegmentInit&amp;#34;&lt;/span>: {
&lt;span style="color:#062873;font-weight:bold">&amp;#34;description&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;init a segment upload&amp;#34;&lt;/span>,
&lt;span style="color:#062873;font-weight:bold">&amp;#34;input&amp;#34;&lt;/span>: [
&lt;span style="color:#4070a0">&amp;#34;PartSize&amp;#34;&lt;/span>,
&lt;span style="color:#4070a0">&amp;#34;Path&amp;#34;&lt;/span>,
&lt;span style="color:#4070a0">&amp;#34;Storage&amp;#34;&lt;/span>
],
&lt;span style="color:#062873;font-weight:bold">&amp;#34;output&amp;#34;&lt;/span>: [
&lt;span style="color:#4070a0">&amp;#34;SegmentID&amp;#34;&lt;/span>
]
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="type-system">Type System&lt;/h3>
&lt;p>上层抽象已经确定，下面需要考虑如何去实现。为了保证整体服务的正确性，我们期望这个任务中的所有 Value 都是强类型的，在编译期决定的，这样我们的 IDE 和编译器就能为我们免除大量的低级错误。所以我们设计了一套类型系统：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#062873;font-weight:bold">&amp;#34;PartSize&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;int64&amp;#34;&lt;/span>,
&lt;span style="color:#062873;font-weight:bold">&amp;#34;Path&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;string&amp;#34;&lt;/span>,
&lt;span style="color:#062873;font-weight:bold">&amp;#34;Storage&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;storage.Storager&amp;#34;&lt;/span>,
&lt;span style="color:#062873;font-weight:bold">&amp;#34;SegmentID&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;string&amp;#34;&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们通过一个 JSON 文件来描述实际使用的 Type Name 和内部的类型，这样就可以通过模板来生成对应的结构体：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">type&lt;/span> PartSize &lt;span style="color:#007020;font-weight:bold">struct&lt;/span> {
valid &lt;span style="color:#902000">bool&lt;/span>
v &lt;span style="color:#902000">int64&lt;/span>
l sync.RWMutex
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们还能够借此生成对应的 &lt;code>Getter&lt;/code>，&lt;code>Setter&lt;/code> 和 &lt;code>Validator&lt;/code>，以 &lt;code>Getter&lt;/code> 为例：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">type&lt;/span> PartSizeGetter &lt;span style="color:#007020;font-weight:bold">interface&lt;/span> {
&lt;span style="color:#06287e">GetPartSize&lt;/span>() &lt;span style="color:#902000">int64&lt;/span>
}
&lt;span style="color:#007020;font-weight:bold">func&lt;/span> (o &lt;span style="color:#666">*&lt;/span>PartSize) &lt;span style="color:#06287e">GetPartSize&lt;/span>() &lt;span style="color:#902000">int64&lt;/span> {
o.l.&lt;span style="color:#06287e">RLock&lt;/span>()
&lt;span style="color:#007020;font-weight:bold">defer&lt;/span> o.l.&lt;span style="color:#06287e">RUnlock&lt;/span>()
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> !o.valid {
&lt;span style="color:#007020">panic&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;PartSize value is not valid&amp;#34;&lt;/span>)
}
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> o.v
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们能够实现自动的加锁和解锁，还能够检查这个值是否有效，如果这个值无效，但是后续的代码中还是尝试去 &lt;code>Get&lt;/code> 了，我们将其认为是开发者的问题，直接 &lt;code>panic&lt;/code> 掉。不仅如此，我们还能实现任务与任务之间的 Value 自动传递：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">LoadPartSize&lt;/span>(t navvy.Task, v PartSizeSetter) {
x, ok &lt;span style="color:#666">:=&lt;/span> t.(&lt;span style="color:#007020;font-weight:bold">interface&lt;/span> {
PartSizeGetter
PartSizeValidator
})
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> !ok {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span>
}
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> !x.&lt;span style="color:#06287e">ValidatePartSize&lt;/span>() {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span>
}
v.&lt;span style="color:#06287e">SetPartSize&lt;/span>(x.&lt;span style="color:#06287e">GetPartSize&lt;/span>())
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="task-system">Task System&lt;/h3>
&lt;p>在前述 Type System 的基础上，我们可以实现我们的 Task 类型了：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#60a0b0;font-style:italic">// SegmentInitTask will init a segment upload.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">type&lt;/span> SegmentInitTask &lt;span style="color:#007020;font-weight:bold">struct&lt;/span> {
&lt;span style="color:#60a0b0;font-style:italic">// Predefined value
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#666">...&lt;/span>
&lt;span style="color:#60a0b0;font-style:italic">// Input value
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> types.PartSize
types.Path
types.Storage
&lt;span style="color:#60a0b0;font-style:italic">// Output value
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> types.SegmentID
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于每个 Task 的 &lt;code>Input&lt;/code> 和 &lt;code>Output&lt;/code> 在编译阶段就已经知道了，所以我们可以做很多事情，比如在初始化任务的时候自动载入父任务中已经存在的值：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#60a0b0;font-style:italic">// loadInput will check and load all input before new task.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> (t &lt;span style="color:#666">*&lt;/span>SegmentInitTask) &lt;span style="color:#06287e">loadInput&lt;/span>(task navvy.Task) {
&lt;span style="color:#666">...&lt;/span>
types.&lt;span style="color:#06287e">LoadPartSize&lt;/span>(task, t)
types.&lt;span style="color:#06287e">LoadPath&lt;/span>(task, t)
types.&lt;span style="color:#06287e">LoadStorage&lt;/span>(task, t)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>比如在 Task 运行之前去校验所有的 &lt;code>Input&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#60a0b0;font-style:italic">// validateInput will validate all input before run task.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> (t &lt;span style="color:#666">*&lt;/span>SegmentInitTask) &lt;span style="color:#06287e">validateInput&lt;/span>() {
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> !t.&lt;span style="color:#06287e">ValidatePartSize&lt;/span>() {
&lt;span style="color:#007020">panic&lt;/span>(fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Task SegmentInit value PartSize is invalid&amp;#34;&lt;/span>))
}
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> !t.&lt;span style="color:#06287e">ValidatePath&lt;/span>() {
&lt;span style="color:#007020">panic&lt;/span>(fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Task SegmentInit value Path is invalid&amp;#34;&lt;/span>))
}
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> !t.&lt;span style="color:#06287e">ValidateStorage&lt;/span>() {
&lt;span style="color:#007020">panic&lt;/span>(fmt.&lt;span style="color:#06287e">Errorf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Task SegmentInit value Storage is invalid&amp;#34;&lt;/span>))
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>比如自动生成这个任务的 Debug 信息：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#60a0b0;font-style:italic">// String will implement Stringer interface.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> (t &lt;span style="color:#666">*&lt;/span>SegmentInitTask) &lt;span style="color:#06287e">String&lt;/span>() &lt;span style="color:#902000">string&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> fmt.&lt;span style="color:#06287e">Sprintf&lt;/span>(
&lt;span style="color:#4070a0">&amp;#34;SegmentInitTask {PartSize: %v, Path: %v, Storage: %v}&amp;#34;&lt;/span>,
t.&lt;span style="color:#06287e">GetPartSize&lt;/span>(), t.&lt;span style="color:#06287e">GetPath&lt;/span>(), t.&lt;span style="color:#06287e">GetStorage&lt;/span>(),
)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>初始化和接口的实现也可以自动生成：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#60a0b0;font-style:italic">// NewSegmentInit will create a SegmentInitTask struct and fetch inherited data from parent task.
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">NewSegmentInit&lt;/span>(task navvy.Task) &lt;span style="color:#666">*&lt;/span>SegmentInitTask {
t &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#666">&amp;amp;&lt;/span>SegmentInitTask{}
t.&lt;span style="color:#06287e">SetID&lt;/span>(uuid.&lt;span style="color:#06287e">New&lt;/span>().&lt;span style="color:#06287e">String&lt;/span>())
t.&lt;span style="color:#06287e">loadInput&lt;/span>(task)
t.&lt;span style="color:#06287e">SetScheduler&lt;/span>(schedule.&lt;span style="color:#06287e">NewScheduler&lt;/span>(t.&lt;span style="color:#06287e">GetPool&lt;/span>()))
t.&lt;span style="color:#007020">new&lt;/span>() &lt;span style="color:#60a0b0;font-style:italic">// What we need to implement
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> t
}
&lt;span style="color:#60a0b0;font-style:italic">// Run implement navvy.Task
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> (t &lt;span style="color:#666">*&lt;/span>SegmentInitTask) &lt;span style="color:#06287e">Run&lt;/span>() {
t.&lt;span style="color:#06287e">validateInput&lt;/span>()
log.&lt;span style="color:#06287e">Debugf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Started %s&amp;#34;&lt;/span>, t)
t.&lt;span style="color:#06287e">run&lt;/span>() &lt;span style="color:#60a0b0;font-style:italic">// What we need to implement
&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> t.&lt;span style="color:#06287e">GetScheduler&lt;/span>().&lt;span style="color:#06287e">Wait&lt;/span>()
log.&lt;span style="color:#06287e">Debugf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Finished %s&amp;#34;&lt;/span>, t)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在所有的非业务逻辑代码都被自动生成之后，我们只需要专注于自己的任务即可，实现 &lt;code>InitSemgnet&lt;/code> 变成一件非常容易的事情：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">func&lt;/span> (t &lt;span style="color:#666">*&lt;/span>SegmentInitTask) &lt;span style="color:#007020">new&lt;/span>() {}
&lt;span style="color:#007020;font-weight:bold">func&lt;/span> (t &lt;span style="color:#666">*&lt;/span>SegmentInitTask) &lt;span style="color:#06287e">run&lt;/span>() {
id, err &lt;span style="color:#666">:=&lt;/span> t.&lt;span style="color:#06287e">GetStorage&lt;/span>().&lt;span style="color:#06287e">InitSegment&lt;/span>(t.&lt;span style="color:#06287e">GetPath&lt;/span>(),
typ.&lt;span style="color:#06287e">WithPartSize&lt;/span>(t.&lt;span style="color:#06287e">GetPartSize&lt;/span>()))
&lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
t.&lt;span style="color:#06287e">TriggerFault&lt;/span>(types.&lt;span style="color:#06287e">NewErrUnhandled&lt;/span>(err))
&lt;span style="color:#007020;font-weight:bold">return&lt;/span>
}
t.&lt;span style="color:#06287e">SetSegmentID&lt;/span>(id)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>每个 Task 都是独立，不需要关心谁会调用它，只要实现自己的逻辑即可。这一点使得测试变得同样容易且清晰：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">TestSegmentInitTask_run&lt;/span>(t &lt;span style="color:#666">*&lt;/span>testing.T) {
ctrl &lt;span style="color:#666">:=&lt;/span> gomock.&lt;span style="color:#06287e">NewController&lt;/span>(t)
&lt;span style="color:#007020;font-weight:bold">defer&lt;/span> ctrl.&lt;span style="color:#06287e">Finish&lt;/span>()
t.&lt;span style="color:#06287e">Run&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;normal&amp;#34;&lt;/span>, &lt;span style="color:#007020;font-weight:bold">func&lt;/span>(t &lt;span style="color:#666">*&lt;/span>testing.T) {
store &lt;span style="color:#666">:=&lt;/span> mock.&lt;span style="color:#06287e">NewMockStorager&lt;/span>(ctrl)
path &lt;span style="color:#666">:=&lt;/span> uuid.&lt;span style="color:#06287e">New&lt;/span>().&lt;span style="color:#06287e">String&lt;/span>()
segmentID &lt;span style="color:#666">:=&lt;/span> uuid.&lt;span style="color:#06287e">New&lt;/span>().&lt;span style="color:#06287e">String&lt;/span>()
task &lt;span style="color:#666">:=&lt;/span> SegmentInitTask{}
task.&lt;span style="color:#06287e">SetStorage&lt;/span>(store)
task.&lt;span style="color:#06287e">SetPath&lt;/span>(path)
task.&lt;span style="color:#06287e">SetPartSize&lt;/span>(&lt;span style="color:#40a070">1000&lt;/span>)
store.&lt;span style="color:#06287e">EXPECT&lt;/span>().&lt;span style="color:#06287e">InitSegment&lt;/span>(gomock.&lt;span style="color:#06287e">Any&lt;/span>(), gomock.&lt;span style="color:#06287e">Any&lt;/span>()).&lt;span style="color:#06287e">DoAndReturn&lt;/span>(
&lt;span style="color:#007020;font-weight:bold">func&lt;/span>(inputPath &lt;span style="color:#902000">string&lt;/span>, pairs &lt;span style="color:#666">...*&lt;/span>typ.Pair) (&lt;span style="color:#902000">string&lt;/span>, &lt;span style="color:#902000">error&lt;/span>) {
assert.&lt;span style="color:#06287e">Equal&lt;/span>(t, inputPath, path)
assert.&lt;span style="color:#06287e">Equal&lt;/span>(t, pairs[&lt;span style="color:#40a070">0&lt;/span>].Value.(&lt;span style="color:#902000">int64&lt;/span>), &lt;span style="color:#007020">int64&lt;/span>(&lt;span style="color:#40a070">1000&lt;/span>))
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> segmentID, &lt;span style="color:#007020;font-weight:bold">nil&lt;/span>
},
)
task.&lt;span style="color:#06287e">run&lt;/span>()
assert.&lt;span style="color:#06287e">Equal&lt;/span>(t, segmentID, task.&lt;span style="color:#06287e">GetSegmentID&lt;/span>())
})
t.&lt;span style="color:#06287e">Run&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;init segment returned error&amp;#34;&lt;/span>, &lt;span style="color:#007020;font-weight:bold">func&lt;/span>(t &lt;span style="color:#666">*&lt;/span>testing.T) {
store &lt;span style="color:#666">:=&lt;/span> mock.&lt;span style="color:#06287e">NewMockStorager&lt;/span>(ctrl)
path &lt;span style="color:#666">:=&lt;/span> uuid.&lt;span style="color:#06287e">New&lt;/span>().&lt;span style="color:#06287e">String&lt;/span>()
task &lt;span style="color:#666">:=&lt;/span> SegmentInitTask{}
task.&lt;span style="color:#06287e">SetFault&lt;/span>(fault.&lt;span style="color:#06287e">New&lt;/span>())
task.&lt;span style="color:#06287e">SetStorage&lt;/span>(store)
task.&lt;span style="color:#06287e">SetPath&lt;/span>(path)
task.&lt;span style="color:#06287e">SetPartSize&lt;/span>(&lt;span style="color:#40a070">1000&lt;/span>)
store.&lt;span style="color:#06287e">EXPECT&lt;/span>().&lt;span style="color:#06287e">String&lt;/span>().&lt;span style="color:#06287e">DoAndReturn&lt;/span>(&lt;span style="color:#007020;font-weight:bold">func&lt;/span>() &lt;span style="color:#902000">string&lt;/span> {
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#4070a0">&amp;#34;test storager&amp;#34;&lt;/span>
})
store.&lt;span style="color:#06287e">EXPECT&lt;/span>().&lt;span style="color:#06287e">InitSegment&lt;/span>(gomock.&lt;span style="color:#06287e">Any&lt;/span>(), gomock.&lt;span style="color:#06287e">Any&lt;/span>()).&lt;span style="color:#06287e">DoAndReturn&lt;/span>(
&lt;span style="color:#007020;font-weight:bold">func&lt;/span>(inputPath &lt;span style="color:#902000">string&lt;/span>, pairs &lt;span style="color:#666">...*&lt;/span>typ.Pair) (&lt;span style="color:#902000">string&lt;/span>, &lt;span style="color:#902000">error&lt;/span>) {
assert.&lt;span style="color:#06287e">Equal&lt;/span>(t, inputPath, path)
assert.&lt;span style="color:#06287e">Equal&lt;/span>(t, pairs[&lt;span style="color:#40a070">0&lt;/span>].Value.(&lt;span style="color:#902000">int64&lt;/span>), &lt;span style="color:#007020">int64&lt;/span>(&lt;span style="color:#40a070">1000&lt;/span>))
&lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#4070a0">&amp;#34;&amp;#34;&lt;/span>, errors.&lt;span style="color:#06287e">New&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;test&amp;#34;&lt;/span>)
},
)
task.&lt;span style="color:#06287e">run&lt;/span>()
assert.&lt;span style="color:#06287e">False&lt;/span>(t, task.&lt;span style="color:#06287e">ValidateSegmentID&lt;/span>())
assert.&lt;span style="color:#06287e">True&lt;/span>(t, task.&lt;span style="color:#06287e">GetFault&lt;/span>().&lt;span style="color:#06287e">HasError&lt;/span>())
})
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>每个任务的测试都不需要提前设置父任务，只需要设置对应的 &lt;code>Input&lt;/code> 即可。&lt;/p>
&lt;hr>
&lt;p>By the way，qsctl 2.0 昨天发布了首个 Beta 版本：&lt;a href="https://github.com/yunify/qsctl/tree/v2.0.0-beta.1">v2.0.0-beta.1&lt;/a> ，欢迎大家体验并反馈 BUG。&lt;/p>
&lt;h2 id="一些总结">一些总结&lt;/h2>
&lt;p>这一段时间的实践带给我的是思路的转变：&lt;strong>为实际的问题寻找一个合适的抽象，并针对抽象而不是实际的逻辑编程&lt;/strong>。模板元编程的助力在于减少试错的成本，在 qsctl 2 的开发过程中，Task System 的抽象及其实现进行过三次大规模的重构，大多数时间都花在思考和测试上，整体的业务逻辑迁移起来并不困难。&lt;/p>
&lt;p>银弹当然不存在，并不是所有项目都适合搞模板元编程，但是如果你的项目中有大量的重复逻辑和确定的输入输出，不妨尝试一下。&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/yunify/qsctl/pull/107">qsctl PR: New task execution framework&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/yunify/qsctl/pull/146">qsctl PR: *: Refactor task scheduler system&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/yunify/qsctl/pull/151">qsctl PR: *: Refactor task type system&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.google.com/presentation/d/1DrGBNIFXRZbMehPWygF1fsgGXypmpF83NzBxSpUBk4o/edit?usp=sharing">数据驱动编程及其在 qsctl 中的实践&lt;/a> 的 Slides&lt;/li>
&lt;/ul></description></item><item><title>Archlinux 连接并使用打印机</title><link>https://xuanwo.io/2019/09/19/archlinux-cups-connect/</link><pubDate>Thu, 19 Sep 2019 01:00:00 +0000</pubDate><guid>https://xuanwo.io/2019/09/19/archlinux-cups-connect/</guid><description>&lt;p>一直觉得折腾打印机很麻烦，所以每次都是让朋友 F 帮我打印各种材料。但是现在朋友 F 已经离职了，所以只能自己想办法搞了。本文会首先介绍操作系统与打印机通讯的原理，然后讲解如何在 Archlinux 连接并使用打印机，最后介绍常见的故障排除手段。&lt;/p>
&lt;h2 id="打印系统">打印系统&lt;/h2>
&lt;h3 id="假脱机spool">假脱机(spool)&lt;/h3>
&lt;blockquote>
&lt;p>在信息学中，假脱机（外部设备联机并行操作，SPOOL,Simultaneous Peripheral Operations On-line）是一种数据缓冲，指传输数据的过程中，将数据存放在临时工作区中。其它程序可以在之后的任意时间点对其存取。通常英语动词 spool 可以指储存设备的行为，具体表现为物理意义上的缠或卷，就比如说磁带机。最常见的假脱机的应用是打印缓存，即把打印任务加入到队列。&lt;/p>
&lt;/blockquote>
&lt;p>UNIX 和 Linux 系统会为每一个打印机创建一个任务队列，交由一个假脱机程序来管理。其他程序将打印任务提交给这个假脱机程序，然后它就会进行一系列的过滤操作最后发送到打印机上。最初大家都是用的 BSD 打印子系统，其中包含一个守护进程 lpd 和客户端命令 lpr。这个系统由 IETF 实现标准化，成为 &lt;a href="https://www.ietf.org/rfc/rfc1179.txt">RFC 1179&lt;/a> 中所述的行式打印机守护程序协议。随着打印技术的不断发展，大家也在不断的对打印系统做改进，比如 &lt;a href="http://lprng.sourceforge.net/">LPRng&lt;/a> 和 &lt;a href="https://www.cups.org/">CUPS&lt;/a>，可以支持在同一个页面上使用不同字体，支持打印图像，支持打印变宽字体，支持字距调整和连字等。&lt;/p>
&lt;p>目前使用最广泛的打印系统是 CUPS，也是 Archlinux 和很多其他 Liunx 发行版缺省的打印系统。&lt;/p>
&lt;h3 id="postscript">PostScript&lt;/h3>
&lt;p>PostScript 是主要用于电子产业和桌面出版领域的一种页面描述语言和编程语言，在 1984 年由 Adobe 开发并推向市场，在乔布斯的敦促下被改进为驱动激光打印机的语言，后来加入到 Conon 打印机中，带来了 &lt;a href="https://en.wikipedia.org/wiki/LaserWriter">Apple LaserWriter&lt;/a>，引发了二十世纪八十年代中期的桌面印刷革命，并由此成为业界标准。其后继者是同样由 Adobe 开发的 &lt;a href="https://en.wikipedia.org/wiki/PDF">PDF(Portable Document Format)&lt;/a>。&lt;/p>
&lt;h3 id="cups">CUPS&lt;/h3>
&lt;p>CUPS 打印系统会在本地启动一个名为 cupsd 的守护进程，它将会维护打印机和打印队列，自带 Web 管理工具(http://localhost:631)。&lt;/p>
&lt;p>CUPS 通过 AppSocket，IPP，LPD 等多种协议来连接到打印机并创建任务队列，之后应用程序将文件发送给 CUPS 守护进程，CUPS 通过 MIME 类型来确定文件的转换过滤器，将输入文件转换为 PostScript 格式或者其他类型，然后再发送给打印机。&lt;/p>
&lt;h2 id="连接并使用">连接并使用&lt;/h2>
&lt;h3 id="安装-cups">安装 CUPS&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">pacman -S cups
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可选择安装的其他包：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.archlinux.org/packages/extra/x86_64/cups-pdf/">&lt;code>cups-pdf&lt;/code>&lt;/a> 包可以在本地启动一个打印为 PDF 的虚拟打印机。&lt;/li>
&lt;li>&lt;a href="https://www.archlinux.org/packages/extra/x86_64/print-manager/">&lt;code>print-manager&lt;/code>&lt;/a> 是 KDE 提供的打印机和打印任务图形化管理界面&lt;/li>
&lt;li>&lt;a href="https://www.archlinux.org/packages/extra/x86_64/system-config-printer/">&lt;code>system-config-printer&lt;/code>&lt;/a> 是 GTK 下的图形化管理界面，还有 applet 支持&lt;/li>
&lt;/ul>
&lt;h3 id="启动守护进程">启动守护进程&lt;/h3>
&lt;div class="highlight">&lt;pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">systemctl start org.cups.cupsd.service
&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认情况下无需其他配置，可以访问 localhost:631 来查看服务是否正常启动&lt;/p>
&lt;h3 id="添加打印机">添加打印机&lt;/h3>
&lt;blockquote>
&lt;p>以 KDE 下使用 print-manager 为例，其他的平台应该大同小异&lt;/p>
&lt;/blockquote>
&lt;p>点击添加打印机开始添加，第一步是选择打印机协议和输入 IP 地址，根据自己打印机的实际情况进行选择：&lt;/p>
&lt;p>&lt;img src="1st.png" alt="">&lt;/p>
&lt;p>第二步选择打印机驱动：&lt;/p>
&lt;p>&lt;img src="2nd.png" alt="">&lt;/p>
&lt;p>没有找到对应的驱动，则需要自行安装，可以按照如下顺序寻找：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://aur.archlinux.org/">AUR&lt;/a>，google 搜索 &lt;code>AUR + 设备型号&lt;/code> 一般就能找到&lt;/li>
&lt;li>&lt;a href="http://www.openprinting.org/printers">Printer Listings&lt;/a>，OpenPrinting 提供的打印机驱动，放在 &lt;code>/usr/share/cups/model/&lt;/code> 下&lt;/li>
&lt;li>设备供应商网站，放在 &lt;code>/usr/share/cups/model/&lt;/code> 下&lt;/li>
&lt;/ul>
&lt;p>最后填写一些打印机的相关描述信息即可，建议写清楚一些，以免以后分不清不同打印机的位置：&lt;/p>
&lt;p>&lt;img src="3rd.png" alt="">&lt;/p>
&lt;p>打印机添加完毕后可以选择打印测试页来进行测试。&lt;/p>
&lt;h3 id="使用打印机">使用打印机&lt;/h3>
&lt;p>只需要在应用程序的菜单中点击打印然后选择刚才添加的打印机即可。&lt;/p>
&lt;h2 id="常见故障">常见故障&lt;/h2>
&lt;h3 id="无法连接上打印机">无法连接上打印机&lt;/h3>
&lt;p>检查网络，防火墙等配置，检查 IP 地址是否输入错误。&lt;/p>
&lt;h3 id="连接上打印机但是提交任务时报错-print-job-was-not-accepted">连接上打印机，但是提交任务时报错 &amp;ldquo;Print job was not accepted.&amp;rdquo;&lt;/h3>
&lt;p>首先检查自己选择的协议是否正确，然后检查自己选择的驱动是否正确&lt;/p>
&lt;h2 id="相关资料">相关资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.ibm.com/developerworks/cn/linux/l-lpic1-108-4/index.html">学习 Linux，101: 管理打印机和打印&lt;/a> 教程从 &lt;a href="http://www.lpi.org/">LPIC-1&lt;/a> 备考的角度介绍了管理和使用打印机的相关知识&lt;/li>
&lt;li>&lt;a href="https://wiki.linuxfoundation.org/openprinting/start">OpenPrinting&lt;/a> 提供了驱动程序，打印机支持等资源和信息&lt;/li>
&lt;li>维基百科词条 &lt;a href="https://zh.wikipedia.org/wiki/PostScript">PostScript&lt;/a> 详细地介绍了 PostScript 的前世今生&lt;/li>
&lt;/ul></description></item></channel></rss>