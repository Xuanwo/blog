<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Engineering Efficiency on Xuanwo&#39;s Blog</title><link>https://xuanwo.io/series/engineering-efficiency/</link><description>Recent content in Engineering Efficiency on Xuanwo&#39;s Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 06 Aug 2019 01:00:00 +0000</lastBuildDate><atom:link href="https://xuanwo.io/series/engineering-efficiency/index.xml" rel="self" type="application/rss+xml"/><item><title>开放容器标准(OCI) 内部分享</title><link>https://xuanwo.io/2019/08/06/oci-intro/</link><pubDate>Tue, 06 Aug 2019 01:00:00 +0000</pubDate><guid>https://xuanwo.io/2019/08/06/oci-intro/</guid><description>&lt;p&gt;研究工程效率提升必然逃不开容器化，容器化能够屏蔽不同项目的细节，大幅度降低构建持续集成系统的难度，只需要专注于提供平台服务即可，这对我们 Team 来说尤为重要：项目历史包袱重，开发周期长，依赖众多，还正在经历主力开发语言从 &lt;code&gt;Python&lt;/code&gt; 到 &lt;code&gt;Golang&lt;/code&gt; 到 &lt;code&gt;Rust&lt;/code&gt; 的转变。而正式发布于 2017 年的开放容器标准（OCI）的出现使得整个容器社区都在朝着标准化的方向发展，为社区注入了新的动力，很多依托于新标准的项目涌现了出来。在这样的背景下，我在例会之后进行了分享，介绍开放容器标准以及社区向着标准靠拢的努力，然后介绍一些基于标准开发的工具，最后做一些个人的展望。&lt;/p&gt;
&lt;h2 id=&#34;oci-是什么&#34;&gt;OCI 是什么？&lt;/h2&gt;
&lt;p&gt;OCI，&lt;a href=&#34;https://www.opencontainers.org&#34;&gt;Open Container Initiative&lt;/a&gt;，是一个轻量级，开放的治理结构（项目），在 Linux 基金会的支持下成立，致力于围绕容器格式和运行时创建开放的行业标准。OCI 项目由 Docker，CoreOS（后来被 Red Hat 收购了，相应的席位被 Red Hat 继承）和容器行业中的其他领导者在 2015 年 6 月的时候启动。OCI 的技术委员会成员包括 Red Hat，Microsoft，Docker，&lt;a href=&#34;https://getcruise.com/&#34;&gt;Cruise&lt;/a&gt;，IBM，Google，Red Hat 和 SUSE，其中 Docker 公司有两名成员，且其中的一位是现任主席，具体的细节可以查看 &lt;a href=&#34;https://github.com/opencontainers/tob&#34;&gt;OCI Technical Oversight Board&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;OCI 目前提出的规范有如下这些：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/opencontainers/runtime-spec&#34;&gt;Runtime Specification&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;v1.0.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/opencontainers/image-spec&#34;&gt;Image Format&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;v1.0.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/opencontainers/distribution-spec&#34;&gt;Distribution Specification&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;v1.0.0-rc0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中 runtime 和 image 的规范都已经正式发布，而 distribution 的还在工作之中。runtime 规范中介绍了如何运行解压缩到磁盘上的 &lt;a href=&#34;https://github.com/opencontainers/runtime-spec/blob/master/bundle.md&#34;&gt;&lt;code&gt;Filesystem Bundle&lt;/code&gt;&lt;/a&gt;。在 OCI 标准下，运行一个容器的过程就是下载一个 OCI 的镜像，将其解压到某个 &lt;code&gt;Filesystem Bundle&lt;/code&gt; 中，然后某个 OCI Runtime 就会运行这个 Bundle。细节此处不再展开，感兴趣的同学可以直接阅读 Spec。&lt;/p&gt;
&lt;h2 id=&#34;社区演进&#34;&gt;社区演进&lt;/h2&gt;
&lt;p&gt;标准如果没有人支持的话就只是个 Markdown 文件而已，整个容器社区为了 OCI 标准成为真正的行业标准付出了艰辛的努力。接下来我从几个侧面展开一下容器领域的各个关键组件是如何一步步走向 OCI 标准的，这个过程中也会捋清楚各个组件之间的关系。&lt;/p&gt;
&lt;h3 id=&#34;oci-in-docker&#34;&gt;OCI in docker&lt;/h3&gt;
&lt;p&gt;自从 2013 年 docker 发布之后，docker 项目本身逐渐成为了一个庞然大物。为了能够降低项目维护的成本，内部代码能够回馈社区，docker 公司提出了 “基础设施管道宣言” (Infrastructure Plumbing Manifesto)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只要有可能，重新使用现有的管道并提供改进：当您需要创建新的管道时，可以轻松地重复使用并提供改进。 这增加了可用组件的公共池，每个人都受益。&lt;/li&gt;
&lt;li&gt;遵循 UNIX 原则：几个简单的组件比一个复杂的组件要好&lt;/li&gt;
&lt;li&gt;定义标准接口：可用于将许多简单组件组合到更复杂的系统中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker 开始自行拆分自己项目中的管道代码并形成一个个新的开源项目：他们于 2014 年开源了 &lt;a href=&#34;https://github.com/docker/libcontainer&#34;&gt;libcontainer&lt;/a&gt;，并在随后的几年中陆续开源了 &lt;a href=&#34;https://github.com/docker/libnetwork&#34;&gt;libnetwork&lt;/a&gt;, &lt;a href=&#34;https://github.com/docker/notary&#34;&gt;notary&lt;/a&gt;, &lt;a href=&#34;https://github.com/docker/hyperkit&#34;&gt;hyperkit&lt;/a&gt; 等项目。在 OCI 项目启动后，docker 公司将 &lt;code&gt;libcontainer&lt;/code&gt; 的实现移动到 &lt;a href=&#34;https://github.com/opencontainers/runc&#34;&gt;runC&lt;/a&gt; 并捐赠给了 OCI。此时，容器社区有了第一个 OCI Runtime 的参考实现。runC 是一个轻量可移植的容器运行时，包括了所有之前 docker 所使用的容器相关的与系统特性的代码，它的目标是：&lt;code&gt;make standard containers available everywhere&lt;/code&gt;。随后在 2016 年，docker 开源并将 &lt;a href=&#34;https://github.com/containerd/containerd&#34;&gt;containerd&lt;/a&gt; 捐赠给了 CNCF，containerd 几乎囊括了单机运行一个容器运行时所需要的一切：执行，分发，监控，网络，构建，日志等。为了能够支持多种 OCI Runtime，containerd 内部使用 &lt;code&gt;containerd-shim&lt;/code&gt;，每启动一个容器都会创建一个新的 &lt;code&gt;containerd-shim&lt;/code&gt; 进程，指定容器 ID，Bundle 目录，运行时的二进制（比如 runc）。&lt;/p&gt;
&lt;p&gt;于是，现代 docker 启动一个标准化容器需要经历这样的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;docker-to-oci.svg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;oci-in-kubernetes&#34;&gt;OCI in Kubernetes&lt;/h3&gt;
&lt;p&gt;Kubernetes 最初只支持 docker 作为运行时，为了能够让 Kubernetes 变得更具有可扩展性，在 1.5 版本增加了 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/242a97307b34076d5d8f5bbeb154fa4d97c9ef1d/docs/devel/container-runtime-interface.md&#34;&gt;CRI: the Container Runtime Interface&lt;/a&gt;，在随后的演进中，CRI 被抽出来做成了独立的项目：&lt;a href=&#34;https://github.com/kubernetes/cri-api/&#34;&gt;https://github.com/kubernetes/cri-api/&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;CRI 是一套通过 protocol buffers 定义的 API，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;cri.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;kubelet 实现了 client 端，CRI shim 实现 server 端。只要实现了对应的接口，就能接入 k8s 作为 Container Runtime。&lt;/p&gt;
&lt;p&gt;k8s 1.5 中自己实现了 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/tree/release-1.5/pkg/kubelet/dockershim&#34;&gt;docker CRI shim&lt;/a&gt;，此时启动容器的流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;cri-docker.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;从 containerd 1.0 开始，为了能够减少一层调用的开销，containerd 开发了一个新的 daemon，叫做 CRI-Containerd，直接与 containerd 通信，从而取代了 dockershim：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;cri-containerd.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;但是这仍然多了一个独立的 daemon，从 containerd 1.1 开始，社区选择在 containerd 中直接内建 CRI plugin，通过方法调用来进行交互，从而减少一层 gRPC 的开销，最终的容器启动流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;containerd-built-in-plugin.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;最终的结果是 k8s 的 Pod 启动延迟得到了降低，CPU 和内存占用率都有不同程度的降低。&lt;/p&gt;
&lt;p&gt;但是这还不是终点，为了能够直接对接 OCI 的 runtime 而不是 containerd，社区孵化了 &lt;a href=&#34;https://github.com/cri-o/cri-o&#34;&gt;CRI-O&lt;/a&gt; 并加入了 CNCF。CRI-O 的目标是让 kubelet 与运行时直接对接，减少任何不必要的中间层开销。CRI-O 运行时可以替换为任意 OCI 兼容的 Runtime，镜像管理，存储管理和网络均使用标准化的实现，目前还在积极开发中，前途无量。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://xuxinkun.github.io/&#34;&gt;@xuxinkun&lt;/a&gt; 的文章中有个图将他们之间的关系描绘的很清楚：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;kubelet.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;项目介绍&#34;&gt;项目介绍&lt;/h2&gt;
&lt;p&gt;接下来会介绍一些支持 OCI 或者 OCI 相关的开源项目，为读者们提供一些新选择。&lt;/p&gt;
&lt;h3 id=&#34;runtime&#34;&gt;Runtime&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/opencontainers/runc&#34;&gt;opencontainers/runc&lt;/a&gt;：前面已经提到过很多次了，是 OCI Runtime 的参考实现。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kata-containers/runtime&#34;&gt;kata-containers/runtime&lt;/a&gt;：容器标准反攻虚拟机，前身是 &lt;a href=&#34;https://github.com/clearcontainers/runtime&#34;&gt;clearcontainers/runtime&lt;/a&gt; 与 &lt;a href=&#34;https://github.com/hyperhq/runv&#34;&gt;hyperhq/runv&lt;/a&gt;，通过 &lt;a href=&#34;https://github.com/kata-containers/runtime/tree/master/virtcontainers&#34;&gt;virtcontainers&lt;/a&gt; 提供高性能 OCI 标准兼容的硬件虚拟化容器，Linux Only，且需要特定硬件。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/google/gvisor&#34;&gt;google/gvisor&lt;/a&gt;：gVisor 是一个 Go 实现的用户态内核，包含了一个 OCI 兼容的 Runtime 实现，目标是提供一个可运行非受信代码的容器运行时沙盒，目前是 Linux Only，其他架构可能会支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;image-build&#34;&gt;Image Build&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/moby/buildkit&#34;&gt;moby/buildkit&lt;/a&gt;：从 docker build 拆分出来的项目，支持自动 GC，多种输入和输出格式，并发依赖解析，分布式 Worker 和 Rootless 执行等特性&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/genuinetools/img&#34;&gt;genuinetools/img&lt;/a&gt;：对 buildkit 的一层封装，单独的二进制，没有 daemon，支持 Rootless 执行，会自动创建 SUBUID，比 buildkit 使用起来更加容易&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/uber/makisu&#34;&gt;uber/makisu&lt;/a&gt;：uber 开源的内部镜像构建工具，目标是在 Mesos 或 Kubernetes 上进行 Rootless 构建，支持的 Dockerfile 有些许不兼容，在非容器环境下运行会有问题，比如 &lt;a href=&#34;https://github.com/uber/makisu/issues/233&#34;&gt;Image failed to build without modifyfs &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/GoogleContainerTools/kaniko&#34;&gt;GoogleContainerTools/kaniko&lt;/a&gt;：Google 出品，目标是 Daemon free build on Kubernetes，要求运行镜像 &lt;code&gt;gcr.io/kaniko-project/executor&lt;/code&gt; 进行构建，直接在别的镜像中使用二进制可能会不工作，很蠢&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/containers/buildah&#34;&gt;containers/buildah&lt;/a&gt;：开源组织 &lt;a href=&#34;https://github.com/containers&#34;&gt;Containers&lt;/a&gt; 推出的项目，目标是构建 OCI 容器镜像，Daemon free，支持 Rootless 构建&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tools&#34;&gt;Tools&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/containers/skopeo&#34;&gt;containers/skopeo&lt;/a&gt;：这是一个用来查看容器镜像信息的工具，可以在不用下载到本地的前提下查看远端 Registry 中的镜像信息&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/containers/libpod&#34;&gt;containers/libpod&lt;/a&gt;：二进制名为 &lt;code&gt;podman&lt;/code&gt;，支持管理 Pod，容器，镜像和存储卷，命令行与 docker CLI 完全兼容，基本上能视为 docker CLI 的 drop-in replace，镜像部分的代码主要使用了 buildah，未来还会支持 cgroups v2，人类文明之光&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;未来展望&#34;&gt;未来展望&lt;/h2&gt;
&lt;p&gt;技术的发展永远看不到尽头，也没有人知道会不会横空出现一个 docker 硬生生改变了 PaaS 平台发展的轨迹，企图当预言家的人最后都被刀了。这里列出来的是容器未来发展方向中我比较感兴趣的方面，他们更多的是现在进行时，而不是将来时，未来一年内可能就会落地。&lt;/p&gt;
&lt;h3 id=&#34;oci-artifacts&#34;&gt;OCI Artifacts&lt;/h3&gt;
&lt;p&gt;伴随着 image spec 与 distribution spec 的演化，人们开始逐步认识到除了 Container Images 之外，Registries 还能够用来分发 Kubernetes Deployment Files, Helm Charts, docker-compose, &lt;a href=&#34;https://cnab.io/&#34;&gt;CNAB&lt;/a&gt; 等产物。它们可以共用同一套 API，同一套存储，将 Registries 作为一个云存储系统。这就为带来了 OCI Artifacts 的概念，用户能够把所有的产物都存储在 OCI 兼容的 Registiry 当中并进行分发。为此，Microsoft 将 &lt;a href=&#34;https://github.com/deislabs/oras&#34;&gt;oras&lt;/a&gt; 作为一个 client 端实现捐赠给了社区，包括 Harbor 在内的多个项目都在积极的参与。&lt;/p&gt;
&lt;p&gt;到目前为止， 2.7+ 版本 Docker Distribution 和 &lt;a href=&#34;https://aka.ms/acr/docs&#34;&gt;Azure Container Registry&lt;/a&gt; 已经支持， quay.io 也在跟进。&lt;/p&gt;
&lt;h3 id=&#34;rootless-container&#34;&gt;Rootless Container&lt;/h3&gt;
&lt;p&gt;因为 Linux 下的 user namespace 过于复杂，所以 docker 刚发布的时候就没有做支持，docker 运行需要 root 权限，带来了大量的安全问题。在之后的几年中 userns 的支持被逐渐实现，尽管现在的配置还比较复杂，需要升级 runc 到特定版本，要设置 sysctl，需要安装特定的二进制，包括 newuidmap，newgidmap，还要 &lt;a href=&#34;https://github.com/rootless-containers/slirp4netns&#34;&gt;slirp4netns&lt;/a&gt; 来提供用户态网络栈支持。社区也在努力提升 Rootless Container 的体验和性能，未来大部分的工作负载都将会运行在 Rootless Container 当中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我最近的一项工作就是在 CentOS 7.5 上实现对 Rootless Container 的支持，目前我们 QingStor Team 的 CI 全部由 Rootless Container 来完成，相关的介绍将会单独成文与大家分享。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;dockerd-free-build&#34;&gt;dockerd free build&lt;/h3&gt;
&lt;p&gt;随着 docker 进入越来越多企业的生产和测试环境，依赖 &lt;code&gt;dockerd&lt;/code&gt; 来进行容器构建的机制带来的问题变得越来越严重，人们开始不断寻找和开发出不依赖 dockerd 进行构建的项目。容器镜像构建最复杂的地方在于如何处理 &lt;code&gt;RUN&lt;/code&gt; 指令，之前有些项目选择放在容器或者新的 namespace 中执行，但是随着 rootless container 的逐步完善，大家开始选择创建一个新的 userns 来执行命令，比如 buildah。&lt;/p&gt;
&lt;p&gt;我预计未来绝大多数容器构建都将会脱离 dockerd，转而使用 buildah 或者 buildkit 之类的方案。至于 kaniko 和 makisu 那种方案，我觉得没有什么发展的空间，论方便好用拼不过 buildah，论功能全面打不过 buildkit，迟早凉凉。&lt;/p&gt;
&lt;h3 id=&#34;cgroups-v2&#34;&gt;cgroups v2&lt;/h3&gt;
&lt;p&gt;容器社区与 systemd &amp;amp;&amp;amp; cgroups 的爱恨情仇简直能写成一本书，而 cgroups v2 就像是《怪物猎人：世界》雪原 这样的超大型扩充 DLC。&lt;/p&gt;
&lt;p&gt;早在 2016 年 3 月，&lt;a href=&#34;https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=34a9304a96d6351c2d35dcdc9293258378fc0bd8&#34;&gt;Linux 4.5 内核&lt;/a&gt;（cgroups v2 become official）发布后没多久，就有人提出要求支持 cgroups v2：&lt;a href=&#34;https://github.com/opencontainers/runc/issues/654&#34;&gt;support cgroup v2 (unified hierarchy)&lt;/a&gt;。然而至今进展缓慢，最开始是因为 cgroups v2 本身功能不太完善，无法满足 runc 的要求，后来是因为发行版(或者直接说是 systemd) 还没有实现真正的 cgroups v2 支持，现在是卡在了 OCI 标准强依赖于 cgroups v1 的某些实现，社区需要更新 OCI 标准来适应 cgroups v2 的变更。&lt;/p&gt;
&lt;p&gt;困难是有的，但是我还是抱有期待，相信明年的今天 &lt;em&gt;(#flag)&lt;/em&gt; 我就能用上支持 cgroups v2 的 runtime。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;这篇文章只是简单了介绍了开放容器标准和相关的一些项目，没有涉及到过多的细节，各位读者可以针对感兴趣的点向下继续探索。此外，除了附上引用地址和参考资料的片段外，其余观点均是我一家之言，各位读者请自行判断成色。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.docker.com/2015/06/runc/&#34;&gt;Introducing runC: a lightweight universal container runtime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.docker.com/2015/06/open-container-project-foundation/&#34;&gt;Docker and Broad Industry Coalition Unite to Create Open Container Project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.docker.com/docker-news-and-press/docker-extracts-and-donates-containerd-its-core-container-runtime-accelerate&#34;&gt;Docker Extracts and Donates containerd, its Core Container Runtime, to Accelerate Innovation Across the Container Ecosystem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.docker.com/2017/07/demystifying-open-container-initiative-oci-specifications/&#34;&gt;Demystifying the Open Container Initiative (OCI) Specifications&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/&#34;&gt;Introducing Container Runtime Interface (CRI) in Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/blog/2018/05/24/kubernetes-containerd-integration-goes-ga/&#34;&gt;Kubernetes Containerd Integration Goes GA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stevelasker.blog/2019/01/25/cloud-native-artifact-stores-evolve-from-container-registries/&#34;&gt;Cloud Native Artifact Registries evolve from Docker Container Registries&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/systemd/systemd/blob/master/docs/CGROUP_DELEGATION.md#three-scenarios&#34;&gt;Control Group APIs and Delegation - Three Scenarios&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.redhat.com/en/blog/preview-running-containers-without-root-rhel-76&#34;&gt;A preview of running containers without root in RHEL 7.6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xuxinkun.github.io/2017/12/12/docker-oci-runc-and-kubernetes/&#34;&gt;docker、oci、runc以及kubernetes梳理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Go Modules 内部分享</title><link>https://xuanwo.io/2019/05/27/go-modules/</link><pubDate>Mon, 27 May 2019 01:00:00 +0000</pubDate><guid>https://xuanwo.io/2019/05/27/go-modules/</guid><description>&lt;p&gt;最近在日常工作之外，我开始负责 Team 内部的工程效率提升。瞄准的第一个目标便是推动 Go Modules 在 Team 内部的普及，一方面是想淘汰祖传的依赖管理脚本，减少浪费在处理依赖问题上的时间，另一方面是为了实现 CI/CD 和可重现构建。这安利是否成功，除了要看个人的奋斗，还要看历史的行程。为了使得大家相信迁移到 Modules 好处多多，我在周一的例会后进行了一次分享，本文就是分享后的整理而成的。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;大家好，今天要跟大家分享是 Go Module。我们首先回顾一下依赖管理及其想要解决的根本问题，然后介绍 Golang 依赖管理工具发展的历史，理解我们是如何走到了如今这个时点，然后再介绍 Go Module 是什么，以及它如何解决我们面对的问题，之后以一个实际的案例来展示 Go Module 如何使用，最后是 Q &amp;amp; A 环节。&lt;/p&gt;
&lt;h2 id=&#34;依赖管理&#34;&gt;依赖管理&lt;/h2&gt;
&lt;p&gt;首先大家想一下为什么需要依赖：我们想复用已有的工作成果。而将已有的工作成果加入到我们的项目中作为依赖存在着太多的不确定性：这个包的 API 会变化，这个包内部行为会变化，这个包的依赖会变化，这个包可能已经已经不存在或无法访问，包与包之间的不同依赖相互冲突等等。不仅如此，随着软件开发规模的逐步增大，涉及到的外部依赖越来越多，手动管理的所有依赖愈发不可能。所以我们需要依赖管理，我们需要有个工具或者规范来描述和定义包与包之间的依赖关系，并自动化的去处理、解析和满足这些依赖。&lt;/p&gt;
&lt;p&gt;依赖管理试图解决的问题我认为（或者 Russ Cox 认为）主要有两个：其一是 API 稳定性，其二是可重现构建。API 稳定性自不用多说，我们都希望我们依赖的 API 是稳定的，不会因为我们更新了一个小版本就要大规模的重写我们的代码。可重现构建在我们依赖管理的领域内可以理解为相同的源码最后能得到同样的二进制或链接库（当然真正的想实现可重现构建还需要一系列配套的工具和特定的参数）。假设我们同事 A 和 B 协同开发，A 依赖了存在 BUG 的 uuid v1.2，而 B 依赖了最新的 uuid v1.3。他们都是使用了相同的代码去构建，但是最后测试的结果却不一致，这为他们进一步的排错增添了无数烦恼。特别是我们本身就在从事着底层存储系统的开发， 如果开发时和最后部署时的二进制不一致，极端情况下可能导致用户数据丢失等极其严重的后果。&lt;/p&gt;
&lt;h2 id=&#34;回溯历史&#34;&gt;回溯历史&lt;/h2&gt;
&lt;p&gt;依赖管理如此重要，Golang 社区及其开发者们都采取了哪些手段来解决这些问题呢？我们分别从 API 稳定性和可重现构建的角度来回溯一下历史，理解一下我们当下处于何种位置，这样才能知道我们要往何处去。&lt;/p&gt;
&lt;h3 id=&#34;api-稳定性&#34;&gt;API 稳定性&lt;/h3&gt;
&lt;p&gt;在 2011 年 Go 1 发布的时候就没有版本的概念，2013 年时 Golang 团队在 FAQ 中提议开发者需要保证相同的 import path 的兼容性，这个后来成了一纸空文，没有强制措施的倡议是没有人会听的。&lt;/p&gt;
&lt;p&gt;到了 2014 年，&lt;code&gt;gopkg.in&lt;/code&gt; 出现了。它本质上是一个 github 的重定向工具，将 &lt;code&gt;gopkg.in/yaml.v1&lt;/code&gt; 重定向到 &lt;a href=&#34;https://github.com/go-yaml/yaml&#34;&gt;&lt;code&gt;go-yaml/yaml&lt;/code&gt;&lt;/a&gt; 库的 v1 分支，将 &lt;code&gt;gopkg.in/yaml.v2&lt;/code&gt; 重定向到 v2 分支。它使得同一个包可以有不同的 import path，在遵守 &lt;code&gt;相同的 import path 要向后兼容&lt;/code&gt; 的前提下实现了一定程度的版本化控制，缓解了引入破坏性变更的问题。&lt;/p&gt;
&lt;p&gt;在 2015 年的时候，有人提出了采用语义化版本的草案，但是并没有被 Golang 团队接受。&lt;/p&gt;
&lt;h3 id=&#34;可重现构建&#34;&gt;可重现构建&lt;/h3&gt;
&lt;p&gt;在 Go 1 刚发布的时候，Golang 使用 GOROOT 和 GOPATH 来决定包的位置。GOROOT 和 GOPATH 结构是相似的，只不过 GOROOT 用来指示 Go 的 Root Tree 位置，GOPATH 中则是用户自定义的 Tree。GOPATH 中可以指定多个目录，go get 默认总是会把依赖下载到第一个目录中。而在查找的时候，Go 总是会先查找 GOROOT，然后在按照顺序查找 GOPATH。如果没有自行设置的话，GOROOT 会取 &lt;code&gt;/usr/lib/go&lt;/code&gt; 作为默认值，而 GOPATH 则会取 &lt;code&gt;$HOME/go&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;后来有人想到可以在运行前修改 GOPATH，使得 go get 和 go build 总是能够从一个指定目录中下载或者查找指定的包。很多人可能见过各种教你 &lt;code&gt;export GOPATH=&amp;quot;`pwd`:$GOPATH&amp;quot;&lt;/code&gt; 的奇技淫巧，顺着这种思路发展下去出现一些工具，他们能够自动的设置和修改 GOPATH，我们项目中用到的管理依赖的脚本就是这个思路。&lt;/p&gt;
&lt;p&gt;到了 2014 年，有人提出了 external packages 的概念，在项目的目录下增加一个 vendor 目录来存放外部的包，同时让 go 的 tools 能够感知到这是一个 vendor。这个草案在 2015 年时被接受，并在 go 1.5 中作为 vendor 作为试验推出，在 go 1.6 中作为默认参数被启用。自此出现&lt;/p&gt;
&lt;p&gt;到了 2016 年，一群开发者聚在一起进行了讨论，并成立一个社区组织合作开发出了 dep。dep 后来被 golang 官方接纳为 official experiment，并在很长的一段时间里被认为是有望终结 Golang 依赖管理工具混乱的统治者。&lt;/p&gt;
&lt;h2 id=&#34;versioned-modules&#34;&gt;Versioned Modules&lt;/h2&gt;
&lt;p&gt;就在所有人以为 dep 就将是那个最终的解决方案时，我们的 Russ Cox 同学有不同的想法：我们要引入 Module 的概念，我们要重新定义依赖管理。实际上从一开始 dep 就只是一个试验，用来帮助 Golang 团队积累经验和学习依赖管理，至少 Russ Cox 是这么认为的。这中间的种种故事和花边新闻大家可以去看看 &lt;a href=&#34;https://www.zhihu.com/people/caoqianli_&#34;&gt;@hsiafan&lt;/a&gt; 的文章 &lt;a href=&#34;https://zhuanlan.zhihu.com/p/41627929&#34;&gt;关于Go Module的争吵&lt;/a&gt;，此处我就不多谈了。&lt;/p&gt;
&lt;h3 id=&#34;模块&#34;&gt;模块&lt;/h3&gt;
&lt;p&gt;先来看模块。&lt;/p&gt;
&lt;p&gt;模块是&lt;strong&gt;相关连的包&lt;/strong&gt;作为&lt;strong&gt;一个单元&lt;/strong&gt;被一起&lt;strong&gt;版本化&lt;/strong&gt;后的组合。&lt;/p&gt;
&lt;p&gt;每个模块都有着确定的依赖要求，并且能够创建可复现的构建。一个仓库里可以有多个模块，一个模块里面可以有多个包。&lt;/p&gt;
&lt;h3 id=&#34;导入兼容性规则&#34;&gt;导入兼容性规则&lt;/h3&gt;
&lt;p&gt;我们可以重新阐述一下 FAQ 里面的那个兼容性规则（The Import Compatibility Rule）：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果旧包和新包具有相同的导入路径，则新包必须向后兼容旧包。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;换言之，如果他们的导入路径不同，他们就无需保持兼容。&lt;/p&gt;
&lt;h3 id=&#34;语义导入版本控制&#34;&gt;语义导入版本控制&lt;/h3&gt;
&lt;p&gt;这就为我们带来了语义导入版本控制（Semantic Import Versioning）。&lt;/p&gt;
&lt;p&gt;首先所有的模块都必须遵循语义化版本规则：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;impver.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;其次，当主版本号大于等于 &lt;code&gt;v2&lt;/code&gt; 时，这个 Module 的 import path 必须在尾部加上 &lt;code&gt;/vN&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 go.mod 文件中： &lt;code&gt;module github.com/my/mod/v2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 require 的时候： &lt;code&gt;require github.com/my/mod/v2 v2.0.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 import 的时候： &lt;code&gt;import &amp;quot;github.com/my/mod/v2/mypkg&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，当主版本号为 &lt;code&gt;v0&lt;/code&gt; 或者 &lt;code&gt;v1&lt;/code&gt; 时，尾部的 &lt;code&gt;/v0&lt;/code&gt; 或 &lt;code&gt;/v1&lt;/code&gt; 可以省略。&lt;/p&gt;
&lt;p&gt;根据语义化版本的要求，&lt;code&gt;v0&lt;/code&gt; 是不需要保证兼容性的，可以随意的引入破坏性变更，所以不需要显式的写出来；而省略 &lt;code&gt;v1&lt;/code&gt; 更大程度上是现实的考虑，毕竟 99% 的包都不会有 &lt;code&gt;v2&lt;/code&gt;，同时考虑到现有代码库的兼容，省略 &lt;code&gt;v1&lt;/code&gt; 是一个合情合理的决策。&lt;/p&gt;
&lt;h3 id=&#34;最小版本选择&#34;&gt;最小版本选择&lt;/h3&gt;
&lt;p&gt;现在我们已经可以定义出一个模块了，但是一个模块具体构建的时候到底选择是哪个版本呢？这就涉及到 Go Module 使用的最小版本选择（Minimal Version Selection）算法。&lt;/p&gt;
&lt;p&gt;它的工作方式是这样的：我们为每个模块指定的依赖都是可用于构建的最低版本，最后实际选择的版本是所有出现过的最低版本中的最大值。&lt;/p&gt;
&lt;p&gt;我们现在有这样的一个依赖关系，A 会依赖 B，C，而 B，C 会去依赖 D，D 又会依赖 E。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;version-select-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;那么我们从 A 开始做一个 BFS &lt;em&gt;（仅用于讲解原理，背后实现不一定是这样）&lt;/em&gt; ，把每个模块依赖的版本都找出来，这样我们会首先得到一个粗略的清单。然后相同的模块我们总是取最大的版本，这样就能得到最终的依赖列表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;version-select-list.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;为什么可以这样呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;导入兼容性规则&lt;/code&gt; 规定了相同的导入路径，新包必须向后兼容旧包，因此只要 D 还是 v1 版本，不管是选择 v1.3 还是 v1.4 都是可以的，不会有破坏性的变更。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;语义导入版本控制&lt;/code&gt; 规定了不同的大版本需要使用不同的导入路径，因此假设 D 升级到了 v2 版本，那就应当选择 &lt;code&gt;D v1.4&lt;/code&gt; 和 &lt;code&gt;D v2.0&lt;/code&gt; 这两个包了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么要这样做呢？&lt;/p&gt;
&lt;p&gt;为了可重现构建，为了降低复杂度。&lt;/p&gt;
&lt;p&gt;大多数包管理工具，包括 &lt;code&gt;dep&lt;/code&gt;，&lt;code&gt;cargo&lt;/code&gt; 和 &lt;code&gt;pip&lt;/code&gt; 等，采用的都是总是选择允许的最新版本（&lt;code&gt;use the newest allowed version&lt;/code&gt;）策略。这会带来两个问题：第一，&lt;code&gt;允许的最新版本&lt;/code&gt;可能会随着外部事件而发生变化，比如说在构建的时候，依赖的一个库刚好发布了一个新版本，这会导致可重现构建失效；第二，开发者为了避免依赖在构建期间发生变化，他必须显式的告诉依赖管理工具我不要哪些版本，比如：&lt;code&gt;&amp;gt;= 0.3, &amp;lt;= 0.4&lt;/code&gt;。这会导致依赖管理工具花费大量的时间去计算可用的版本，而最终的结果总是让人感到沮丧，A 依赖需要 &lt;code&gt;Z &amp;gt;= 0.5&lt;/code&gt; 而 B 依赖需要 &lt;code&gt;Z &amp;lt;= 0.4&lt;/code&gt;，关于这一点 Russ Cox 在 &lt;a href=&#34;https://research.swtch.com/version-sat&#34;&gt;Version SAT&lt;/a&gt; 给出了更加规范的论述，感兴趣的同学不妨一观。&lt;/p&gt;
&lt;p&gt;与总是选择允许的最新版本相反，Go Module 默认采用的是总是使用允许的最旧的版本。我们在 &lt;code&gt;go.mod&lt;/code&gt; 中描述的 &lt;code&gt;vX.Y.Z&lt;/code&gt; 实际上是在告诉编译器：“Hey，我最少需要 &lt;code&gt;vX.Y.Z&lt;/code&gt; 才能被 Build 出来”，编译器听完了所有模块的话之后按照刚才描述的流程就能选择出允许的最旧的那个版本。&lt;/p&gt;
&lt;h3 id=&#34;go-mod&#34;&gt;go.mod&lt;/h3&gt;
&lt;p&gt;讲了那么多理论之后，我们下面来聊一些比较实际的东西：&lt;code&gt;go.mod&lt;/code&gt; 应该要怎么写。在目前的版本当中，&lt;code&gt;go.mod&lt;/code&gt; 文件中主要有四个部分组成：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;module&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;用来声明当前 &lt;code&gt;module&lt;/code&gt;，如果当前版本大于 v1 的话，还需要在尾部显式的声明 &lt;code&gt;/vN&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module /path/to/your/mod/v2
module github.com/Xuanwo/go-mod-intro/v2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;require&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这是最为常用的部分，在 mod 之后可以写任意有效的、能指向一个引用的字符串，比如 Tag，Branch，Commit 或者是使用 &lt;code&gt;latest&lt;/code&gt; 来表示引用最新的 commit。如果对应的引用刚好是一个 Tag 的话，这个字符串会被重写为对应的 tag；如果不是的话，这个字符串会被规范化为形如 &lt;code&gt;v2.0.0-20180128182452-d3ae77c26ac8&lt;/code&gt; 这样的字符串。我们后面会发现这个字符串与底层的 mod 存储形式是相对应的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;require /your/mod tag/branch/commit
require github.com/google/go-github/v24 v24.0.1
require gopkg.in/urfave/cli.v2 v2.0.0-20180128182452-d3ae77c26ac8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;replace&lt;/code&gt; 这边的花样比较多，主要是两种，一个是与 &lt;code&gt;require&lt;/code&gt; 类似，可以指向另外一个 repo，另一种是可以指向本地的一个目录。加了 &lt;code&gt;replace&lt;/code&gt; 的话，go 在编译的时候就会使用对应的项目代码来替换。需要注意的是这个只作用于当前模块的构建，其他模块的 replace 对它不生效，同理，它的 replace 对其他模块也不会生效。&lt;/p&gt;
&lt;p&gt;需要额外注意的是，如果引用一个本地路径的话，那这个目录下必须要有 &lt;code&gt;go.mod&lt;/code&gt; 文件，这个目录可以是绝对路径，也可以是相对路径。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;replace original_name =&amp;gt; real_name tag/branch/commit
replace original_name =&amp;gt; local_path
replace test.dev/common =&amp;gt; git.example.com/bravo/common.git v0.0.0-20190520075948-958a278528f8
replace test.dev/common =&amp;gt; ../../another-porject/common-go
replace github.com/qiniu/x =&amp;gt; github.com/Xuanwo/qiniu_x v0.0.0-20190416044656-4dd63e731f37
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;exclude&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个用的比较少，主要是为了能在构建的时候排除掉特定的版本，跟 &lt;code&gt;replace&lt;/code&gt; 一样，只能作用于当前模块的构建。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;exclude /your/mod tag/branch/commit
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实战演练&#34;&gt;实战演练&lt;/h2&gt;
&lt;p&gt;好，说了那么多，下面我们实际的上手操作一下。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;/tmp&lt;/code&gt; 下创建一个目录 &lt;code&gt;go-mod-intro&lt;/code&gt;，然后输入&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;go mod init github.com/Xuanwo/go-mod-intro&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时会有输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;go: creating new go.mod: module github.com/Xuanwo/go-mod-intro&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时目录下会有一个自动创建的新文件：&lt;code&gt;go.mod&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;module github.com&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;Xuanwo&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;go&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;mod&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;intro
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;1.12&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就拥有了一个最小化的模块，尽管它什么用都没有。下面我们来写一些代码，创建一个 &lt;code&gt;main.go&lt;/code&gt; 并写入如下内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;package&lt;/span&gt; main
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;import&lt;/span&gt; (
v24 &lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#34;github.com/google/go-github/v24/github&amp;#34;&lt;/span&gt;
v25 &lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#34;github.com/google/go-github/v25/github&amp;#34;&lt;/span&gt;
)
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;var&lt;/span&gt; (
_ = v24.Tag{}
_ = v25.Tag{}
)
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#06287e&#34;&gt;main&lt;/span&gt;() {
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;return&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在当前目录下执行 &lt;code&gt;go build&lt;/code&gt;，看看 go 是如何查找依赖的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;:&lt;span style=&#34;color:#666&#34;&gt;)&lt;/span&gt; go build
go: finding github.com/google/go-github/v25/github latest
go: finding github.com/google/go-github/v24/github latest
go: finding github.com/google/go-github/v25 v25.0.4
go: finding github.com/google/go-github/v24 v24.0.1
go: downloading github.com/google/go-github/v25 v25.0.4
go: downloading github.com/google/go-github/v24 v24.0.1
go: extracting github.com/google/go-github/v25 v25.0.4
go: extracting github.com/google/go-github/v24 v24.0.1
go: finding github.com/google/go-github v17.0.0+incompatible
go: finding github.com/google/go-querystring v1.0.0
go: finding github.com/golang/protobuf v1.2.0
go: finding golang.org/x/crypto v0.0.0-20180820150726-614d502a4dac
go: finding golang.org/x/sys v0.0.0-20180824143301-4910a1d54f87
go: finding golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be
go: finding golang.org/x/net v0.0.0-20180826012351-8a410e7b638d
go: finding golang.org/x/net v0.0.0-20190311183353-d8887717615a
go: finding golang.org/x/sync v0.0.0-20190227155943-e225da77a7e6
go: finding google.golang.org/appengine v1.1.0
go: finding golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2
go: finding golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a
go: finding golang.org/x/text v0.3.0
go: downloading github.com/google/go-github v17.0.0+incompatible
go: extracting github.com/google/go-github v17.0.0+incompatible
go: downloading github.com/google/go-querystring v1.0.0
go: extracting github.com/google/go-querystring v1.0.0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，我们的 &lt;code&gt;go.mod&lt;/code&gt; 文件会被自动的重写以反应现在项目的依赖要求，&lt;code&gt;go.sum&lt;/code&gt; 文件也会被自动的创建：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;module github.com&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;Xuanwo&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;go&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;mod&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;intro
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;1.12&lt;/span&gt;
&lt;span style=&#34;color:#06287e&#34;&gt;require&lt;/span&gt; (
github.com&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;google&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;go&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;github&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;v24 v24&lt;span style=&#34;color:#40a070&#34;&gt;.0.1&lt;/span&gt;
github.com&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;google&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;go&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;github&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;v25 v25&lt;span style=&#34;color:#40a070&#34;&gt;.0.4&lt;/span&gt;
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大家不难发现，我们可以在同一个文件中引用同一个模块的不同大版本。正如我们前面所说的，它们的导入路径不同，所以被看作两个不同的模块来看待，不同的模块当然可以并存。这一点可以为我们之后的版本迁移带来很多便利，Go Team 也在尝试在 go fix 中利用这个特性来帮助库开发者实现迁移。&lt;/p&gt;
&lt;p&gt;下面我们稍微修改一下代码，引入 &lt;code&gt;golang.org/x/text&lt;/code&gt;，并尝试修改它的版本：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;package&lt;/span&gt; main
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;import&lt;/span&gt; (
v24 &lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#34;github.com/google/go-github/v24/github&amp;#34;&lt;/span&gt;
v25 &lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#34;github.com/google/go-github/v25/github&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#34;golang.org/x/text/width&amp;#34;&lt;/span&gt;
)
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;var&lt;/span&gt; (
_ = v24.Tag{}
_ = v25.Tag{}
_ = width.EastAsianAmbiguous
)
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#06287e&#34;&gt;main&lt;/span&gt;() {
&lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;return&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接构建的话，我们的 go.mod 中会增加一行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;golang.org&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;x&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;text v0&lt;span style=&#34;color:#40a070&#34;&gt;.3.0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 &lt;code&gt;go list -m all&lt;/code&gt; 可以查看当前模块所有的依赖：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;github.com/Xuanwo/go-mod-intro
github.com/golang/protobuf v1.2.0
github.com/google/go-github v17.0.0+incompatible
github.com/google/go-github/v24 v24.0.1
github.com/google/go-github/v25 v25.0.4
github.com/google/go-querystring v1.0.0
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2
golang.org/x/net v0.0.0-20190311183353-d8887717615a
golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be
golang.org/x/sync v0.0.0-20190227155943-e225da77a7e6
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a
golang.org/x/text v0.3.0
google.golang.org/appengine v1.1.0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我们把 &lt;code&gt;golang.org/x/text&lt;/code&gt; 依赖的 &lt;code&gt;v0.3.0&lt;/code&gt; 修改成 &lt;code&gt;v0.2.0&lt;/code&gt;，然后重新执行 &lt;code&gt;go list -m all&lt;/code&gt; 看最后选择的版本：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;:&lt;span style=&#34;color:#666&#34;&gt;)&lt;/span&gt; go list -m all
go: finding golang.org/x/text v0.2.0
github.com/Xuanwo/go-mod-intro
...
golang.org/x/text v0.3.0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;能发现 go 在查找了 &lt;code&gt;golang.org/x/text v0.2.0&lt;/code&gt; 之后实际选择的还是 &lt;code&gt;v0.3.0&lt;/code&gt;，我们可以用 &lt;code&gt;go mod graph | rg text&lt;/code&gt; 来看看谁在依赖这个模块：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;:&lt;span style=&#34;color:#666&#34;&gt;)&lt;/span&gt; go mod graph | rg text
github.com/Xuanwo/go-mod-intro golang.org/x/text@v0.3.0
golang.org/x/net@v0.0.0-20190311183353-d8887717615a golang.org/x/text@v0.3.0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为 &lt;code&gt;golang.org/x/net&lt;/code&gt; 在依赖 &lt;code&gt;golang.org/x/text@v0.3.0&lt;/code&gt;，所以即使我们在 &lt;code&gt;go.mod&lt;/code&gt; 中强行指定了 &lt;code&gt;v0.2.0&lt;/code&gt;，最后还是会选择 &lt;code&gt;v0.3.0&lt;/code&gt; 来进行构建，不仅如此，我们的 &lt;code&gt;go.mod&lt;/code&gt; 文件中依赖也被修改成了 &lt;code&gt;v0.3.0&lt;/code&gt;，因为这才是我们依赖的最终状态。&lt;/p&gt;
&lt;p&gt;下面我们来试一下如果指定成 &lt;code&gt;v0.3.2&lt;/code&gt; 会如何：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;:&lt;span style=&#34;color:#666&#34;&gt;)&lt;/span&gt; go list -m all
go: finding golang.org/x/text v0.3.2
github.com/Xuanwo/go-mod-intro
...
golang.org/x/text v0.3.2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然的，&lt;code&gt;v0.3.2 &amp;gt; v0.3.0&lt;/code&gt;，所以最后选择了 &lt;code&gt;v0.3.2&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;注意&#34;&gt;注意&lt;/h2&gt;
&lt;p&gt;好，在简单的实战演练之后，我们回顾一下需要额外注意的要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;replace 和 exclude 只作用于当前模块的构建，它们既不会向上继承，也不会向下传递。&lt;/li&gt;
&lt;li&gt;go 官方的所有工具都有可能在符合语义的前提下自行重写 go mod &amp;amp; sum 文件，比如补充缺失的依赖，重写 commit 为标准的形式等等&lt;/li&gt;
&lt;li&gt;所有的升级操作都需要人工确认并执行，go 官方的工具不会自动升级&lt;/li&gt;
&lt;li&gt;模块的依赖是平行的，而不是嵌套的，想象一下 BFS 把所有模块的依赖都扫出来放在一个列表里面&lt;/li&gt;
&lt;li&gt;跟 vendor 说再见，尽管 go module 对 vendor 提供了支持&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go.mod&lt;/code&gt; 中只会添加直接的依赖，间接的依赖都是隐含的，下列几种特殊情况会在后面加上 &lt;code&gt;// indirect&lt;/code&gt; 标记出来
&lt;ul&gt;
&lt;li&gt;手动指定了更高的依赖版本，比如在不引用 &lt;code&gt;golang.org/x/text&lt;/code&gt; 的前提下通过 &lt;code&gt;go get golang.org/x/text@v0.3.2
&lt;/code&gt; 升级依赖&lt;/li&gt;
&lt;li&gt;依赖的库还没有切换到 Go Module，这时候 go 工具链是不知道内部的依赖关系的，所以所有的依赖都会直接添加到当前模块中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;技巧&#34;&gt;技巧&lt;/h2&gt;
&lt;p&gt;下面我介绍一些常用的技巧：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;go list -m all&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;列出当前模块依赖的所有模块&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;go list -u -m all&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;列出当前模块依赖中可升级的模块&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;go get -u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;升级所有依赖至最新版本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;go get -u=patch&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;升级所有依赖至最新的修订版本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;go mod tidy&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;清理未使用/生效的依赖&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;q-a&#34;&gt;Q &amp;amp; A&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;module 的命名有什么最佳实践么？比如我有一个模块确定只会导入其他包，那它能不能叫 core 这样的名字？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般来说我们会用一个域名来表示该组织下面的所有模块，比如我们的可以叫做 &lt;code&gt;qingstor.dev&lt;/code&gt;。然后整个组织共享的 common 模块可以叫做 &lt;code&gt;qingstor.dev/common&lt;/code&gt;，项目相关的模块则可以进一步的分层，比如我们的对象存储可以叫做 &lt;code&gt;qingstor.dev/qs/xxx&lt;/code&gt;。为了做到这一点，我们前期可以使用 &lt;code&gt;replace&lt;/code&gt; 来过渡，后续可以自建 GOPROXY，让它来完成重定向的工作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果依赖包有了新的小版本会不会自动升级？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不会。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;vendor 还能不能用？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;go mod 可以开启 vendor 模式，但是从长期来看 vendor 会被去除。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现有的库如果已经大于等于 v2 了该怎么处理？比如 etcd 已经 v3 了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果这个库已经切换到 Go Module 的话，需要在导入时加 &lt;code&gt;/v3&lt;/code&gt;；如果还没有的话，go mod 会以兼容模式来导入它，此时虽然它的 tag 是 v3.x，但是我们还是把它们当作 v1 的模块来导入，即不需要显示在路径中写 v3。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;能够引用一个具体的 Commit？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以，go 工具链会自动的将这个 commit 重写为标准的形式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下载下来的 mod 中是否还有 git 信息？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没有。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下载下来的 mod 是如何存储的？如何区分不同 commit 的 mod？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;:) ~/Code/go/pkg/mod/github.com/google
:) tree -L 2
.
├── go-github
│   ├── v24@v24.0.1
│   ├── v24@v24.0.2-0.20190418103935-a6b4602a9129
│   └── v25@v25.0.4
├── go-github@v13.0.0+incompatible
├── go-github@v17.0.0+incompatible
└── go-querystring@v1.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;存储方式和 &lt;code&gt;go.mod&lt;/code&gt; 中规范化后的 tag/commit 是一致的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下载下来的 mod 如何清理？这只会清理当前项目用到的 mod 吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以使用 &lt;code&gt;go clean -modcache&lt;/code&gt;，这会删除所有的 mod，相当于 &lt;code&gt;$GOPATH/pkg/mod&lt;/code&gt; 被删除。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;go.sum&lt;/code&gt; 是干嘛用的？相当于其他语言里面的 lock 文件？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;go.sum&lt;/code&gt; 不是 lock 文件。&lt;/p&gt;
&lt;p&gt;在其他语言里面 lock 文件用来保证可重现构建，但是在 Go Module 中，只需要有 &lt;code&gt;go.mod&lt;/code&gt; 文件就已经足够支持可重现构建了。&lt;code&gt;go.sum&lt;/code&gt; 文件主要记录了所有在构建过程中访问到的模块的 checksums，用于保证我们的代码在传输过程中没有被纂改。&lt;/p&gt;
&lt;h2 id=&#34;分享资源&#34;&gt;分享资源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.google.com/presentation/d/1-q658rf048NrM_ecn_jWcIo87sWcXvgiID3zlih6i94/edit?usp=sharing&#34;&gt;Go Modules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Xuanwo/go-mod-intro&#34;&gt;演示 Repo: go-mod-intro&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文主要的内容都来自于 Russ Cox 关于 &lt;code&gt;Go &amp;amp; Versioning&lt;/code&gt; 的博文集，图也都是他画的，对细节感兴趣的同学可以去读一读。此外本次分享的主要目的是为了介绍 Go Module，无意于参与哪个工具更好以及什么语言的包管理工具更好的讨论，有更好的想法建议赶着 Go 2 这波车提一个新的草案。&lt;/p&gt;
&lt;p&gt;以上就是本次分享的全部内容，大家如果对 Go Module 还有什么问题的话可以在评论区提出来，我尽量解答~&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://go.googlesource.com/proposal/+/master/design/24301-versioned-go.md&#34;&gt;Proposal: Versioned Go Modules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://research.swtch.com/vgo&#34;&gt;Go &amp;amp; Versioning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/golang/go/wiki/Modules&#34;&gt;Modules - Go Wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/golang/go/issues/24301&#34;&gt;cmd/go: add package version support to Go toolchain&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>