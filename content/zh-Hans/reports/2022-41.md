---
categories: Daily
date: 2022-10-16T01:00:00Z
title: "2022-41: Rust Drop 踩坑分享"
---

Rust 使用 RAII (Resource Acquisition Is Initialization) 来管理资源：对象初始化会导致资源的初始化，而对象释放时会导致资源的释放。

以 `Mutex` 为例：

```rust
{
    let guard = m.lock();
    // do something
}
// guard freed out of scope.
{
    // we can acquire this lock again.
    let guard = m.lock();
}
```

当 `guard` 离开当前 scope 的时，rust 会保证 `guard` 的 `drop` 被自动调用：

```rust
#[stable(feature = "rust1", since = "1.0.0")]
impl<T: ?Sized> Drop for MutexGuard<'_, T> {
    #[inline]
    fn drop(&mut self) {
        unsafe {
            self.lock.poison.done(&self.poison);
            self.lock.inner.raw_unlock();
        }
    }
}
```

- 如果对应的类型有自己的 `Drop` 实现，rust 会调用 `Drop::drop()`
- 否则则递归对每个字段执行自动生成的 drop 实现

Drop 的 trait 定义如下：

```rust
pub trait Drop {
    fn drop(&mut self);
}
```

非常简单，但是在实际的使用过程中还是很容易踩坑。今天的这期周报就结合一些实际的 BUG 来聊聊我的踩坑经历。

## `_` 与 `_var` 的行为差异

`let _ = abc;` 与 `let _var = abc;` 有着不同的含义：

- `let _ = abc;` 会导致 abc 在这个语句结束后被直接释放；
- 而 `let _var = abc;` 则会创建一个新的对象，他的生命周期会一直持续到当前 scope 结束。

我们可以尝试这样一个样例 ([Try in playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=b0930efbe4353afc4bfddf1d38b55bee))：

```rust
struct Test(&'static str);

impl Drop for Test {
    fn drop(&mut self) {
        println!("Test with {} dropped", self.0)
    }
}

fn main() {
    {
        println!("into scope");
        let _ = Test("_");
        println!("leave scope");
    }
    
    println!();
    
    {
        println!("into scope");
        let _abc = Test("_abc");
        println!("leave scope");
    }
}
```

其执行结果如下：

```shell
into scope
Test with _ dropped
leave scope

into scope
leave scope
Test with _abc dropped
```

我们能够看到 `Test("_")` 在当前语句结束，`leave scope` 之前就 drop 了，而 `Test("_abc")` 在 `leave scope` 之后才结束。

在实际的业务逻辑中，我们时常会忽略这一点，以 Databend 最近修复的一个 BUG 为例：[Bug: runtime spawn_batch does not release permit correctly](https://github.com/datafuselabs/databend/issues/8183)。Databend 为了控制 IO 的并发数量，使用 semaphore 来控制任务的并行度。本来期望的时候在任务执行完毕后再释放，但是代码中使用了 `_`，导致 permits 被任务最开始就被释放了，进而导致任务的并发控制不符合预期：

```diff
 let handler = self.handle.spawn(async move {
     // take the ownership of the permit, (implicitly) drop it when task is done
-    let _ = permit;
+    let _pin = permit;
     fut.await
 });
```

## 如何手动调用 drop

处于显而易见的原因，`Drop::drop()` 不允许被手动调用，否则非常容易出现 double free 的问题，Rust 在编译器就会对这样的调用报错。如果想要控制变量的 drop，可以使用 [std::mem::drop](https://doc.rust-lang.org/std/mem/fn.drop.html) 函数，它的原理非常简单：Move 这个变量，然后不返回任何东西。

```rust
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
#[cfg_attr(not(test), rustc_diagnostic_item = "mem_drop")]
pub fn drop<T>(_x: T) {}
```

本质上相当于：

```rust
let x = Test {};

{
    x;
}
```

但是需要注意，对实现了 `Copy` 的类型来说，调用 `drop` 是没有意义的：

- 编译器会自行维护 Copy 类型在栈上的数据，不能为 Copy 类型实现 `Drop` trait
- 对 Copy 类型调用 drop 总是会复制当前变量然后释放

## 参考资料

- [透过 Rust 探索系统的本原：RAII](https://mp.weixin.qq.com/s/jaKjzc_1rkDe67rfpnFTgg)
- [Rust Doc: std::ops::Drop](https://doc.rust-lang.org/std/ops/trait.Drop.html)
- [Rust Doc: std::mem::drop](https://doc.rust-lang.org/std/mem/fn.drop.html)
